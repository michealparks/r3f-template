import {
  ArcballControls,
  DRACOLoader,
  DeviceOrientationControls,
  EffectComposer,
  FBXLoader,
  FirstPersonControls,
  Flow,
  FlyControls,
  GLTFLoader,
  GammaCorrectionShader,
  HorizontalBlurShader,
  KTX2Loader,
  Line2,
  LineGeometry,
  LineMaterial,
  LineSegmentsGeometry,
  MapControls,
  MeshoptDecoder,
  OrbitControls,
  PointerLockControls,
  RGBELoader,
  RenderPass,
  SelectionBox,
  ShaderPass,
  SimplexNoise,
  Sky,
  TrackballControls,
  TransformControls,
  VerticalBlurShader
} from "./chunk-CQFESDJV.js";
import {
  require_react_dom
} from "./chunk-6RPMZDRQ.js";
import {
  addAfterEffect,
  addEffect,
  applyProps,
  context,
  create,
  createPortal,
  extend,
  react_merge_refs_esm_default,
  useAsset,
  useFrame,
  useLoader,
  useThree
} from "./chunk-B64WSNHN.js";
import "./chunk-JENAXM66.js";
import {
  AdditiveBlending,
  AnimationMixer,
  AudioListener,
  AudioLoader,
  BackSide,
  Box3,
  BufferAttribute,
  BufferGeometry,
  Camera,
  CanvasTexture,
  Color,
  CubeCamera,
  CubeTextureLoader,
  CubicBezierCurve3,
  CylinderGeometry,
  DataTexture,
  DefaultLoadingManager,
  DepthFormat,
  DepthTexture,
  DoubleSide,
  DynamicDrawUsage,
  EdgesGeometry,
  EquirectangularReflectionMapping,
  FloatType,
  FrontSide,
  Group,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  Line3,
  LinearFilter,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NoBlending,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  QuadraticBezierCurve3,
  Quaternion,
  RGBADepthPacking,
  RGBAFormat,
  RGBFormat,
  Ray,
  Raycaster,
  RepeatWrapping,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  Shape,
  Sphere,
  Spherical,
  Texture,
  TextureLoader,
  Triangle,
  Uniform,
  UniformsUtils,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  WebGLCubeRenderTarget,
  WebGLMultisampleRenderTarget,
  WebGLRenderTarget,
  sRGBEncoding,
  three_module_exports
} from "./chunk-7RNBQYTM.js";
import {
  require_object_assign,
  require_react
} from "./chunk-7FITP5SS.js";
import {
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-WC6BDPVA.js";

// node_modules/lodash.omit/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.omit/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e2) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var omit2 = baseRest(function(object, props) {
      if (object == null) {
        return {};
      }
      props = arrayMap(baseFlatten(props, 1), toKey);
      return basePick(object, baseDifference(getAllKeysIn(object), props));
    });
    function stubArray() {
      return [];
    }
    module.exports = omit2;
  }
});

// node_modules/lodash.pick/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.pick/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function basePick(object, props) {
      object = Object(object);
      return basePickBy(object, props, function(value, key) {
        return key in object;
      });
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function baseRest(func, start2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = array;
        return apply(func, this, otherArgs);
      };
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var pick2 = baseRest(function(object, props) {
      return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
    });
    module.exports = pick2;
  }
});

// node_modules/three/examples/js/libs/stats.min.js
var require_stats_min = __commonJS({
  "node_modules/three/examples/js/libs/stats.min.js"(exports, module) {
    var Stats2 = function() {
      function h(a3) {
        c6.appendChild(a3.dom);
        return a3;
      }
      function k(a3) {
        for (var d2 = 0; d2 < c6.children.length; d2++)
          c6.children[d2].style.display = d2 === a3 ? "block" : "none";
        l2 = a3;
      }
      var l2 = 0, c6 = document.createElement("div");
      c6.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
      c6.addEventListener("click", function(a3) {
        a3.preventDefault();
        k(++l2 % c6.children.length);
      }, false);
      var g = (performance || Date).now(), e2 = g, a2 = 0, r2 = h(new Stats2.Panel("FPS", "#0ff", "#002")), f = h(new Stats2.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory)
        var t2 = h(new Stats2.Panel("MB", "#f08", "#201"));
      k(0);
      return { REVISION: 16, dom: c6, addPanel: h, showPanel: k, begin: function() {
        g = (performance || Date).now();
      }, end: function() {
        a2++;
        var c7 = (performance || Date).now();
        f.update(c7 - g, 200);
        if (c7 > e2 + 1e3 && (r2.update(1e3 * a2 / (c7 - e2), 100), e2 = c7, a2 = 0, t2)) {
          var d2 = performance.memory;
          t2.update(d2.usedJSHeapSize / 1048576, d2.jsHeapSizeLimit / 1048576);
        }
        return c7;
      }, update: function() {
        g = this.end();
      }, domElement: c6, setMode: k };
    };
    Stats2.Panel = function(h, k, l2) {
      var c6 = Infinity, g = 0, e2 = Math.round, a2 = e2(window.devicePixelRatio || 1), r2 = 80 * a2, f = 48 * a2, t2 = 3 * a2, u = 2 * a2, d2 = 3 * a2, m = 15 * a2, n2 = 74 * a2, p = 30 * a2, q = document.createElement("canvas");
      q.width = r2;
      q.height = f;
      q.style.cssText = "width:80px;height:48px";
      var b = q.getContext("2d");
      b.font = "bold " + 9 * a2 + "px Helvetica,Arial,sans-serif";
      b.textBaseline = "top";
      b.fillStyle = l2;
      b.fillRect(0, 0, r2, f);
      b.fillStyle = k;
      b.fillText(h, t2, u);
      b.fillRect(d2, m, n2, p);
      b.fillStyle = l2;
      b.globalAlpha = 0.9;
      b.fillRect(d2, m, n2, p);
      return { dom: q, update: function(f2, v4) {
        c6 = Math.min(c6, f2);
        g = Math.max(g, f2);
        b.fillStyle = l2;
        b.globalAlpha = 1;
        b.fillRect(0, 0, r2, m);
        b.fillStyle = k;
        b.fillText(e2(f2) + " " + h + " (" + e2(c6) + "-" + e2(g) + ")", t2, u);
        b.drawImage(q, d2 + a2, m, n2 - a2, p, d2, m, n2 - a2, p);
        b.fillRect(d2 + n2 - a2, m, a2, p);
        b.fillStyle = l2;
        b.globalAlpha = 0.9;
        b.fillRect(d2 + n2 - a2, m, a2, e2((1 - f2 / v4) * p));
      } };
    };
    typeof module === "object" && (module.exports = Stats2);
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment4 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment4;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign4 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is2(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey2 = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey2] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey2] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i4 = 0; i4 < propValue.length; i4++) {
            var error = typeChecker(propValue, i4, componentName, location, propFullName + "[" + i4 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i4 = 0; i4 < expectedValues.length; i4++) {
            if (is2(propValue, expectedValues[i4])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
          var checker = arrayOfTypeCheckers[i4];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i4 + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i5 = 0; i5 < arrayOfTypeCheckers.length; i5++) {
            var checker2 = arrayOfTypeCheckers[i5];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign4({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@react-three/drei/web/Html.js
var React = __toModule(require_react());
var ReactDOM = __toModule(require_react_dom());
var v1 = new Vector3();
var v2 = new Vector3();
var v3 = new Vector3();
function defaultCalculatePosition(el, camera, size) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}
function isObjectBehindCamera(el, camera) {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}
function isObjectVisible(el, camera, raycaster, occlude) {
  const elPos = v1.setFromMatrixPosition(el.matrixWorld);
  const screenPos = elPos.clone();
  screenPos.project(camera);
  raycaster.setFromCamera(screenPos, camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
}
function objectScale(el, camera) {
  if (camera instanceof OrthographicCamera) {
    return camera.zoom;
  } else if (camera instanceof PerspectiveCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
}
function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }
  return void 0;
}
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
function getCSSMatrix(matrix2, multipliers, prepend = "") {
  let matrix3d = "matrix3d(";
  for (let i4 = 0; i4 !== 16; i4++) {
    matrix3d += epsilon(multipliers[i4] * matrix2.elements[i4]) + (i4 !== 15 ? "," : ")");
  }
  return prepend + matrix3d;
}
var getCameraCSSMatrix = ((multipliers) => {
  return (matrix2) => getCSSMatrix(matrix2, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = ((scaleMultipliers) => {
  return (matrix2, factor) => getCSSMatrix(matrix2, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [1 / f, 1 / f, 1 / f, 1, -1 / f, -1 / f, -1 / f, -1, 1 / f, 1 / f, 1 / f, 1, 1, 1, 1, 1]);
var Html = React.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    eps: eps2 = 1e-3,
    style,
    className,
    prepend,
    center,
    fullscreen,
    portal,
    distanceFactor,
    sprite = false,
    transform = false,
    occlude,
    onOcclude,
    zIndexRange = [16777271, 0],
    calculatePosition = defaultCalculatePosition,
    as = "div",
    wrapperClass,
    pointerEvents = "auto"
  } = _b, props = __objRest(_b, [
    "children",
    "eps",
    "style",
    "className",
    "prepend",
    "center",
    "fullscreen",
    "portal",
    "distanceFactor",
    "sprite",
    "transform",
    "occlude",
    "onOcclude",
    "zIndexRange",
    "calculatePosition",
    "as",
    "wrapperClass",
    "pointerEvents"
  ]);
  var _portal$current;
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  const size = useThree(({
    size: size2
  }) => size2);
  const raycaster = useThree(({
    raycaster: raycaster2
  }) => raycaster2);
  const [el] = React.useState(() => document.createElement(as));
  const group = React.useRef(null);
  const oldZoom = React.useRef(0);
  const oldPosition = React.useRef([0, 0]);
  const transformOuterRef = React.useRef(null);
  const transformInnerRef = React.useRef(null);
  const target2 = (_portal$current = portal == null ? void 0 : portal.current) !== null && _portal$current !== void 0 ? _portal$current : gl.domElement.parentNode;
  React.useEffect(() => {
    if (group.current) {
      scene.updateMatrixWorld();
      if (transform) {
        el.style.cssText = `position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;`;
      } else {
        const vec2 = calculatePosition(group.current, camera, size);
        el.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${vec2[0]}px,${vec2[1]}px,0);transform-origin:0 0;`;
      }
      if (target2) {
        if (prepend)
          target2.prepend(el);
        else
          target2.appendChild(el);
      }
      return () => {
        if (target2)
          target2.removeChild(el);
        ReactDOM.unmountComponentAtNode(el);
      };
    }
  }, [target2, transform]);
  React.useLayoutEffect(() => {
    if (wrapperClass)
      el.className = wrapperClass;
  }, [wrapperClass]);
  const styles2 = React.useMemo(() => {
    if (transform) {
      return {
        position: "absolute",
        top: 0,
        left: 0,
        width: size.width,
        height: size.height,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
      };
    } else {
      return __spreadValues(__spreadValues({
        position: "absolute",
        transform: center ? "translate3d(-50%,-50%,0)" : "none"
      }, fullscreen && {
        top: -size.height / 2,
        left: -size.width / 2,
        width: size.width,
        height: size.height
      }), style);
    }
  }, [style, center, fullscreen, size, transform]);
  const transformInnerStyles = React.useMemo(() => ({
    position: "absolute",
    pointerEvents
  }), [pointerEvents]);
  React.useLayoutEffect(() => {
    if (transform) {
      ReactDOM.render(React.createElement("div", {
        ref: transformOuterRef,
        style: styles2
      }, React.createElement("div", {
        ref: transformInnerRef,
        style: transformInnerStyles
      }, React.createElement("div", {
        ref,
        className,
        style,
        children
      }))), el);
    } else {
      ReactDOM.render(React.createElement("div", {
        ref,
        style: styles2,
        className,
        children
      }), el);
    }
  });
  const visible = React.useRef(true);
  useFrame(() => {
    if (group.current) {
      camera.updateMatrixWorld();
      group.current.updateWorldMatrix(true, false);
      const vec2 = transform ? oldPosition.current : calculatePosition(group.current, camera, size);
      if (transform || Math.abs(oldZoom.current - camera.zoom) > eps2 || Math.abs(oldPosition.current[0] - vec2[0]) > eps2 || Math.abs(oldPosition.current[1] - vec2[1]) > eps2) {
        const isBehindCamera = isObjectBehindCamera(group.current, camera);
        let raytraceTarget = false;
        if (typeof occlude === "boolean") {
          if (occlude === true) {
            raytraceTarget = [scene];
          }
        } else if (Array.isArray(occlude)) {
          raytraceTarget = occlude.map((item) => item.current);
        }
        const previouslyVisible = visible.current;
        if (raytraceTarget) {
          const isvisible = isObjectVisible(group.current, camera, raycaster, raytraceTarget);
          visible.current = isvisible && !isBehindCamera;
        } else {
          visible.current = !isBehindCamera;
        }
        if (previouslyVisible !== visible.current) {
          if (onOcclude)
            onOcclude(!visible.current);
          else
            el.style.display = visible.current ? "block" : "none";
        }
        el.style.zIndex = `${objectZIndex(group.current, camera, zIndexRange)}`;
        if (transform) {
          const [widthHalf, heightHalf] = [size.width / 2, size.height / 2];
          const fov = camera.projectionMatrix.elements[5] * heightHalf;
          const {
            isOrthographicCamera,
            top,
            left,
            bottom,
            right
          } = camera;
          const cameraMatrix = getCameraCSSMatrix(camera.matrixWorldInverse);
          const cameraTransform = isOrthographicCamera ? `scale(${fov})translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;
          let matrix2 = group.current.matrixWorld;
          if (sprite) {
            matrix2 = camera.matrixWorldInverse.clone().transpose().copyPosition(matrix2).scale(group.current.scale);
            matrix2.elements[3] = matrix2.elements[7] = matrix2.elements[11] = 0;
            matrix2.elements[15] = 1;
          }
          el.style.width = size.width + "px";
          el.style.height = size.height + "px";
          el.style.perspective = isOrthographicCamera ? "" : `${fov}px`;
          if (transformOuterRef.current && transformInnerRef.current) {
            transformOuterRef.current.style.transform = `${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`;
            transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix2, 1 / ((distanceFactor || 10) / 400));
          }
        } else {
          const scale2 = distanceFactor === void 0 ? 1 : objectScale(group.current, camera) * distanceFactor;
          el.style.transform = `translate3d(${vec2[0]}px,${vec2[1]}px,0) scale(${scale2})`;
        }
        oldPosition.current = vec2;
        oldZoom.current = camera.zoom;
      }
    }
  });
  return React.createElement("group", _extends({}, props, {
    ref: group
  }));
});

// node_modules/@react-three/drei/web/CycleRaycast.js
var React2 = __toModule(require_react());
function CycleRaycast({
  onChanged,
  portal,
  preventDefault = true,
  scroll = true,
  keyCode = 9
}) {
  const cycle = React2.useRef(0);
  const raycaster = useThree((state) => state.raycaster);
  const get = useThree((state) => state.get);
  const gl = useThree((state) => state.gl);
  React2.useEffect(() => {
    var _portal$current;
    let hits = [];
    let lastEvent = void 0;
    const prev = raycaster.filter;
    const target2 = (_portal$current = portal == null ? void 0 : portal.current) !== null && _portal$current !== void 0 ? _portal$current : gl.domElement.parentNode;
    const renderStatus = () => target2 && onChanged && onChanged(hits, Math.round(cycle.current) % hits.length);
    raycaster.filter = (intersections, state) => {
      let clone = [...intersections];
      if (clone.length !== hits.length || !hits.every((hit) => clone.map((e2) => e2.object.uuid).includes(hit.object.uuid))) {
        cycle.current = 0;
        hits = clone;
        renderStatus();
      }
      if (prev)
        clone = prev(clone, state);
      for (let i4 = 0; i4 < Math.round(cycle.current) % clone.length; i4++) {
        const first = clone.shift();
        clone = [...clone, first];
      }
      return clone;
    };
    const refresh = (fn) => {
      var _get$events$handlers, _get$events$handlers2;
      cycle.current = fn(cycle.current);
      (_get$events$handlers = get().events.handlers) == null ? void 0 : _get$events$handlers.onPointerCancel(void 0);
      (_get$events$handlers2 = get().events.handlers) == null ? void 0 : _get$events$handlers2.onPointerMove(lastEvent);
      renderStatus();
    };
    const tabEvent = (event) => {
      if (event.keyCode || event.which === keyCode) {
        if (preventDefault)
          event.preventDefault();
        if (hits.length > 1)
          refresh((current) => current + 1);
      }
    };
    const wheelEvent = (event) => {
      if (preventDefault)
        event.preventDefault();
      let delta = 0;
      if (!event)
        event = window.event;
      if (event.wheelDelta)
        delta = event.wheelDelta / 120;
      else if (event.detail)
        delta = -event.detail / 3;
      if (hits.length > 1)
        refresh((current) => Math.abs(current - delta));
    };
    const moveEvent = (event) => lastEvent = event;
    document.addEventListener("pointermove", moveEvent, {
      passive: true
    });
    if (scroll)
      document.addEventListener("wheel", wheelEvent);
    if (keyCode !== void 0)
      document.addEventListener("keydown", tabEvent);
    return () => {
      raycaster.filter = prev;
      if (keyCode !== void 0)
        document.removeEventListener("keydown", tabEvent);
      if (scroll)
        document.removeEventListener("wheel", wheelEvent);
      document.removeEventListener("pointermove", moveEvent);
    };
  }, [gl, get, raycaster, preventDefault, scroll, keyCode]);
  return null;
}

// node_modules/@react-three/drei/web/useCursor.js
var React3 = __toModule(require_react());
function useCursor(hovered, onPointerOver = "pointer", onPointerOut = "auto") {
  React3.useEffect(() => {
    if (hovered) {
      document.body.style.cursor = onPointerOver;
      return () => void (document.body.style.cursor = onPointerOut);
    }
  }, [hovered]);
}

// node_modules/@react-three/drei/web/Loader.js
var React4 = __toModule(require_react());

// node_modules/@react-three/drei/core/useProgress.js
var saveLastTotalLoaded = 0;
var useProgress = create((set) => {
  DefaultLoadingManager.onStart = (item, loaded, total) => {
    set({
      active: true,
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100
    });
  };
  DefaultLoadingManager.onLoad = () => {
    set({
      active: false
    });
  };
  DefaultLoadingManager.onError = (item) => set((state) => ({
    errors: [...state.errors, item]
  }));
  DefaultLoadingManager.onProgress = (item, loaded, total) => {
    if (loaded === total) {
      saveLastTotalLoaded = total;
    }
    set({
      active: true,
      item,
      loaded,
      total,
      progress: (loaded - saveLastTotalLoaded) / (total - saveLastTotalLoaded) * 100 || 100
    });
  };
  return {
    errors: [],
    active: false,
    progress: 0,
    item: "",
    loaded: 0,
    total: 0
  };
});

// node_modules/@react-three/drei/web/Loader.js
var defaultDataInterpolation = (p) => `Loading ${p.toFixed(2)}%`;
function Loader({
  containerStyles,
  innerStyles,
  barStyles,
  dataStyles,
  dataInterpolation = defaultDataInterpolation,
  initialState = (active) => active
}) {
  const {
    active,
    progress
  } = useProgress();
  const progressRef = React4.useRef(0);
  const rafRef = React4.useRef(0);
  const progressSpanRef = React4.useRef(null);
  const [shown, setShown] = React4.useState(initialState(active));
  React4.useEffect(() => {
    let t2;
    if (active !== shown)
      t2 = setTimeout(() => setShown(active), 300);
    return () => clearTimeout(t2);
  }, [shown, active]);
  const updateProgress = React4.useCallback(() => {
    if (!progressSpanRef.current)
      return;
    progressRef.current += (progress - progressRef.current) / 2;
    if (progressRef.current > 0.95 * progress || progress === 100)
      progressRef.current = progress;
    progressSpanRef.current.innerText = dataInterpolation(progressRef.current);
    if (progressRef.current < progress)
      rafRef.current = requestAnimationFrame(updateProgress);
  }, [dataInterpolation, progress]);
  React4.useEffect(() => {
    updateProgress();
    return () => cancelAnimationFrame(rafRef.current);
  }, [updateProgress]);
  return shown ? React4.createElement("div", {
    style: __spreadValues(__spreadProps(__spreadValues({}, styles.container), {
      opacity: active ? 1 : 0
    }), containerStyles)
  }, React4.createElement("div", null, React4.createElement("div", {
    style: __spreadValues(__spreadValues({}, styles.inner), innerStyles)
  }, React4.createElement("div", {
    style: __spreadValues(__spreadProps(__spreadValues({}, styles.bar), {
      transform: `scaleX(${progress / 100})`
    }), barStyles)
  }), React4.createElement("span", {
    ref: progressSpanRef,
    style: __spreadValues(__spreadValues({}, styles.data), dataStyles)
  })))) : null;
}
var styles = {
  container: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    background: "#171717",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: "opacity 300ms ease",
    zIndex: 1e3
  },
  inner: {
    width: 100,
    height: 3,
    background: "#272727",
    textAlign: "center"
  },
  bar: {
    height: 3,
    width: "100%",
    background: "white",
    transition: "transform 200ms",
    transformOrigin: "left center"
  },
  data: {
    display: "inline-block",
    position: "relative",
    fontVariantNumeric: "tabular-nums",
    marginTop: "0.8em",
    color: "#f0f0f0",
    fontSize: "0.6em",
    fontFamily: `-apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", "Helvetica Neue", Helvetica, Arial, Roboto, Ubuntu, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    whiteSpace: "nowrap"
  }
};

// node_modules/@react-three/drei/web/ScrollControls.js
var React5 = __toModule(require_react());
var ReactDOM2 = __toModule(require_react_dom());
var context2 = React5.createContext(null);
function useScroll() {
  return React5.useContext(context2);
}
function ScrollControls({
  eps: eps2 = 1e-5,
  enabled = true,
  infinite,
  horizontal,
  pages = 1,
  distance = 1,
  damping = 4,
  style = {},
  children
}) {
  const {
    gl,
    size,
    invalidate,
    events,
    raycaster
  } = useThree();
  const [el] = React5.useState(() => document.createElement("div"));
  const [fill] = React5.useState(() => document.createElement("div"));
  const [fixed] = React5.useState(() => document.createElement("div"));
  const target2 = gl.domElement.parentNode;
  const scroll = React5.useRef(0);
  const state = React5.useMemo(() => {
    const state2 = {
      el,
      eps: eps2,
      fill,
      fixed,
      horizontal,
      damping,
      offset: 0,
      delta: 0,
      scroll,
      pages,
      range(from, distance2, margin = 0) {
        const start2 = from - margin;
        const end = start2 + distance2 + margin * 2;
        return this.offset < start2 ? 0 : this.offset > end ? 1 : (this.offset - start2) / (end - start2);
      },
      curve(from, distance2, margin = 0) {
        return Math.sin(this.range(from, distance2, margin) * Math.PI);
      },
      visible(from, distance2, margin = 0) {
        const start2 = from - margin;
        const end = start2 + distance2 + margin * 2;
        return this.offset >= start2 && this.offset <= end;
      }
    };
    return state2;
  }, [eps2, damping, horizontal, pages]);
  React5.useEffect(() => {
    el.style.position = "absolute";
    el.style.width = "100%";
    el.style.height = "100%";
    el.style[horizontal ? "overflowX" : "overflowY"] = "auto";
    el.style[horizontal ? "overflowY" : "overflowX"] = "hidden";
    el.style.top = "0px";
    el.style.left = "0px";
    for (const key in style) {
      el.style[key] = style[key];
    }
    fixed.style.position = "sticky";
    fixed.style.top = "0px";
    fixed.style.left = "0px";
    fixed.style.width = "100%";
    fixed.style.height = "100%";
    fixed.style.overflow = "hidden";
    el.appendChild(fixed);
    fill.style.height = horizontal ? "100%" : `${pages * distance * 100}%`;
    fill.style.width = horizontal ? `${pages * distance * 100}%` : "100%";
    fill.style.pointerEvents = "none";
    el.appendChild(fill);
    target2.appendChild(el);
    el[horizontal ? "scrollLeft" : "scrollTop"] = 1;
    const oldTarget = typeof events.connected !== "boolean" ? events.connected : gl.domElement;
    requestAnimationFrame(() => events.connect == null ? void 0 : events.connect(el));
    const oldCompute = raycaster.computeOffsets;
    raycaster.computeOffsets = ({
      clientX,
      clientY
    }) => ({
      offsetX: clientX - target2.offsetLeft,
      offsetY: clientY - target2.offsetTop
    });
    return () => {
      target2.removeChild(el);
      raycaster.computeOffsets = oldCompute;
      events.connect == null ? void 0 : events.connect(oldTarget);
    };
  }, [pages, distance, horizontal, el, fill, fixed, target2]);
  React5.useEffect(() => {
    const containerLength = size[horizontal ? "width" : "height"];
    const scrollLength = el[horizontal ? "scrollWidth" : "scrollHeight"];
    const scrollThreshold = scrollLength - containerLength;
    let current = 0;
    let disableScroll = true;
    let firstRun = true;
    const onScroll = () => {
      if (!enabled || firstRun)
        return;
      invalidate();
      current = el[horizontal ? "scrollLeft" : "scrollTop"];
      scroll.current = current / scrollThreshold;
      if (infinite) {
        if (!disableScroll) {
          if (current >= scrollThreshold) {
            const damp = 1 - state.offset;
            el[horizontal ? "scrollLeft" : "scrollTop"] = 1;
            scroll.current = state.offset = -damp;
            disableScroll = true;
          } else if (current <= 0) {
            const damp = 1 + state.offset;
            el[horizontal ? "scrollLeft" : "scrollTop"] = scrollLength;
            scroll.current = state.offset = damp;
            disableScroll = true;
          }
        }
        if (disableScroll)
          setTimeout(() => disableScroll = false, 40);
      }
    };
    el.addEventListener("scroll", onScroll, {
      passive: true
    });
    requestAnimationFrame(() => firstRun = false);
    const onWheel = (e2) => el.scrollLeft += e2.deltaY / 2;
    if (horizontal)
      el.addEventListener("wheel", onWheel, {
        passive: true
      });
    return () => {
      el.removeEventListener("scroll", onScroll);
      if (horizontal)
        el.removeEventListener("wheel", onWheel);
    };
  }, [el, size, infinite, state, invalidate, horizontal]);
  let last = 0;
  useFrame((_, delta) => {
    state.offset = MathUtils.damp(last = state.offset, scroll.current, damping, delta);
    state.delta = MathUtils.damp(state.delta, Math.abs(last - state.offset), damping, delta);
    if (state.delta > eps2)
      invalidate();
  });
  return React5.createElement(context2.Provider, {
    value: state
  }, children);
}
var ScrollCanvas = React5.forwardRef(({
  children
}, ref) => {
  const group = React5.useRef(null);
  const state = useScroll();
  const {
    width,
    height
  } = useThree((state2) => state2.viewport);
  useFrame(() => {
    group.current.position.x = state.horizontal ? -width * (state.pages - 1) * state.offset : 0;
    group.current.position.y = state.horizontal ? 0 : height * (state.pages - 1) * state.offset;
  });
  return React5.createElement("group", {
    ref: react_merge_refs_esm_default([ref, group])
  }, children);
});
var ScrollHtml = React5.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    style
  } = _b, props = __objRest(_b, [
    "children",
    "style"
  ]);
  const state = useScroll();
  const group = React5.useRef(null);
  const {
    width,
    height
  } = useThree((state2) => state2.size);
  const fiberState = React5.useContext(context);
  useFrame(() => {
    if (state.delta > state.eps) {
      group.current.style.transform = `translate3d(${state.horizontal ? -width * (state.pages - 1) * state.offset : 0}px,${state.horizontal ? 0 : height * (state.pages - 1) * -state.offset}px,0)`;
    }
  });
  ReactDOM2.render(React5.createElement("div", _extends({
    ref: react_merge_refs_esm_default([ref, group]),
    style: __spreadProps(__spreadValues({}, style), {
      position: "absolute",
      top: 0,
      left: 0,
      willChange: "transform"
    })
  }, props), React5.createElement(context2.Provider, {
    value: state
  }, React5.createElement(context.Provider, {
    value: fiberState
  }, children))), state.fixed);
  return null;
});
var Scroll = React5.forwardRef((_a, ref) => {
  var _b = _a, {
    html
  } = _b, props = __objRest(_b, [
    "html"
  ]);
  const El = html ? ScrollHtml : ScrollCanvas;
  return React5.createElement(El, _extends({
    ref
  }, props));
});

// node_modules/@react-three/drei/web/PresentationControls.js
var React10 = __toModule(require_react());

// node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  let time = raf.now() + ms;
  let cancel = () => {
    let i4 = timeouts.findIndex((t2) => t2.cancel == cancel);
    if (~i4)
      timeouts.splice(i4, 1);
    pendingCount -= ~i4 ? 1 : 0;
  };
  let timeout = {
    time,
    handler,
    cancel
  };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t2) => t2.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
  onFinishQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
};
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  let prevTs = ts;
  ts = raf.now();
  let count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t2) => t2.handler());
    pendingCount -= count;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
  if (!pendingCount) {
    stop();
  }
}
function makeQueue() {
  let next = new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e2) {
      raf.catch(e2);
    }
  });
}

// node_modules/@react-spring/shared/dist/react-spring-shared.esm.js
var React6 = __toModule(require_react());
var import_react = __toModule(require_react());
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
  value,
  writable: true,
  configurable: true
});
var is = {
  arr: Array.isArray,
  obj: (a2) => !!a2 && a2.constructor.name === "Object",
  fun: (a2) => typeof a2 === "function",
  str: (a2) => typeof a2 === "string",
  num: (a2) => typeof a2 === "number",
  und: (a2) => a2 === void 0
};
function isEqual(a2, b) {
  if (is.arr(a2)) {
    if (!is.arr(b) || a2.length !== b.length)
      return false;
    for (let i4 = 0; i4 < a2.length; i4++) {
      if (a2[i4] !== b[i4])
        return false;
    }
    return true;
  }
  return a2 === b;
}
var each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx2) {
  if (is.arr(obj)) {
    for (let i4 = 0; i4 < obj.length; i4++) {
      fn.call(ctx2, obj[i4], `${i4}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a2) => is.und(a2) ? [] : is.arr(a2) ? a2 : [a2];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator$1;
var to;
var colors$1 = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals2) => {
  if (globals2.to)
    to = globals2.to;
  if (globals2.now)
    raf.now = globals2.now;
  if (globals2.colors !== void 0)
    colors$1 = globals2.colors;
  if (globals2.skipAnimation != null)
    skipAnimation = globals2.skipAnimation;
  if (globals2.createStringInterpolator)
    createStringInterpolator$1 = globals2.createStringInterpolator;
  if (globals2.requestAnimationFrame)
    raf.use(globals2.requestAnimationFrame);
  if (globals2.batchedUpdates)
    raf.batchedUpdates = globals2.batchedUpdates;
  if (globals2.willAdvance)
    willAdvance = globals2.willAdvance;
  if (globals2.frameLoop)
    raf.frameLoop = globals2.frameLoop;
};
var globals = Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return createStringInterpolator$1;
  },
  get to() {
    return to;
  },
  get colors() {
    return colors$1;
  },
  get skipAnimation() {
    return skipAnimation;
  },
  get willAdvance() {
    return willAdvance;
  },
  assign
});
var startQueue = new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  advance,
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i4 = 0; i4 < currentFrame.length; i4++) {
    const animation = currentFrame[i4];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}
var colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color3) {
  let match;
  if (typeof color3 === "number") {
    return color3 >>> 0 === color3 && color3 >= 0 && color3 <= 4294967295 ? color3 : null;
  }
  if (match = hex6.exec(color3))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors$1 && colors$1[color3] !== void 0) {
    return colors$1[color3];
  }
  if (match = rgb.exec(color3)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
  }
  if (match = rgba.exec(color3)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
  }
  if (match = hex3.exec(color3)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
  }
  if (match = hex8.exec(color3))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color3)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
  }
  if (match = hsl.exec(color3)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
  }
  if (match = hsla.exec(color3)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
  }
  return null;
}
function hue2rgb(p, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p + (q - p) * (2 / 3 - t2) * 6;
  return p;
}
function hslToRgb(h, s, l2) {
  const q = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
  const p = 2 * l2 - q;
  const r2 = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r2 * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  let r2 = (int32Color & 4278190080) >>> 24;
  let g = (int32Color & 16711680) >>> 16;
  let b = (int32Color & 65280) >>> 8;
  let a2 = (int32Color & 255) / 255;
  return `rgba(${r2}, ${g}, ${b}, ${a2})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator$1(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t2) => t2);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i4 = 1; i4 < inputRange.length - 1; ++i4)
    if (inputRange[i4] >= input)
      break;
  return i4 - 1;
}
function _extends2() {
  _extends2 = Object.assign || function(target2) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends2.apply(this, arguments);
}
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target2) => target2[$observers] || null;
function callFluidObserver(observer, event) {
  if (observer.eventObserved) {
    observer.eventObserved(event);
  } else {
    observer(event);
  }
}
function callFluidObservers(target2, event) {
  let observers = target2[$observers];
  if (observers) {
    observers.forEach((observer) => {
      callFluidObserver(observer, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    this[$get] = void 0;
    this[$observers] = void 0;
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target2, get) => setHidden(target2, $get, get);
function addFluidObserver(target2, observer) {
  if (target2[$get]) {
    let observers = target2[$observers];
    if (!observers) {
      setHidden(target2, $observers, observers = new Set());
    }
    if (!observers.has(observer)) {
      observers.add(observer);
      if (target2.observerAdded) {
        target2.observerAdded(observers.size, observer);
      }
    }
  }
  return observer;
}
function removeFluidObserver(target2, observer) {
  let observers = target2[$observers];
  if (observers && observers.has(observer)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer);
    } else {
      target2[$observers] = null;
    }
    if (target2.observerRemoved) {
      target2.observerRemoved(count, observer);
    }
  }
}
var setHidden = (target2, key, value) => Object.defineProperty(target2, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (_value) {
      return _value;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map((_, i4) => keyframes.map((values) => {
    if (!(i4 in values)) {
      throw Error('The arity of each "output" value must be equal');
    }
    return values[i4];
  }));
  const interpolators = outputRanges.map((output2) => createInterpolator(_extends2({}, config2, {
    output: output2
  })));
  return (input) => {
    var _output$find;
    const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
    let i4 = 0;
    return output[0].replace(numberRegex, () => `${interpolators[i4++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
}
var useOnce = (effect) => (0, import_react.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function useForceUpdate() {
  const update3 = (0, import_react.useState)()[1];
  const mounted = (0, import_react.useState)(makeMountedRef)[0];
  useOnce(mounted.unmount);
  return () => {
    if (mounted.current) {
      update3({});
    }
  };
}
function makeMountedRef() {
  const mounted = {
    current: true,
    unmount: () => () => {
      mounted.current = false;
    }
  };
  return mounted;
}
function useMemoOne(getResult, inputs) {
  const [initial] = (0, import_react.useState)(() => ({
    inputs,
    result: getResult()
  }));
  const committed = (0, import_react.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0, import_react.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i4 = 0; i4 < next.length; i4++) {
    if (next[i4] !== prev[i4]) {
      return false;
    }
  }
  return true;
}
function usePrev(value) {
  const prevRef = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}
var useLayoutEffect3 = typeof window !== "undefined" && window.document && window.document.createElement ? React6.useLayoutEffect : React6.useEffect;

// node_modules/@react-spring/core/dist/react-spring-core.esm.js
var React8 = __toModule(require_react());
var import_react3 = __toModule(require_react());

// node_modules/@react-spring/animated/dist/react-spring-animated.esm.js
var React7 = __toModule(require_react());
var import_react2 = __toModule(require_react());
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    this.payload = void 0;
    setAnimated(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this.done = true;
    this.elapsedTime = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.v0 = void 0;
    this.durationProgress = 0;
    this._value = _value;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const {
      done
    } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = void 0;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    let value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = {
  dependencies: null
};
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  _makePayload(source) {
    if (source) {
      const payload = new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i4) => node.setValue(source[i4])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
function _extends3() {
  _extends3 = Object.assign || function(target2) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends3.apply(this, arguments);
}
var withAnimated = (Component, host2) => {
  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
  return (0, import_react2.forwardRef)((givenProps, givenRef) => {
    const instanceRef2 = (0, import_react2.useRef)(null);
    const ref = hasInstance && (0, import_react2.useCallback)((value) => {
      instanceRef2.current = updateRef(givenRef, value);
    }, [givenRef]);
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef2.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react2.useRef)();
    useLayoutEffect3(() => {
      const lastObserver = observerRef.current;
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      if (lastObserver) {
        each(lastObserver.deps, (dep) => removeFluidObserver(dep, lastObserver));
        raf.cancel(lastObserver.update);
      }
    });
    (0, import_react2.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React7.createElement(Component, _extends3({}, usedProps, {
      ref
    }));
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = _extends3({}, props, {
      style: host2.createAnimatedStyle(props.style)
    });
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: _applyAnimatedValues = () => false,
  createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps: _getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: _applyAnimatedValues,
    createAnimatedStyle: _createAnimatedStyle,
    getComponentProps: _getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@react-spring/core/dist/react-spring-core.esm.js
function _extends4() {
  _extends4 = Object.assign || function(target2) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends4.apply(this, arguments);
}
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = {
      to: to2
    };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return _extends4({}, props);
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  var _ctrl$ref;
  (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    var _ctrl$ref2;
    (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2
};
var defaults = _extends4({}, config.default, {
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
});
var AnimationConfig = class {
  constructor() {
    this.tension = void 0;
    this.friction = void 0;
    this.frequency = void 0;
    this.damping = void 0;
    this.mass = void 0;
    this.velocity = 0;
    this.restVelocity = void 0;
    this.precision = void 0;
    this.progress = void 0;
    this.duration = void 0;
    this.easing = void 0;
    this.clamp = void 0;
    this.bounce = void 0;
    this.decay = void 0;
    this.round = void 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = _extends4({}, defaultConfig);
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = _extends4({}, defaultConfig, newConfig);
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let {
    mass,
    frequency,
    damping
  } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.to = void 0;
    this.from = void 0;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, {
  key,
  props,
  defaultProps,
  state,
  actions
}) {
  return new Promise((resolve, reject) => {
    var _props$cancel;
    let delay;
    let timeout;
    let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start(_extends4({}, props, {
          callId,
          cancel
        }), resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target2, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target2.get()) : results.every((result) => result.noop) ? getNoopResult(target2.get()) : getFinishedResult(target2.get(), results.every((result) => result.finished));
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to2, props, state, target2) {
  const {
    callId,
    parentId,
    onRest
  } = props;
  const {
    asyncTo: prevTo,
    promise: prevPromise
  } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
    let preventBail;
    let bail;
    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
    const bailIfEnded = (bailSignal) => {
      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target2) || callId !== state.asyncId && getFinishedResult(target2, false);
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAniamtionSignal();
      return (async () => {
        if (globals.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target2, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
          to: arg1
        });
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target2.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target2, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target2.stop.bind(target2)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target2.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAniamtionSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target2, target2.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t2) => t2.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
    this.result = void 0;
  }
};
var SkipAniamtionSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
    this.result = void 0;
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId$1 = 1;
var FrameValue = class extends FluidValue {
  constructor(...args) {
    super(...args);
    this.id = nextId$1++;
    this.key = void 0;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  to(...args) {
    return globals.to(this, args);
  }
  interpolate(...args) {
    deprecateInterpolate();
    return globals.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target2) => (target2[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target2) => (target2[$P] & IS_ANIMATING) > 0;
var isPaused = (target2) => (target2[$P] & IS_PAUSED) > 0;
var setActiveBit = (target2, active) => active ? target2[$P] |= IS_ANIMATING | HAS_ANIMATED : target2[$P] &= ~IS_ANIMATING;
var setPausedBit = (target2, paused) => paused ? target2[$P] |= IS_PAUSED : target2[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.key = void 0;
    this.animation = new Animation();
    this.queue = void 0;
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: new Set(),
      resumeQueue: new Set(),
      timeouts: new Set()
    };
    this._pendingCalls = new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
        from: arg1
      });
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  get hasAnimated() {
    return hasAnimated(this);
  }
  get isAnimating() {
    return isAnimating(this);
  }
  get isPaused() {
    return isPaused(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let {
      config: config2,
      toValues
    } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i4) => {
      if (node2.done)
        return;
      const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i4].lastPosition : toValues[i4];
      let finished = anim.immediate;
      let position2 = to2;
      if (!finished) {
        position2 = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i4];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i4] : config2.velocity;
        let velocity;
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position2 = from + config2.easing(p) * (to2 - from);
          velocity = (position2 - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e2 = Math.exp(-(1 - decay) * elapsed);
          position2 = from + v0 / (1 - decay) * (1 - e2);
          finished = Math.abs(node2.lastPosition - position2) < 0.1;
          velocity = v0 * e2;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n2 = 0; n2 < numSteps; ++n2) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position2) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position2 == to2 || position2 > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position2 = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position2 - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position2 = position2 + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position2)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i4].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position2, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  pause() {
    this._update({
      pause: true
    });
  }
  resume() {
    this._update({
      pause: false
    });
  }
  finish() {
    if (isAnimating(this)) {
      const {
        to: to2,
        config: config2
      } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : _extends4({}, arg2, {
        to: to2
      })];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(queue.map((props) => {
      const up = this._update(props);
      return up;
    })).then((results) => getCombinedResult(this, results));
  }
  stop(cancel) {
    const {
      to: to2
    } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  reset() {
    this._update({
      reset: true
    });
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  _prepareNode(props) {
    const key = this.key || "";
    let {
      to: to2,
      from
    } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = {
      to: to2,
      from
    };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range;
  }
  _update(_ref, isLoop) {
    let props = _extends4({}, _ref);
    const {
      key,
      defaultProps
    } = this;
    if (props.default)
      Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const {
      key,
      defaultProps,
      animation: anim
    } = this;
    const {
      to: prevTo,
      from: prevFrom
    } = anim;
    let {
      to: to2 = prevTo,
      from = prevFrom
    } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const {
      config: config2
    } = anim;
    const {
      decay,
      velocity
    } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
    const value = reset ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const {
          onRest
        } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              anim.onStart == null ? void 0 : anim.onStart(result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const {
      to: to2
    } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority2 = to2.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const {
      to: to2
    } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target2, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target2.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
  let loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate(_extends4({}, props, {
      loop: loop2,
      default: false,
      pause: void 0,
      to: !reverse || isAsyncTo(to2) ? to2 : void 0,
      from: reset ? props.from : void 0,
      reset
    }, overrides));
  }
}
function createUpdate(props) {
  const {
    to: to2,
    from
  } = props = inferTo(props);
  const keys = new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update3 = createUpdate(props);
  if (is.und(update3.default)) {
    update3.default = getDefaultProps(update3);
  }
  return update3;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function mergeActiveFn(target2, props, type) {
  target2.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target2.key) : void 0;
}
function sendEvent(target2, type, ...args) {
  var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
  (_target$animation$typ = (_target$animation = target2.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
  (_target$defaultProps$ = (_target$defaultProps = target2.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId = 1;
var Controller = class {
  constructor(props, flush2) {
    this.id = nextId++;
    this.springs = {};
    this.queue = [];
    this.ref = void 0;
    this._flush = void 0;
    this._initialProps = void 0;
    this._lastAsyncId = 0;
    this._active = new Set();
    this._changed = new Set();
    this._started = false;
    this._item = void 0;
    this._state = {
      paused: false,
      pauseQueue: new Set(),
      resumeQueue: new Set(),
      timeouts: new Set()
    };
    this._events = {
      onStart: new Map(),
      onChange: new Map(),
      onRest: new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush2) {
      this._flush = flush2;
    }
    if (props) {
      this.start(_extends4({
        default: true
      }, props));
    }
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  start(props) {
    let {
      queue
    } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  pause(keys) {
    if (is.und(keys)) {
      this.start({
        pause: true
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  resume(keys) {
    if (is.und(keys)) {
      this.start({
        pause: false
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  _onFrame() {
    const {
      onStart,
      onChange,
      onRest
    } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
}
async function flushUpdate(ctrl, props, isLoop) {
  const {
    keys,
    to: to2,
    from,
    loop: loop2,
    onRest,
    onResolve
  } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({
          finished,
          cancelled
        }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
      props,
      state,
      actions: {
        pause: noop,
        resume: noop,
        start(props2, resolve) {
          if (cancel) {
            stopAsync(state, ctrl["_lastAsyncId"]);
            resolve(getCancelledResult(ctrl));
          } else {
            props2.onRest = onRest;
            resolve(runAsync(asyncTo, props2, state, ctrl));
          }
        }
      }
    }));
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = _extends4({}, ctrl.springs);
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = _extends4({}, props2, {
          to: void 0
        });
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create3) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create3(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
var _excluded$3 = ["children"];
var SpringContext = (_ref) => {
  let {
    children
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$3);
  const inherited = (0, import_react3.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({
    pause,
    immediate
  }), [pause, immediate]);
  const {
    Provider
  } = ctx;
  return React8.createElement(Provider, {
    value: props
  }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target2, init) {
  Object.assign(target2, React8.createContext(init));
  target2.Provider._context = target2;
  target2.Consumer._context = target2;
  return target2;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function SpringRef3(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i4) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = _getProps(props, ctrl, i4);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i4 = current.indexOf(ctrl);
    if (~i4)
      current.splice(i4, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl) => ctrl.set(values));
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i4) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = this._getProps(props, ctrl, i4);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i4) => ctrl.update(this._getProps(props, ctrl, i4)));
    return this;
  };
  const _getProps = function _getProps2(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0, import_react3.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
  const layoutId = (0, import_react3.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react3.useMemo)(() => ({
    ctrls: [],
    queue: [],
    flush(ctrl, updates2) {
      const springs2 = getSprings(ctrl, updates2);
      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
        setSprings(ctrl, springs2);
        state.queue.push(() => {
          resolve(flushUpdateQueue(ctrl, updates2));
        });
        forceUpdate();
      });
    }
  }), []);
  const ctrls = (0, import_react3.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0, import_react3.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react3.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i4 = startIndex; i4 < endIndex; i4++) {
      const ctrl = ctrls.current[i4] || (ctrls.current[i4] = new Controller(null, state.flush));
      const update3 = propsFn ? propsFn(i4, ctrl) : props[i4];
      if (update3) {
        updates[i4] = declareUpdate(update3);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i4) => getSprings(ctrl, updates[i4]));
  const context7 = (0, import_react3.useContext)(SpringContext);
  const prevContext = usePrev(context7);
  const hasContext = context7 !== prevContext && hasProps(context7);
  useLayoutEffect3(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const {
      queue
    } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i4) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({
          default: context7
        });
      }
      const update3 = updates[i4];
      if (update3) {
        replaceRef(ctrl, update3.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update3);
        } else {
          ctrl.start(update3);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x) => _extends4({}, x));
  return ref ? [values, ref] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
  return isFn || arguments.length == 2 ? [values, ref] : values;
}
var TransitionPhase;
(function(TransitionPhase2) {
  TransitionPhase2["MOUNT"] = "mount";
  TransitionPhase2["ENTER"] = "enter";
  TransitionPhase2["UPDATE"] = "update";
  TransitionPhase2["LEAVE"] = "leave";
})(TransitionPhase || (TransitionPhase = {}));
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.key = void 0;
    this.idle = true;
    this.calc = void 0;
    this._active = new Set();
    this.source = source;
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node) => {
      node.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
globals.assign({
  createStringInterpolator,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@react-spring/three/dist/react-spring-three.esm.js
var primitives = ["primitive"].concat(Object.keys(three_module_exports).filter((key) => /^[A-Z]/.test(key)).map((key) => key[0].toLowerCase() + key.slice(1)));
globals.assign({
  createStringInterpolator,
  colors,
  frameLoop: "demand"
});
addEffect(() => {
  raf.advance();
});
var host = createHost(primitives, {
  applyAnimatedValues: applyProps
});
var animated = host.animated;

// node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js
function clamp(v4, min, max) {
  return Math.max(min, Math.min(v4, max));
}
var V = {
  toVector(v4, fallback) {
    if (v4 === void 0)
      v4 = fallback;
    return Array.isArray(v4) ? v4 : [v4, v4];
  },
  add(v12, v22) {
    return [v12[0] + v22[0], v12[1] + v22[1]];
  },
  sub(v12, v22) {
    return [v12[0] - v22[0], v12[1] - v22[1]];
  },
  addTo(v12, v22) {
    v12[0] += v22[0];
    v12[1] += v22[1];
  },
  subTo(v12, v22) {
    v12[0] -= v22[0];
    v12[1] -= v22[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position2, min, max, constant = 0.15) {
  if (constant === 0)
    return clamp(position2, min, max);
  if (position2 < min)
    return -rubberband(min - position2, max - min, constant) + min;
  if (position2 > max)
    return +rubberband(position2 - max, max - min, constant) + max;
  return position2;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/@use-gesture/core/dist/actions-fd032a26.esm.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target2) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4] != null ? arguments[i4] : {};
    if (i4 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target2, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target2, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target2;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string)
    return "";
  return string[0].toUpperCase() + string.slice(1);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (capture ? "Capture" : "");
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e2) => {
    var _event$currentTarget, _event$currentTarget$;
    return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  const dx = P2.clientX - P1.clientX;
  const dy = P2.clientY - P1.clientY;
  const cx = (P2.clientX + P1.clientX) / 2;
  const cy = (P2.clientY + P1.clientY) / 2;
  const distance = Math.hypot(dx, dy);
  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
  const origin = [cx, cy];
  return {
    angle,
    distance,
    origin
  };
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call2(v4, ...args) {
  if (typeof v4 === "function") {
    return v4(...args);
  } else {
    return v4;
  }
}
function noop2() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop2;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config2.from ? call2(config2.from, state) : state.offset;
      state.offset = state.lastOffset;
    }
    state.startTime = state.timeStamp = event.timeStamp;
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config: config2,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config2.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config2.threshold;
    const {
      _step,
      values
    } = state;
    if (config2.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config2.hasCustomTransform) {
      const [v0, v12] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v12 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.intent)
      this.intent(movement);
    if (state._active && !state._blocked || state.active) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config2)
            state._bounds = call2(config2.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        const previousOffset = state.offset;
        this.computeOffset();
        if (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY) {
          state.delta = V.sub(state.offset, previousOffset);
          const absoluteDelta = state.delta.map(Math.abs);
          V.addTo(state.distance, absoluteDelta);
          state.direction = state.delta.map(Math.sign);
          if (!state.first && dt > 0) {
            state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
          }
        }
      }
    }
    const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    this.computeMovement();
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config2 = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents)
      return;
    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo !== void 0)
      state.memo = memo;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy]) {
  const d2 = Math.abs(dx) - Math.abs(dy);
  if (d2 > 0)
    return "x";
  if (d2 < 0)
    return "y";
  return void 0;
}
function restrictVectorToAxis(v4, axis) {
  switch (axis) {
    case "x":
      v4[1] = 0;
      break;
    case "y":
      v4[0] = 0;
      break;
  }
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  intent(v4) {
    this.state.axis = this.state.axis || selectAxis(v4);
    this.state._blocked = (this.config.lockDirection || !!this.config.axis) && !this.state.axis || !!this.config.axis && this.config.axis !== this.state.axis;
    if (this.state._blocked)
      return;
    if (this.config.axis || this.config.lockDirection) {
      restrictVectorToAxis(v4, this.state.axis);
    }
  }
};
var identity = (v4) => v4;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config2) {
    const transform = value || config2.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v4) => {
        const r2 = originalTransform(v4);
        if (!isFinite(r2[0]) || !isFinite(r2[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r2[0]},${[1]}]`);
        }
        return r2;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var DISPLACEMENT = 10;
var KEYS_DELTA_MAP = {
  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config2 = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons))
      return;
    this.ctrl.setEventIds(event);
    if (config2.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (state._pointerActive)
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config2.preventScroll) {
      this.setupScrollPrevention(event);
    } else if (config2.delay > 0) {
      this.setupDelayTrigger(event);
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state._pointerActive)
      return;
    if (state.type === event.type && event.timeStamp === state.timeStamp)
      return;
    const id = pointerId(event);
    if (state._pointerId && id !== state._pointerId)
      return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config2.preventScroll && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config2 = this.config;
    if (!state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId && id !== state._pointerId)
      return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= 3 && dy <= 3;
    if (state.tap && config2.filterTaps) {
      state._force = true;
    } else {
      const [dirx, diry] = state.direction;
      const [vx, vy] = state.velocity;
      const [mx, my] = state.movement;
      const [svx, svy] = config2.swipe.velocity;
      const [sx, sy] = config2.swipe.distance;
      const sdt = config2.swipe.duration;
      if (state.elapsedTime < sdt) {
        if (Math.abs(vx) > svx && Math.abs(mx) > sx)
          state.swipe[0] = dirx;
        if (Math.abs(vy) > svy && Math.abs(my) > sy)
          state.swipe[1] = diry;
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config2 = this.config;
    let device = config2.device;
    if (true) {
      try {
        if (device === "pointer") {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config2.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config2.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    persistEvent(event);
    this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", this.clean.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", this.clean.bind(this), {
      passive: false
    });
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScroll, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", this.startPointerDrag.bind(this), this.config.delay, event);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      state._delta = deltaFn(factor);
      this.start(event);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP))
      return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
    }
    bindFunction("key", "down", this.keyDown.bind(this));
    bindFunction("key", "up", this.keyUp.bind(this));
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e2) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  pointerLock(_v, _k, {
    pointer: {
      lock = false,
      touch = false
    } = {}
  }) {
    this.useTouch = SUPPORT.touch && touch;
    return SUPPORT.pointerLock && lock;
  },
  device(_v, _k) {
    if (this.useTouch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScroll(value = false, _k, {
    preventScrollAxis = "y"
  }) {
    if (preventScrollAxis)
      this.preventScrollAxis = preventScrollAxis;
    if (!SUPPORT.touchscreen)
      return false;
    if (typeof value === "number")
      return value;
    return value ? DEFAULT_PREVENT_SCROLL_DELAY : false;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1
    } = {}
  }) {
    this.pointerButtons = buttons;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? 3 : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 36;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  intent(v4) {
    const state = this.state;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(v4[0]) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(v4[1]);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
    if (this.config.lockDirection) {
      if (state.axis === "scale")
        v4[1] = 0;
      else if (state.axis === "angle")
        v4[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    if (!event.ctrlKey)
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
    } else {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  useTouch(_v, _k, {
    pointer: {
      touch = false
    } = {}
  }) {
    return SUPPORT.touch && touch;
  },
  device(_v, _k, config2) {
    const sharedConfig = config2.shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (this.useTouch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call2(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call2(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config2) {
    this.lockDirection = config2.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    if (!this.state._active)
      this.moveStart(event);
    else
      this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active)
      return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active)
      this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(this.state._movement, state._delta);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    const state = this.state;
    if (!state._active)
      return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = new Map();
var ConfigResolverMap = new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react4 = __toModule(require_react());

// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key = sourceKeys[i4];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target2 = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i4;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i4 = 0; i4 < sourceSymbolKeys.length; i4++) {
      key = sourceSymbolKeys[i4];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target2[key] = source[key];
    }
  }
  return target2;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config2 = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r2 = resolver.call(result, config2[key], key, config2);
          if (!Number.isNaN(r2))
            result[key] = r2;
        } else {
          result[key] = resolver.call(result, config2[key], key, config2);
        }
        break;
      case "object":
        result[key] = resolveWith(config2[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config2[key];
        break;
    }
  }
  return result;
}
function parse(config2, gestureKey) {
  const _ref = config2, {
    target: target2,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  const _config = {
    shared: resolveWith({
      target: target2,
      eventOptions,
      window: window2,
      enabled,
      transform
    }, sharedConfigResolver)
  };
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl) {
    _defineProperty(this, "_listeners", []);
    this._ctrl = ctrl;
  }
  add(element, device, action, handler, options) {
    const type = toDomEventType(device, action);
    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);
    element.addEventListener(type, handler, eventOptions);
    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners = [];
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller2 = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", new Set());
    _defineProperty(this, "touchIds", new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown")
        this.pointerIds.add(event.pointerId);
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config2, gestureKey) {
    this.config = parse(config2, gestureKey);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const eventOptions = sharedConfig.eventOptions;
    const props = {};
    let target2;
    if (sharedConfig.target) {
      target2 = sharedConfig.target();
      if (!target2)
        return;
    }
    const bindFunction = bindToProps(props, eventOptions, !!target2);
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        if (this.config[gestureKey].enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      for (const eventKey in this.nativeHandlers) {
        bindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target2)
      return props;
    for (const handlerProp in props) {
      let eventKey = handlerProp.substr(2).toLowerCase();
      const capture = !!~eventKey.indexOf("capture");
      const passive = !!~eventKey.indexOf("passive");
      if (capture || passive)
        eventKey = eventKey.replace(/capture|passive/g, "");
      this._targetEventStore.add(target2, eventKey, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config2) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn;
  config2[key] = config2[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react4.default.useMemo(() => new Controller2(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config2, gestureKey);
  import_react4.default.useEffect(ctrl.effect.bind(ctrl));
  import_react4.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config2.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config = {}) {
    const {
      handlers,
      nativeHandlers,
      config: config2
    } = parseMergedHandlers(_handlers, _config);
    return useRecognizers(handlers, config2, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config2 = {}) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config2);
}

// node_modules/@react-three/drei/web/PresentationControls.js
function PresentationControls({
  snap,
  global: global2,
  cursor = true,
  children,
  speed = 1,
  rotation: rotation2 = [0, 0, 0],
  zoom = 1,
  polar = [0, Math.PI / 2],
  azimuth = [-Infinity, Infinity],
  config: config2 = {
    mass: 1,
    tension: 170,
    friction: 26
  }
}) {
  const {
    size,
    gl
  } = useThree();
  const rPolar = React10.useMemo(() => [rotation2[0] + polar[0], rotation2[0] + polar[1]], [rotation2[0], polar[0], polar[1]]);
  const rAzimuth = React10.useMemo(() => [rotation2[1] + azimuth[0], rotation2[1] + azimuth[1]], [rotation2[1], azimuth[0], azimuth[1]]);
  const rInitial = React10.useMemo(() => [MathUtils.clamp(rotation2[0], ...rPolar), MathUtils.clamp(rotation2[1], ...rAzimuth), rotation2[2]], [rotation2[0], rotation2[1], rotation2[2], rPolar, rAzimuth]);
  const [spring, api] = useSpring(() => ({
    scale: 1,
    rotation: rInitial,
    config: config2
  }));
  React10.useEffect(() => void api.start({
    scale: 1,
    rotation: rInitial,
    config: config2
  }), [rInitial]);
  React10.useEffect(() => {
    if (global2 && cursor)
      gl.domElement.style.cursor = "grab";
  }, [global2, cursor, gl.domElement]);
  const bind = useGesture({
    onHover: ({
      last
    }) => {
      if (cursor && !global2)
        gl.domElement.style.cursor = last ? "auto" : "grab";
    },
    onDrag: ({
      down,
      delta: [x, y],
      memo: [oldY, oldX] = spring.rotation.animation.to || rInitial
    }) => {
      if (cursor)
        gl.domElement.style.cursor = down ? "grabbing" : "grab";
      x = MathUtils.clamp(oldX + x / size.width * Math.PI * speed, ...rAzimuth);
      y = MathUtils.clamp(oldY + y / size.height * Math.PI * speed, ...rPolar);
      const sConfig = snap && !down && typeof snap !== "boolean" ? snap : config2;
      api.start({
        scale: down && y > rPolar[1] / 2 ? zoom : 1,
        rotation: snap && !down ? rInitial : [y, x, 0],
        config: (n2) => n2 === "scale" ? __spreadProps(__spreadValues({}, sConfig), {
          friction: sConfig.friction * 3
        }) : sConfig
      });
      return [y, x];
    }
  }, {
    target: global2 ? gl.domElement : void 0
  });
  return React10.createElement(animated.group, _extends({}, bind == null ? void 0 : bind(), spring), children);
}

// node_modules/@react-three/drei/web/Select.js
var React11 = __toModule(require_react());

// node_modules/zustand/esm/shallow.js
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i4 = 0; i4 < keysA.length; i4++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i4]) || !Object.is(objA[keysA[i4]], objB[keysA[i4]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@react-three/drei/web/Select.js
var context3 = React11.createContext([]);
function Select(_a) {
  var _b = _a, {
    box,
    multiple,
    children,
    onChange,
    border = "1px solid #55aaff",
    backgroundColor = "rgba(75, 160, 255, 0.1)",
    filter: customFilter = (item) => item
  } = _b, props = __objRest(_b, [
    "box",
    "multiple",
    "children",
    "onChange",
    "border",
    "backgroundColor",
    "filter"
  ]);
  const {
    camera,
    raycaster,
    gl,
    controls,
    size,
    get
  } = useThree();
  const [hovered, hover] = React11.useState(false);
  const [active, dispatch] = React11.useReducer((state, {
    object,
    shift
  }) => {
    if (object === void 0)
      return [];
    else if (Array.isArray(object))
      return object;
    else if (!shift)
      return state[0] === object ? [] : [object];
    else if (state.includes(object))
      return state.filter((o2) => o2 !== object);
    else
      return [object, ...state];
  }, []);
  React11.useEffect(() => void (onChange == null ? void 0 : onChange(active)), [active]);
  const onClick = React11.useCallback((e2) => {
    e2.stopPropagation();
    dispatch({
      object: customFilter([e2.object])[0],
      shift: multiple && e2.shiftKey
    });
  }, []);
  const onPointerMissed = React11.useCallback((e2) => !hovered && dispatch({}), [hovered]);
  const ref = React11.useRef(null);
  React11.useEffect(() => {
    if (!box || !multiple)
      return;
    const selBox = new SelectionBox(camera, ref.current);
    const element = document.createElement("div");
    element.style.pointerEvents = "none";
    element.style.border = border;
    element.style.backgroundColor = backgroundColor;
    element.style.position = "fixed";
    const startPoint = new Vector2();
    const pointTopLeft = new Vector2();
    const pointBottomRight = new Vector2();
    const oldRaycasterEnabled = raycaster.enabled;
    const oldControlsEnabled = controls == null ? void 0 : controls.enabled;
    let isDown = false;
    function prepareRay(event, vec2) {
      var _raycaster$computeOff;
      const {
        offsetX,
        offsetY
      } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, get())) !== null && _raycaster$computeOff !== void 0 ? _raycaster$computeOff : event;
      const {
        width,
        height
      } = size;
      vec2.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);
    }
    function onSelectStart(event) {
      var _gl$domElement$parent;
      if (controls)
        controls.enabled = false;
      raycaster.enabled = false;
      isDown = true;
      (_gl$domElement$parent = gl.domElement.parentElement) == null ? void 0 : _gl$domElement$parent.appendChild(element);
      element.style.left = `${event.clientX}px`;
      element.style.top = `${event.clientY}px`;
      element.style.width = "0px";
      element.style.height = "0px";
      startPoint.x = event.clientX;
      startPoint.y = event.clientY;
    }
    function onSelectMove(event) {
      pointBottomRight.x = Math.max(startPoint.x, event.clientX);
      pointBottomRight.y = Math.max(startPoint.y, event.clientY);
      pointTopLeft.x = Math.min(startPoint.x, event.clientX);
      pointTopLeft.y = Math.min(startPoint.y, event.clientY);
      element.style.left = `${pointTopLeft.x}px`;
      element.style.top = `${pointTopLeft.y}px`;
      element.style.width = `${pointBottomRight.x - pointTopLeft.x}px`;
      element.style.height = `${pointBottomRight.y - pointTopLeft.y}px`;
    }
    function onSelectOver() {
      if (isDown) {
        var _element$parentElemen;
        if (controls)
          controls.enabled = oldControlsEnabled;
        raycaster.enabled = oldRaycasterEnabled;
        isDown = false;
        (_element$parentElemen = element.parentElement) == null ? void 0 : _element$parentElemen.removeChild(element);
      }
    }
    function pointerDown(event) {
      if (event.shiftKey) {
        onSelectStart(event);
        prepareRay(event, selBox.startPoint);
      }
    }
    let previous = [];
    function pointerMove(event) {
      if (isDown) {
        onSelectMove(event);
        prepareRay(event, selBox.endPoint);
        const allSelected = selBox.select().sort((o2) => o2.uuid).filter((o2) => o2.isMesh);
        if (!shallow(allSelected, previous)) {
          previous = allSelected;
          dispatch({
            object: customFilter(allSelected)
          });
        }
      }
    }
    function pointerUp(event) {
      if (isDown)
        onSelectOver();
    }
    document.addEventListener("pointerdown", pointerDown, {
      passive: true
    });
    document.addEventListener("pointermove", pointerMove, {
      passive: true,
      capture: true
    });
    document.addEventListener("pointerup", pointerUp, {
      passive: true
    });
    return () => {
      document.removeEventListener("pointerdown", pointerDown);
      document.removeEventListener("pointermove", pointerMove);
      document.removeEventListener("pointerup", pointerUp);
    };
  }, [size, raycaster, camera, controls, gl]);
  return React11.createElement("group", _extends({
    ref,
    onClick,
    onPointerOver: () => hover(true),
    onPointerOut: () => hover(false),
    onPointerMissed
  }, props), React11.createElement(context3.Provider, {
    value: active
  }, children));
}
function useSelect() {
  return React11.useContext(context3);
}

// node_modules/@react-three/drei/core/Billboard.js
var React12 = __toModule(require_react());
var Billboard = React12.forwardRef(function Billboard2(_a, ref) {
  var _b = _a, {
    follow = true,
    lockX = false,
    lockY = false,
    lockZ = false
  } = _b, props = __objRest(_b, [
    "follow",
    "lockX",
    "lockY",
    "lockZ"
  ]);
  const localRef = React12.useRef();
  useFrame(({
    camera
  }) => {
    if (!follow || !localRef.current)
      return;
    const prevRotation = localRef.current.rotation.clone();
    localRef.current.quaternion.copy(camera.quaternion);
    if (lockX)
      localRef.current.rotation.x = prevRotation.x;
    if (lockY)
      localRef.current.rotation.y = prevRotation.y;
    if (lockZ)
      localRef.current.rotation.z = prevRotation.z;
  });
  return React12.createElement("group", _extends({
    ref: react_merge_refs_esm_default([localRef, ref])
  }, props));
});

// node_modules/@react-three/drei/core/QuadraticBezierLine.js
var React14 = __toModule(require_react());

// node_modules/@react-three/drei/core/Line.js
var React13 = __toModule(require_react());
var Line = React13.forwardRef(function Line4(_a, ref) {
  var _b = _a, {
    points,
    color: color3 = "black",
    vertexColors,
    lineWidth,
    dashed
  } = _b, rest = __objRest(_b, [
    "points",
    "color",
    "vertexColors",
    "lineWidth",
    "dashed"
  ]);
  const [line2] = React13.useState(() => new Line2());
  const [lineMaterial] = React13.useState(() => new LineMaterial());
  const [resolution] = React13.useState(() => new Vector2(512, 512));
  const lineGeom = React13.useMemo(() => {
    const geom = new LineGeometry();
    const pValues = points.map((p) => p instanceof Vector3 ? p.toArray() : p);
    geom.setPositions(pValues.flat());
    if (vertexColors) {
      const cValues = vertexColors.map((c6) => c6 instanceof Color ? c6.toArray() : c6);
      geom.setColors(cValues.flat());
    }
    return geom;
  }, [points, vertexColors]);
  React13.useLayoutEffect(() => {
    line2.computeLineDistances();
  }, [points, line2]);
  React13.useLayoutEffect(() => {
    if (dashed) {
      lineMaterial.defines.USE_DASH = "";
    } else {
      delete lineMaterial.defines.USE_DASH;
    }
    lineMaterial.needsUpdate = true;
  }, [dashed, lineMaterial]);
  React13.useEffect(() => {
    return () => lineGeom.dispose();
  }, [lineGeom]);
  return React13.createElement("primitive", _extends({
    object: line2,
    ref
  }, rest), React13.createElement("primitive", {
    object: lineGeom,
    attach: "geometry"
  }), React13.createElement("primitive", _extends({
    object: lineMaterial,
    attach: "material",
    color: color3,
    vertexColors: Boolean(vertexColors),
    resolution,
    linewidth: lineWidth,
    dashed
  }, rest)));
});

// node_modules/@react-three/drei/core/QuadraticBezierLine.js
var v = new Vector3();
var QuadraticBezierLine = React14.forwardRef(function QuadraticBezierLine2(_a, forwardref) {
  var _b = _a, {
    start: start2 = [0, 0, 0],
    end = [0, 0, 0],
    mid,
    segments = 20
  } = _b, rest = __objRest(_b, [
    "start",
    "end",
    "mid",
    "segments"
  ]);
  const ref = React14.useRef(null);
  const [curve] = React14.useState(() => new QuadraticBezierCurve3(void 0, void 0, void 0));
  const getPoints = React14.useCallback((start3, end2, mid2, segments2 = 20) => {
    if (start3 instanceof Vector3)
      curve.v0.copy(start3);
    else
      curve.v0.set(...start3);
    if (end2 instanceof Vector3)
      curve.v2.copy(end2);
    else
      curve.v2.set(...end2);
    if (mid2 instanceof Vector3) {
      curve.v1.copy(mid2);
    } else {
      curve.v1.copy(curve.v0.clone().add(curve.v2.clone().sub(curve.v0)).add(v.set(0, curve.v0.y - curve.v2.y, 0)));
    }
    return curve.getPoints(segments2);
  }, []);
  React14.useLayoutEffect(() => {
    ref.current.setPoints = (start3, end2, mid2) => {
      const points2 = getPoints(start3, end2, mid2);
      if (ref.current.geometry)
        ref.current.geometry.setPositions(points2.map((p) => p.toArray()).flat());
    };
  }, []);
  const points = React14.useMemo(() => getPoints(start2, end, mid, segments), [start2, end, mid, segments]);
  return React14.createElement(Line, _extends({
    ref: react_merge_refs_esm_default([ref, forwardref]),
    points
  }, rest));
});

// node_modules/@react-three/drei/core/CubicBezierLine.js
var React15 = __toModule(require_react());
var CubicBezierLine = React15.forwardRef(function CubicBezierLine2(_a, ref) {
  var _b = _a, {
    start: start2,
    end,
    midA,
    midB,
    segments = 20
  } = _b, rest = __objRest(_b, [
    "start",
    "end",
    "midA",
    "midB",
    "segments"
  ]);
  const points = React15.useMemo(() => {
    const startV = start2 instanceof Vector3 ? start2 : new Vector3(...start2);
    const endV = end instanceof Vector3 ? end : new Vector3(...end);
    const midAV = midA instanceof Vector3 ? midA : new Vector3(...midA);
    const midBV = midB instanceof Vector3 ? midB : new Vector3(...midB);
    const interpolatedV = new CubicBezierCurve3(startV, midAV, midBV, endV).getPoints(segments);
    return interpolatedV;
  }, [start2, end, midA, midB, segments]);
  return React15.createElement(Line, _extends({
    ref,
    points
  }, rest));
});

// node_modules/@react-three/drei/core/PositionalAudio.js
var React16 = __toModule(require_react());
var PositionalAudio = React16.forwardRef((_a, ref) => {
  var _b = _a, {
    url,
    distance = 1,
    loop: loop2 = true,
    autoplay
  } = _b, props = __objRest(_b, [
    "url",
    "distance",
    "loop",
    "autoplay"
  ]);
  const sound = React16.useRef();
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const [listener] = React16.useState(() => new AudioListener());
  const buffer = useLoader(AudioLoader, url);
  React16.useEffect(() => {
    const _sound = sound.current;
    if (_sound) {
      _sound.setBuffer(buffer);
      _sound.setRefDistance(distance);
      _sound.setLoop(loop2);
      if (autoplay && !_sound.isPlaying)
        _sound.play();
    }
  }, [buffer, camera, distance, loop2]);
  React16.useEffect(() => {
    const _sound = sound.current;
    camera.add(listener);
    return () => {
      camera.remove(listener);
      if (_sound) {
        if (_sound.isPlaying)
          _sound.stop();
        if (_sound.source && _sound.source._connected)
          _sound.disconnect();
      }
    };
  }, []);
  return React16.createElement("positionalAudio", _extends({
    ref: react_merge_refs_esm_default([sound, ref]),
    args: [listener]
  }, props));
});

// node_modules/@react-three/drei/core/Text.js
var React17 = __toModule(require_react());

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function BespokeThenable() {
  var state = 0;
  var queue = [];
  var value;
  var scheduled = 0;
  var completeCalled = 0;
  function then(onResolve, onReject) {
    var nextThenable = BespokeThenable();
    function handleNext() {
      var cb = state > 0 ? onResolve : onReject;
      if (isFn(cb)) {
        try {
          var result = cb(value);
          if (result === nextThenable) {
            recursiveError();
          }
          var resultThen = getThenableThen(result);
          if (resultThen) {
            resultThen.call(result, nextThenable.resolve, nextThenable.reject);
          } else {
            nextThenable.resolve(result);
          }
        } catch (err) {
          nextThenable.reject(err);
        }
      } else {
        nextThenable[state > 0 ? "resolve" : "reject"](value);
      }
    }
    queue.push(handleNext);
    if (state) {
      scheduleQueueFlush();
    }
    return nextThenable;
  }
  var resolve = oneTime(function(val) {
    if (!completeCalled) {
      complete(1, val);
    }
  });
  var reject = oneTime(function(reason) {
    if (!completeCalled) {
      complete(-1, reason);
    }
  });
  function complete(st, val) {
    completeCalled++;
    var ignoreThrow = 0;
    try {
      if (val === thenableObj) {
        recursiveError();
      }
      var valThen = st > 0 && getThenableThen(val);
      if (valThen) {
        valThen.call(val, oneTime(function(v4) {
          ignoreThrow++;
          complete(1, v4);
        }), oneTime(function(v4) {
          ignoreThrow++;
          complete(-1, v4);
        }));
      } else {
        state = st;
        value = val;
        scheduleQueueFlush();
      }
    } catch (e2) {
      if (!state && !ignoreThrow) {
        complete(-1, e2);
      }
    }
  }
  function scheduleQueueFlush() {
    if (!scheduled) {
      setTimeout(flushQueue, 0);
      scheduled = 1;
    }
  }
  function flushQueue() {
    var q = queue;
    scheduled = 0;
    queue = [];
    q.forEach(callIt);
  }
  function callIt(fn) {
    fn();
  }
  function getThenableThen(val) {
    var valThen = val && (isFn(val) || typeof val === "object") && val.then;
    return isFn(valThen) && valThen;
  }
  function oneTime(fn) {
    var called = 0;
    return function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!called++) {
        fn.apply(this, args);
      }
    };
  }
  function recursiveError() {
    throw new TypeError("Chaining cycle detected");
  }
  var isFn = function(v4) {
    return typeof v4 === "function";
  };
  var thenableObj = {
    then,
    resolve,
    reject
  };
  return thenableObj;
}
function NativePromiseThenable() {
  var resolve, reject;
  var promise = new Promise(function(res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    then: promise.then.bind(promise),
    resolve,
    reject
  };
}
BespokeThenable.all = NativePromiseThenable.all = function(items) {
  var resultCount = 0;
  var results = [];
  var out = DefaultThenable();
  if (items.length === 0) {
    out.resolve([]);
  } else {
    items.forEach(function(item, i4) {
      var itemThenable = DefaultThenable();
      itemThenable.resolve(item);
      itemThenable.then(function(res) {
        resultCount++;
        results[i4] = res;
        if (resultCount === items.length) {
          out.resolve(results);
        }
      }, out.reject);
    });
  }
  return out;
};
var DefaultThenable = typeof Promise === "function" ? NativePromiseThenable : BespokeThenable;
function workerBootstrap() {
  var modules = Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0)
      dependencies = [];
    var init = ref.init;
    if (init === void 0)
      init = function() {
      };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0)
      getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init = rehydrate("<" + name + ">.init", init);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init === "function") {
        value = init.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r2) {
      return result = r2;
    };
    var url = URL.createObjectURL(new Blob(["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"], { type: "application/javascript" }));
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e2) {
    var ref = e2.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      if (action === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(function(dep) {
      return dep && dep._getInitResult ? dep._getInitResult() : dep;
    }) : [];
    var initThenable = DefaultThenable.all(dependencies).then(function(deps) {
      return init.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initThenable;
    };
    return initThenable;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(URL.createObjectURL(new Blob([""], { type: "application/javascript" })));
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== "undefined" && false)
        ;
      else {
        console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]");
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = Object.create(null);
var registeredModules = Object.create(null);
var openRequests = Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers()) {
    return defineMainThreadModule(options);
  }
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationThenable = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (!registrationThenable) {
      registrationThenable = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationThenable = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);
    }
    return registrationThenable.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"], { type: "application/javascript" })));
    worker.onmessage = function(e2) {
      var response = e2.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action, data) {
  var thenable = DefaultThenable();
  var messageId = ++_messageId;
  openRequests[messageId] = function(response) {
    if (response.success) {
      thenable.resolve(response.result);
    } else {
      thenable.reject(new Error("Error in worker " + action + " call: " + response.error));
    }
  };
  getWorker(workerId).postMessage({
    messageId,
    action,
    data
  });
  return thenable;
}
var ThenableWorkerModule = defineWorkerModule({
  name: "Thenable",
  dependencies: [DefaultThenable],
  init: function(Thenable) {
    return Thenable;
  }
});

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i4) {
      TYPES[type] = 1 << i4 + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = new Map();
        var loop2 = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range) {
              var ref = range.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i4 = 0; i4 < step; i4++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA)
          loop2(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = new Map();
      var reverseMap = includeReverse && new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i4 = +entry; i4--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a2 = ref[0];
          var b = ref[1];
          a2 = String.fromCodePoint(lastCode += parseInt(a2, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map2.set(a2, b);
          includeReverse && reverseMap.set(b, a2);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i4 = 0; i4 < string.length; i4++) {
        charTypes[i4] = getBidiCharType(string[i4]);
      }
      var charTypeCounts = new Map();
      function changeCharType(i5, type2) {
        var oldType = charTypes[i5];
        charTypes[i5] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n2) {
        return n2 + (n2 & 1 ? 1 : 2);
      };
      var nextOdd = function(n2) {
        return n2 + (n2 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          _isolate: 0
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {
                  changeCharType(seqIndices$1[sj$5], TYPE_EN);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {
                  changeCharType(seqIndices$1[sj$7], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a2, b) {
                return a2[0] - b[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === getEmbedDirection(i$15)) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== getEmbedDirection(i$16)) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = getEmbedDirection(i$16);
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {
                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start2, isFSI) {
        for (var i5 = start2; i5 < string.length; i5++) {
          var charType2 = charTypes[i5];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i5);
            i5 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i5 = isolateStart + 1; i5 < string.length; i5++) {
          var charType2 = charTypes[i5];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i5;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
      function getEmbedDirection(i5) {
        return embedLevels[i5] & 1 ? TYPE_R : TYPE_L;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse2() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key) {
          map2.set(key, value);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse2();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start2, end) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map2 = new Map();
      for (var i4 = start2; i4 <= end; i4++) {
        if (embeddingLevels[i4] & 1) {
          var mirror = getMirroredCharacter(string[i4]);
          if (mirror !== null) {
            map2.set(i4, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start2, end) {
      var strLen = string.length;
      start2 = Math.max(0, start2 == null ? 0 : +start2);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start2, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i4 = lineEnd; i4 >= lineStart && getBidiCharType(string[i4]) & TRAILING_TYPES; i4--) {
            lineLevels[i4] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + start2, i$2 + start2]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start2, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start2, end);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i4) {
        chars[i4] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start2, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start2, end);
      var indices = [];
      for (var i4 = 0; i4 < string.length; i4++) {
        indices[i4] = i4;
      }
      segments.forEach(function(ref) {
        var start3 = ref[0];
        var end2 = ref[1];
        var slice = indices.slice(start3, end2 + 1);
        for (var i5 = slice.length; i5--; ) {
          indices[end2 - i5] = slice[i5];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i4 = 0; i4 < 256; i4++) {
  _lut[i4] = (i4 < 16 ? "0" : "") + i4.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign2 = Object.assign || function() {
  let target2 = arguments[0];
  for (let i4 = 1, len = arguments.length; i4 < len; i4++) {
    let source = arguments[i4];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
          target2[prop] = source[prop];
        }
      }
    }
  }
  return target2;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = new WeakMap();
var SHADER_UPGRADE_CACHE = new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo);
    const cacheKey2 = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey2];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey2] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign2(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived = Object.create(base, descriptor);
    Object.defineProperty(derived, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived, "id", { value: materialInstanceId++ });
    derived.uuid = generateUUID();
    derived.uniforms = assign2({}, base.uniforms, options.uniforms);
    derived.defines = assign2({}, base.defines, options.defines);
    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived.extensions = assign2({}, base.extensions, options.extensions);
    derived._listeners = void 0;
    return derived;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign2(this.extensions, source.extensions);
          assign2(this.defines, source.defines);
          assign2(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), options);
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(), options);
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial)
          _depthMaterial.dispose();
        if (_distanceMaterial)
          _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders({ vertexShader, fragmentShader }, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader = expandShaderIncludes(vertexShader);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader = fragmentShader.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n");
    fragmentShader = expandShaderIncludes(fragmentShader);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader, fragmentShader });
    vertexShader = res.vertexShader;
    fragmentShader = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader = fragmentShader.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, (match) => {
      postChunks.push(match);
      return "";
    });
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
  }
  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader,
    fragmentShader
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(voidMainRegExp, `
${defs}
void troikaOrigMain${id}() {`);
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function createSDFGenerator(createGlyphSegmentsIndex2) {
  const CURVE_POINTS = 16;
  function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t2) {
    const t22 = 1 - t2;
    return {
      x: t22 * t22 * x0 + 2 * t22 * t2 * x1 + t2 * t2 * x2,
      y: t22 * t22 * y0 + 2 * t22 * t2 * y1 + t2 * t2 * y2
    };
  }
  function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t2) {
    const t22 = 1 - t2;
    return {
      x: t22 * t22 * t22 * x0 + 3 * t22 * t22 * t2 * x1 + 3 * t22 * t2 * t2 * x2 + t2 * t2 * t2 * x3,
      y: t22 * t22 * t22 * y0 + 3 * t22 * t22 * t2 * y1 + 3 * t22 * t2 * t2 * y2 + t2 * t2 * t2 * y3
    };
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function generateSDF(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent = 1) {
    const start2 = now2();
    const textureData = new Uint8Array(sdfWidth * sdfHeight);
    const viewBoxWidth = viewBox[2] - viewBox[0];
    const viewBoxHeight = viewBox[3] - viewBox[1];
    const lineSegmentsIndex = createGlyphSegmentsIndex2(viewBox);
    const segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
    let match, firstX, firstY, prevX, prevY;
    while (match = segmentRE.exec(path)) {
      const args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map((v4) => parseFloat(v4));
      switch (match[1]) {
        case "M":
          prevX = firstX = args[0];
          prevY = firstY = args[1];
          break;
        case "L":
          if (args[0] !== prevX || args[1] !== prevY) {
            lineSegmentsIndex.addLineSegment(prevX, prevY, prevX = args[0], prevY = args[1]);
          }
          break;
        case "Q": {
          let prevPoint = { x: prevX, y: prevY };
          for (let i4 = 1; i4 < CURVE_POINTS; i4++) {
            let nextPoint = pointOnQuadraticBezier(prevX, prevY, args[0], args[1], args[2], args[3], i4 / (CURVE_POINTS - 1));
            lineSegmentsIndex.addLineSegment(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y);
            prevPoint = nextPoint;
          }
          prevX = args[2];
          prevY = args[3];
          break;
        }
        case "C": {
          let prevPoint = { x: prevX, y: prevY };
          for (let i4 = 1; i4 < CURVE_POINTS; i4++) {
            let nextPoint = pointOnCubicBezier(prevX, prevY, args[0], args[1], args[2], args[3], args[4], args[5], i4 / (CURVE_POINTS - 1));
            lineSegmentsIndex.addLineSegment(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y);
            prevPoint = nextPoint;
          }
          prevX = args[4];
          prevY = args[5];
          break;
        }
        case "Z":
          if (prevX !== firstX || prevY !== firstY) {
            lineSegmentsIndex.addLineSegment(prevX, prevY, firstX, firstY);
          }
          break;
      }
    }
    for (let sdfX = 0; sdfX < sdfWidth; sdfX++) {
      for (let sdfY = 0; sdfY < sdfHeight; sdfY++) {
        const signedDist = lineSegmentsIndex.findNearestSignedDistance(viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth, viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight, maxDistance);
        let alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
        if (signedDist < 0) {
          alpha = 1 - alpha;
        }
        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
        textureData[sdfY * sdfWidth + sdfX] = alpha;
      }
    }
    return {
      textureData,
      timing: now2() - start2
    };
  }
  return generateSDF;
}
function createTypesetter(fontParser, bidi, config2) {
  const {
    defaultFontURL
  } = config2;
  const fonts = Object.create(null);
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const BREAK_AFTER_CHARS = /[\s\-\u007C\u00AD\u2010\u2012-\u2014\u2027\u2056\u2E17\u2E40]/;
  function doLoadFont(url, callback) {
    function tryLoad() {
      const onError = (err) => {
        console.error(`Failure loading font ${url}${url === defaultFontURL ? "" : "; trying fallback"}`, err);
        if (url !== defaultFontURL) {
          url = defaultFontURL;
          tryLoad();
        }
      };
      try {
        const request = new XMLHttpRequest();
        request.open("get", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
          if (request.status >= 400) {
            onError(new Error(request.statusText));
          } else if (request.status > 0) {
            try {
              const fontObj = fontParser(request.response);
              callback(fontObj);
            } catch (e2) {
              onError(e2);
            }
          }
        };
        request.onerror = onError;
        request.send();
      } catch (err) {
        onError(err);
      }
    }
    tryLoad();
  }
  function loadFont(fontUrl, callback) {
    if (!fontUrl)
      fontUrl = defaultFontURL;
    let font = fonts[fontUrl];
    if (font) {
      if (font.pending) {
        font.pending.push(callback);
      } else {
        callback(font);
      }
    } else {
      fonts[fontUrl] = { pending: [callback] };
      doLoadFont(fontUrl, (fontObj) => {
        let callbacks = fonts[fontUrl].pending;
        fonts[fontUrl] = fontObj;
        callbacks.forEach((cb) => cb(fontObj));
      });
    }
  }
  function typeset({
    text = "",
    font = defaultFontURL,
    sdfGlyphSize = 64,
    fontSize = 1,
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback, metricsOnly = false) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    loadFont(font, (fontObj) => {
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const { ascender, descender, unitsPerEm } = fontObj;
      timings.fontLoad = now2() - mainStart;
      const typesetStart = now2();
      const fontSizeMult = fontSize / unitsPerEm;
      if (lineHeight === "normal") {
        lineHeight = (ascender - descender) / unitsPerEm;
      }
      lineHeight = lineHeight * fontSize;
      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
      const topBaseline = -(ascender * fontSizeMult + halfLeading);
      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;
      let lineXOffset = textIndent;
      let currentLine = new TextLine();
      const lines = [currentLine];
      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {
        const char = text.charAt(charIndex);
        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
        const curLineCount = currentLine.count;
        let nextLine;
        if (!("isEmpty" in glyphObj)) {
          glyphObj.isWhitespace = !!char && /\s/.test(char);
          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
        }
        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
          renderableGlyphCount++;
        }
        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
            nextLine = new TextLine();
            lineXOffset = -glyphX;
          } else {
            for (let i4 = curLineCount; i4--; ) {
              if (i4 === 0 && overflowWrap === "break-word") {
                nextLine = new TextLine();
                lineXOffset = -glyphX;
                break;
              } else if (currentLine.glyphAt(i4).glyphObj.canBreakAfter) {
                nextLine = currentLine.splitAt(i4 + 1);
                const adjustX = nextLine.glyphAt(0).x;
                lineXOffset -= adjustX;
                for (let j = nextLine.count; j--; ) {
                  nextLine.glyphAt(j).x -= adjustX;
                }
                break;
              }
            }
          }
          if (nextLine) {
            currentLine.isSoftWrapped = true;
            currentLine = nextLine;
            lines.push(currentLine);
            maxLineWidth = maxWidth;
          }
        }
        let fly = currentLine.glyphAt(currentLine.count);
        fly.glyphObj = glyphObj;
        fly.x = glyphX + lineXOffset;
        fly.width = glyphWidth;
        fly.charIndex = charIndex;
        if (char === "\n") {
          currentLine = new TextLine();
          lines.push(currentLine);
          lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
        }
      });
      lines.forEach((line) => {
        for (let i4 = line.count; i4--; ) {
          let { glyphObj, x, width } = line.glyphAt(i4);
          if (!glyphObj.isWhitespace) {
            line.width = x + width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            return;
          }
        }
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          let height = lines.length * lineHeight;
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -topBaseline : anchorY === "middle" ? height / 2 : anchorY === "bottom" ? height : anchorY === "bottom-baseline" ? height - halfLeading + descender * fontSizeMult : parsePercent(anchorY) * height;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        let lineYOffset = topBaseline;
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 3);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i4 = lineGlyphCount; i4-- && line.glyphAt(i4).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i4 = lineGlyphCount - trailingWhitespaceCount; i4--; ) {
                if (line.glyphAt(i4).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i4 = 0; i4 < lineGlyphCount; i4++) {
                let glyphInfo = line.glyphAt(i4);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i4 < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex);
            for (let fi = 0; fi < flips.length; fi++) {
              const [start2, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i4 = 0; i4 < lineGlyphCount; i4++) {
                if (line.glyphAt(i4).charIndex >= start2) {
                  let startInLine = i4, endInLine = i4;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g) => glyphObj = g;
            for (let i4 = 0; i4 < lineGlyphCount; i4++) {
              let glyphInfo = line.glyphAt(i4);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                if (!glyphData[glyphId]) {
                  glyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = lineYOffset + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0])
                  visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1])
                  visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2])
                  visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3])
                  visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0])
                  chunkRect[0] = visX0;
                if (visY0 < chunkRect[1])
                  chunkRect[1] = visY0;
                if (visX1 > chunkRect[2])
                  chunkRect[2] = visX1;
                if (visY1 > chunkRect[3])
                  chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                if (colorRanges) {
                  const start2 = idx * 3;
                  glyphColors[start2] = currentColor >> 16 & 255;
                  glyphColors[start2 + 1] = currentColor >> 8 & 255;
                  glyphColors[start2 + 2] = currentColor & 255;
                }
              }
            }
          }
          lineYOffset -= lineHeight;
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        glyphPositions,
        glyphData,
        caretPositions,
        caretHeight,
        glyphColors,
        chunkedBounds,
        fontSize,
        unitsPerEm,
        ascender: ascender * fontSizeMult,
        descender: descender * fontSizeMult,
        lineHeight,
        topBaseline,
        blockBounds: [
          anchorXOffset,
          anchorYOffset - lines.length * lineHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset(args, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    }, { metricsOnly: true });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 3];
    const ligEndX = caretPositions[ligStartIndex * 3 + 1];
    const ligY = caretPositions[ligStartIndex * 3 + 2];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i4 = 0; i4 < ligCount; i4++) {
      const startIndex = (ligStartIndex + i4) * 3;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i4;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i4 + 1);
      caretPositions[startIndex + 2] = ligY;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "width", "charIndex"];
  TextLine.prototype = {
    width: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i4) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i4;
      return fly;
    },
    splitAt(i4) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i4 * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i4, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i4];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i4] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure,
    loadFont
  };
}
function createGlyphSegmentsIndex(bounds) {
  let needsSort = false;
  const segments = [];
  function sortSegments() {
    if (needsSort) {
      segments.sort(function(a2, b) {
        return a2.maxX - b.maxX;
      });
      needsSort = false;
    }
  }
  function addLineSegment(x0, y0, x1, y1) {
    const segment = {
      x0,
      y0,
      x1,
      y1,
      minX: Math.min(x0, x1),
      minY: Math.min(y0, y1),
      maxX: Math.max(x0, x1),
      maxY: Math.max(y0, y1)
    };
    segments.push(segment);
    needsSort = true;
  }
  function findNearestSignedDistance(x, y) {
    sortSegments();
    let closestDistSq = Infinity;
    let closestDist = Infinity;
    for (let i4 = segments.length; i4--; ) {
      const seg = segments[i4];
      if (seg.maxX + closestDist <= x)
        break;
      if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
        const distSq = absSquareDistanceToLineSegment(x, y, seg.x0, seg.y0, seg.x1, seg.y1);
        if (distSq < closestDistSq) {
          closestDistSq = distSq;
          closestDist = Math.sqrt(closestDistSq);
        }
      }
    }
    if (isPointInPoly(x, y)) {
      closestDist = -closestDist;
    }
    return closestDist;
  }
  function isPointInPoly(x, y) {
    sortSegments();
    let inside = false;
    for (let i4 = segments.length; i4--; ) {
      const seg = segments[i4];
      if (seg.maxX <= x)
        break;
      if (seg.minY < y && seg.maxY > y) {
        const intersects = seg.y0 > y !== seg.y1 > y && x < (seg.x1 - seg.x0) * (y - seg.y0) / (seg.y1 - seg.y0) + seg.x0;
        if (intersects) {
          inside = !inside;
        }
      }
    }
    return inside;
  }
  function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {
    const ldx = lineX1 - lineX0;
    const ldy = lineY1 - lineY0;
    const lengthSq = ldx * ldx + ldy * ldy;
    const t2 = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
    const dx = x - (lineX0 + t2 * ldx);
    const dy = y - (lineY0 + t2 * ldy);
    return dx * dx + dy * dy;
  }
  return {
    addLineSegment,
    findNearestSignedDistance
  };
}
function typrFactory() {
  return typeof window == "undefined" && (self.window = self), function(r2) {
    var e2 = { parse: function(r3) {
      var t3 = e2._bin, a3 = new Uint8Array(r3);
      if (t3.readASCII(a3, 0, 4) == "ttcf") {
        var n2 = 4;
        t3.readUshort(a3, n2), n2 += 2, t3.readUshort(a3, n2), n2 += 2;
        var o2 = t3.readUint(a3, n2);
        n2 += 4;
        for (var s = [], i4 = 0; i4 < o2; i4++) {
          var h = t3.readUint(a3, n2);
          n2 += 4, s.push(e2._readFont(a3, h));
        }
        return s;
      }
      return [e2._readFont(a3, 0)];
    }, _readFont: function(r3, t3) {
      var a3 = e2._bin, n2 = t3;
      a3.readFixed(r3, t3), t3 += 4;
      var o2 = a3.readUshort(r3, t3);
      t3 += 2, a3.readUshort(r3, t3), t3 += 2, a3.readUshort(r3, t3), t3 += 2, a3.readUshort(r3, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], i4 = { _data: r3, _offset: n2 }, h = {}, f = 0; f < o2; f++) {
        var d2 = a3.readASCII(r3, t3, 4);
        t3 += 4, a3.readUint(r3, t3), t3 += 4;
        var l2 = a3.readUint(r3, t3);
        t3 += 4;
        var u = a3.readUint(r3, t3);
        t3 += 4, h[d2] = { offset: l2, length: u };
      }
      for (f = 0; f < s.length; f++) {
        var v4 = s[f];
        h[v4] && (i4[v4.trim()] = e2[v4.trim()].parse(r3, h[v4].offset, h[v4].length, i4));
      }
      return i4;
    }, _tabOffset: function(r3, t3, a3) {
      for (var n2 = e2._bin, o2 = n2.readUshort(r3, a3 + 4), s = a3 + 12, i4 = 0; i4 < o2; i4++) {
        var h = n2.readASCII(r3, s, 4);
        s += 4, n2.readUint(r3, s), s += 4;
        var f = n2.readUint(r3, s);
        if (s += 4, n2.readUint(r3, s), s += 4, h == t3)
          return f;
      }
      return 0;
    } };
    e2._bin = { readFixed: function(r3, e3) {
      return (r3[e3] << 8 | r3[e3 + 1]) + (r3[e3 + 2] << 8 | r3[e3 + 3]) / 65540;
    }, readF2dot14: function(r3, t3) {
      return e2._bin.readShort(r3, t3) / 16384;
    }, readInt: function(r3, t3) {
      return e2._bin._view(r3).getInt32(t3);
    }, readInt8: function(r3, t3) {
      return e2._bin._view(r3).getInt8(t3);
    }, readShort: function(r3, t3) {
      return e2._bin._view(r3).getInt16(t3);
    }, readUshort: function(r3, t3) {
      return e2._bin._view(r3).getUint16(t3);
    }, readUshorts: function(r3, t3, a3) {
      for (var n2 = [], o2 = 0; o2 < a3; o2++)
        n2.push(e2._bin.readUshort(r3, t3 + 2 * o2));
      return n2;
    }, readUint: function(r3, t3) {
      return e2._bin._view(r3).getUint32(t3);
    }, readUint64: function(r3, t3) {
      return 4294967296 * e2._bin.readUint(r3, t3) + e2._bin.readUint(r3, t3 + 4);
    }, readASCII: function(r3, e3, t3) {
      for (var a3 = "", n2 = 0; n2 < t3; n2++)
        a3 += String.fromCharCode(r3[e3 + n2]);
      return a3;
    }, readUnicode: function(r3, e3, t3) {
      for (var a3 = "", n2 = 0; n2 < t3; n2++) {
        var o2 = r3[e3++] << 8 | r3[e3++];
        a3 += String.fromCharCode(o2);
      }
      return a3;
    }, _tdec: typeof window != "undefined" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r3, t3, a3) {
      var n2 = e2._bin._tdec;
      return n2 && t3 == 0 && a3 == r3.length ? n2.decode(r3) : e2._bin.readASCII(r3, t3, a3);
    }, readBytes: function(r3, e3, t3) {
      for (var a3 = [], n2 = 0; n2 < t3; n2++)
        a3.push(r3[e3 + n2]);
      return a3;
    }, readASCIIArray: function(r3, e3, t3) {
      for (var a3 = [], n2 = 0; n2 < t3; n2++)
        a3.push(String.fromCharCode(r3[e3 + n2]));
      return a3;
    }, _view: function(r3) {
      return r3._dataView || (r3._dataView = r3.buffer ? new DataView(r3.buffer, r3.byteOffset, r3.byteLength) : new DataView(new Uint8Array(r3).buffer));
    } }, e2._lctf = {}, e2._lctf.parse = function(r3, t3, a3, n2, o2) {
      var s = e2._bin, i4 = {}, h = t3;
      s.readFixed(r3, t3), t3 += 4;
      var f = s.readUshort(r3, t3);
      t3 += 2;
      var d2 = s.readUshort(r3, t3);
      t3 += 2;
      var l2 = s.readUshort(r3, t3);
      return t3 += 2, i4.scriptList = e2._lctf.readScriptList(r3, h + f), i4.featureList = e2._lctf.readFeatureList(r3, h + d2), i4.lookupList = e2._lctf.readLookupList(r3, h + l2, o2), i4;
    }, e2._lctf.readLookupList = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = t3, s = [], i4 = n2.readUshort(r3, t3);
      t3 += 2;
      for (var h = 0; h < i4; h++) {
        var f = n2.readUshort(r3, t3);
        t3 += 2;
        var d2 = e2._lctf.readLookupTable(r3, o2 + f, a3);
        s.push(d2);
      }
      return s;
    }, e2._lctf.readLookupTable = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = t3, s = { tabs: [] };
      s.ltype = n2.readUshort(r3, t3), t3 += 2, s.flag = n2.readUshort(r3, t3), t3 += 2;
      var i4 = n2.readUshort(r3, t3);
      t3 += 2;
      for (var h = s.ltype, f = 0; f < i4; f++) {
        var d2 = n2.readUshort(r3, t3);
        t3 += 2;
        var l2 = a3(r3, h, o2 + d2, s);
        s.tabs.push(l2);
      }
      return s;
    }, e2._lctf.numOfOnes = function(r3) {
      for (var e3 = 0, t3 = 0; t3 < 32; t3++)
        (r3 >>> t3 & 1) != 0 && e3++;
      return e3;
    }, e2._lctf.readClassDef = function(r3, t3) {
      var a3 = e2._bin, n2 = [], o2 = a3.readUshort(r3, t3);
      if (t3 += 2, o2 == 1) {
        var s = a3.readUshort(r3, t3);
        t3 += 2;
        var i4 = a3.readUshort(r3, t3);
        t3 += 2;
        for (var h = 0; h < i4; h++)
          n2.push(s + h), n2.push(s + h), n2.push(a3.readUshort(r3, t3)), t3 += 2;
      }
      if (o2 == 2) {
        var f = a3.readUshort(r3, t3);
        t3 += 2;
        for (h = 0; h < f; h++)
          n2.push(a3.readUshort(r3, t3)), t3 += 2, n2.push(a3.readUshort(r3, t3)), t3 += 2, n2.push(a3.readUshort(r3, t3)), t3 += 2;
      }
      return n2;
    }, e2._lctf.getInterval = function(r3, e3) {
      for (var t3 = 0; t3 < r3.length; t3 += 3) {
        var a3 = r3[t3], n2 = r3[t3 + 1];
        if (r3[t3 + 2], a3 <= e3 && e3 <= n2)
          return t3;
      }
      return -1;
    }, e2._lctf.readCoverage = function(r3, t3) {
      var a3 = e2._bin, n2 = {};
      n2.fmt = a3.readUshort(r3, t3), t3 += 2;
      var o2 = a3.readUshort(r3, t3);
      return t3 += 2, n2.fmt == 1 && (n2.tab = a3.readUshorts(r3, t3, o2)), n2.fmt == 2 && (n2.tab = a3.readUshorts(r3, t3, 3 * o2)), n2;
    }, e2._lctf.coverageIndex = function(r3, t3) {
      var a3 = r3.tab;
      if (r3.fmt == 1)
        return a3.indexOf(t3);
      if (r3.fmt == 2) {
        var n2 = e2._lctf.getInterval(a3, t3);
        if (n2 != -1)
          return a3[n2 + 2] + (t3 - a3[n2]);
      }
      return -1;
    }, e2._lctf.readFeatureList = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = [], s = a3.readUshort(r3, t3);
      t3 += 2;
      for (var i4 = 0; i4 < s; i4++) {
        var h = a3.readASCII(r3, t3, 4);
        t3 += 4;
        var f = a3.readUshort(r3, t3);
        t3 += 2;
        var d2 = e2._lctf.readFeatureTable(r3, n2 + f);
        d2.tag = h.trim(), o2.push(d2);
      }
      return o2;
    }, e2._lctf.readFeatureTable = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = {}, s = a3.readUshort(r3, t3);
      t3 += 2, s > 0 && (o2.featureParams = n2 + s);
      var i4 = a3.readUshort(r3, t3);
      t3 += 2, o2.tab = [];
      for (var h = 0; h < i4; h++)
        o2.tab.push(a3.readUshort(r3, t3 + 2 * h));
      return o2;
    }, e2._lctf.readScriptList = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = {}, s = a3.readUshort(r3, t3);
      t3 += 2;
      for (var i4 = 0; i4 < s; i4++) {
        var h = a3.readASCII(r3, t3, 4);
        t3 += 4;
        var f = a3.readUshort(r3, t3);
        t3 += 2, o2[h.trim()] = e2._lctf.readScriptTable(r3, n2 + f);
      }
      return o2;
    }, e2._lctf.readScriptTable = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = {}, s = a3.readUshort(r3, t3);
      t3 += 2, o2.default = e2._lctf.readLangSysTable(r3, n2 + s);
      var i4 = a3.readUshort(r3, t3);
      t3 += 2;
      for (var h = 0; h < i4; h++) {
        var f = a3.readASCII(r3, t3, 4);
        t3 += 4;
        var d2 = a3.readUshort(r3, t3);
        t3 += 2, o2[f.trim()] = e2._lctf.readLangSysTable(r3, n2 + d2);
      }
      return o2;
    }, e2._lctf.readLangSysTable = function(r3, t3) {
      var a3 = e2._bin, n2 = {};
      a3.readUshort(r3, t3), t3 += 2, n2.reqFeature = a3.readUshort(r3, t3), t3 += 2;
      var o2 = a3.readUshort(r3, t3);
      return t3 += 2, n2.features = a3.readUshorts(r3, t3, o2), n2;
    }, e2.CFF = {}, e2.CFF.parse = function(r3, t3, a3) {
      var n2 = e2._bin;
      (r3 = new Uint8Array(r3.buffer, t3, a3))[t3 = 0], r3[++t3], r3[++t3], r3[++t3], t3++;
      var o2 = [];
      t3 = e2.CFF.readIndex(r3, t3, o2);
      for (var s = [], i4 = 0; i4 < o2.length - 1; i4++)
        s.push(n2.readASCII(r3, t3 + o2[i4], o2[i4 + 1] - o2[i4]));
      t3 += o2[o2.length - 1];
      var h = [];
      t3 = e2.CFF.readIndex(r3, t3, h);
      var f = [];
      for (i4 = 0; i4 < h.length - 1; i4++)
        f.push(e2.CFF.readDict(r3, t3 + h[i4], t3 + h[i4 + 1]));
      t3 += h[h.length - 1];
      var d2 = f[0], l2 = [];
      t3 = e2.CFF.readIndex(r3, t3, l2);
      var u = [];
      for (i4 = 0; i4 < l2.length - 1; i4++)
        u.push(n2.readASCII(r3, t3 + l2[i4], l2[i4 + 1] - l2[i4]));
      if (t3 += l2[l2.length - 1], e2.CFF.readSubrs(r3, t3, d2), d2.CharStrings) {
        t3 = d2.CharStrings;
        l2 = [];
        t3 = e2.CFF.readIndex(r3, t3, l2);
        var v4 = [];
        for (i4 = 0; i4 < l2.length - 1; i4++)
          v4.push(n2.readBytes(r3, t3 + l2[i4], l2[i4 + 1] - l2[i4]));
        d2.CharStrings = v4;
      }
      if (d2.ROS) {
        t3 = d2.FDArray;
        var c6 = [];
        t3 = e2.CFF.readIndex(r3, t3, c6), d2.FDArray = [];
        for (i4 = 0; i4 < c6.length - 1; i4++) {
          var p = e2.CFF.readDict(r3, t3 + c6[i4], t3 + c6[i4 + 1]);
          e2.CFF._readFDict(r3, p, u), d2.FDArray.push(p);
        }
        t3 += c6[c6.length - 1], t3 = d2.FDSelect, d2.FDSelect = [];
        var U = r3[t3];
        if (t3++, U != 3)
          throw U;
        var g = n2.readUshort(r3, t3);
        t3 += 2;
        for (i4 = 0; i4 < g + 1; i4++)
          d2.FDSelect.push(n2.readUshort(r3, t3), r3[t3 + 2]), t3 += 3;
      }
      return d2.Encoding && (d2.Encoding = e2.CFF.readEncoding(r3, d2.Encoding, d2.CharStrings.length)), d2.charset && (d2.charset = e2.CFF.readCharset(r3, d2.charset, d2.CharStrings.length)), e2.CFF._readFDict(r3, d2, u), d2;
    }, e2.CFF._readFDict = function(r3, t3, a3) {
      var n2;
      for (var o2 in t3.Private && (n2 = t3.Private[1], t3.Private = e2.CFF.readDict(r3, n2, n2 + t3.Private[0]), t3.Private.Subrs && e2.CFF.readSubrs(r3, n2 + t3.Private.Subrs, t3.Private)), t3)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o2) != -1 && (t3[o2] = a3[t3[o2] - 426 + 35]);
    }, e2.CFF.readSubrs = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = [];
      t3 = e2.CFF.readIndex(r3, t3, o2);
      var s, i4 = o2.length;
      s = i4 < 1240 ? 107 : i4 < 33900 ? 1131 : 32768, a3.Bias = s, a3.Subrs = [];
      for (var h = 0; h < o2.length - 1; h++)
        a3.Subrs.push(n2.readBytes(r3, t3 + o2[h], o2[h + 1] - o2[h]));
    }, e2.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e2.CFF.glyphByUnicode = function(r3, e3) {
      for (var t3 = 0; t3 < r3.charset.length; t3++)
        if (r3.charset[t3] == e3)
          return t3;
      return -1;
    }, e2.CFF.glyphBySE = function(r3, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e2.CFF.glyphByUnicode(r3, e2.CFF.tableSE[t3]);
    }, e2.CFF.readEncoding = function(r3, t3, a3) {
      e2._bin;
      var n2 = [".notdef"], o2 = r3[t3];
      if (t3++, o2 != 0)
        throw "error: unknown encoding format: " + o2;
      var s = r3[t3];
      t3++;
      for (var i4 = 0; i4 < s; i4++)
        n2.push(r3[t3 + i4]);
      return n2;
    }, e2.CFF.readCharset = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = [".notdef"], s = r3[t3];
      if (t3++, s == 0)
        for (var i4 = 0; i4 < a3; i4++) {
          var h = n2.readUshort(r3, t3);
          t3 += 2, o2.push(h);
        }
      else {
        if (s != 1 && s != 2)
          throw "error: format: " + s;
        for (; o2.length < a3; ) {
          h = n2.readUshort(r3, t3);
          t3 += 2;
          var f = 0;
          s == 1 ? (f = r3[t3], t3++) : (f = n2.readUshort(r3, t3), t3 += 2);
          for (i4 = 0; i4 <= f; i4++)
            o2.push(h), h++;
        }
      }
      return o2;
    }, e2.CFF.readIndex = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = n2.readUshort(r3, t3) + 1, s = r3[t3 += 2];
      if (t3++, s == 1)
        for (var i4 = 0; i4 < o2; i4++)
          a3.push(r3[t3 + i4]);
      else if (s == 2)
        for (i4 = 0; i4 < o2; i4++)
          a3.push(n2.readUshort(r3, t3 + 2 * i4));
      else if (s == 3)
        for (i4 = 0; i4 < o2; i4++)
          a3.push(16777215 & n2.readUint(r3, t3 + 3 * i4 - 1));
      else if (o2 != 1)
        throw "unsupported offset size: " + s + ", count: " + o2;
      return (t3 += o2 * s) - 1;
    }, e2.CFF.getCharString = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = r3[t3], s = r3[t3 + 1];
      r3[t3 + 2], r3[t3 + 3], r3[t3 + 4];
      var i4 = 1, h = null, f = null;
      o2 <= 20 && (h = o2, i4 = 1), o2 == 12 && (h = 100 * o2 + s, i4 = 2), 21 <= o2 && o2 <= 27 && (h = o2, i4 = 1), o2 == 28 && (f = n2.readShort(r3, t3 + 1), i4 = 3), 29 <= o2 && o2 <= 31 && (h = o2, i4 = 1), 32 <= o2 && o2 <= 246 && (f = o2 - 139, i4 = 1), 247 <= o2 && o2 <= 250 && (f = 256 * (o2 - 247) + s + 108, i4 = 2), 251 <= o2 && o2 <= 254 && (f = 256 * -(o2 - 251) - s - 108, i4 = 2), o2 == 255 && (f = n2.readInt(r3, t3 + 1) / 65535, i4 = 5), a3.val = f != null ? f : "o" + h, a3.size = i4;
    }, e2.CFF.readCharString = function(r3, t3, a3) {
      for (var n2 = t3 + a3, o2 = e2._bin, s = []; t3 < n2; ) {
        var i4 = r3[t3], h = r3[t3 + 1];
        r3[t3 + 2], r3[t3 + 3], r3[t3 + 4];
        var f = 1, d2 = null, l2 = null;
        i4 <= 20 && (d2 = i4, f = 1), i4 == 12 && (d2 = 100 * i4 + h, f = 2), i4 != 19 && i4 != 20 || (d2 = i4, f = 2), 21 <= i4 && i4 <= 27 && (d2 = i4, f = 1), i4 == 28 && (l2 = o2.readShort(r3, t3 + 1), f = 3), 29 <= i4 && i4 <= 31 && (d2 = i4, f = 1), 32 <= i4 && i4 <= 246 && (l2 = i4 - 139, f = 1), 247 <= i4 && i4 <= 250 && (l2 = 256 * (i4 - 247) + h + 108, f = 2), 251 <= i4 && i4 <= 254 && (l2 = 256 * -(i4 - 251) - h - 108, f = 2), i4 == 255 && (l2 = o2.readInt(r3, t3 + 1) / 65535, f = 5), s.push(l2 != null ? l2 : "o" + d2), t3 += f;
      }
      return s;
    }, e2.CFF.readDict = function(r3, t3, a3) {
      for (var n2 = e2._bin, o2 = {}, s = []; t3 < a3; ) {
        var i4 = r3[t3], h = r3[t3 + 1];
        r3[t3 + 2], r3[t3 + 3], r3[t3 + 4];
        var f = 1, d2 = null, l2 = null;
        if (i4 == 28 && (l2 = n2.readShort(r3, t3 + 1), f = 3), i4 == 29 && (l2 = n2.readInt(r3, t3 + 1), f = 5), 32 <= i4 && i4 <= 246 && (l2 = i4 - 139, f = 1), 247 <= i4 && i4 <= 250 && (l2 = 256 * (i4 - 247) + h + 108, f = 2), 251 <= i4 && i4 <= 254 && (l2 = 256 * -(i4 - 251) - h - 108, f = 2), i4 == 255)
          throw l2 = n2.readInt(r3, t3 + 1) / 65535, f = 5, "unknown number";
        if (i4 == 30) {
          var u = [];
          for (f = 1; ; ) {
            var v4 = r3[t3 + f];
            f++;
            var c6 = v4 >> 4, p = 15 & v4;
            if (c6 != 15 && u.push(c6), p != 15 && u.push(p), p == 15)
              break;
          }
          for (var U = "", g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < u.length; S++)
            U += g[u[S]];
          l2 = parseFloat(U);
        }
        if (i4 <= 21) {
          if (d2 = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i4], f = 1, i4 == 12)
            d2 = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], f = 2;
        }
        d2 != null ? (o2[d2] = s.length == 1 ? s[0] : s, s = []) : s.push(l2), t3 += f;
      }
      return o2;
    }, e2.cmap = {}, e2.cmap.parse = function(r3, t3, a3) {
      r3 = new Uint8Array(r3.buffer, t3, a3), t3 = 0;
      var n2 = e2._bin, o2 = {};
      n2.readUshort(r3, t3), t3 += 2;
      var s = n2.readUshort(r3, t3);
      t3 += 2;
      var i4 = [];
      o2.tables = [];
      for (var h = 0; h < s; h++) {
        var f = n2.readUshort(r3, t3);
        t3 += 2;
        var d2 = n2.readUshort(r3, t3);
        t3 += 2;
        var l2 = n2.readUint(r3, t3);
        t3 += 4;
        var u = "p" + f + "e" + d2, v4 = i4.indexOf(l2);
        if (v4 == -1) {
          var c6;
          v4 = o2.tables.length, i4.push(l2);
          var p = n2.readUshort(r3, l2);
          p == 0 ? c6 = e2.cmap.parse0(r3, l2) : p == 4 ? c6 = e2.cmap.parse4(r3, l2) : p == 6 ? c6 = e2.cmap.parse6(r3, l2) : p == 12 ? c6 = e2.cmap.parse12(r3, l2) : console.debug("unknown format: " + p, f, d2, l2), o2.tables.push(c6);
        }
        if (o2[u] != null)
          throw "multiple tables for one platform+encoding";
        o2[u] = v4;
      }
      return o2;
    }, e2.cmap.parse0 = function(r3, t3) {
      var a3 = e2._bin, n2 = {};
      n2.format = a3.readUshort(r3, t3), t3 += 2;
      var o2 = a3.readUshort(r3, t3);
      t3 += 2, a3.readUshort(r3, t3), t3 += 2, n2.map = [];
      for (var s = 0; s < o2 - 6; s++)
        n2.map.push(r3[t3 + s]);
      return n2;
    }, e2.cmap.parse4 = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = {};
      o2.format = a3.readUshort(r3, t3), t3 += 2;
      var s = a3.readUshort(r3, t3);
      t3 += 2, a3.readUshort(r3, t3), t3 += 2;
      var i4 = a3.readUshort(r3, t3);
      t3 += 2;
      var h = i4 / 2;
      o2.searchRange = a3.readUshort(r3, t3), t3 += 2, o2.entrySelector = a3.readUshort(r3, t3), t3 += 2, o2.rangeShift = a3.readUshort(r3, t3), t3 += 2, o2.endCount = a3.readUshorts(r3, t3, h), t3 += 2 * h, t3 += 2, o2.startCount = a3.readUshorts(r3, t3, h), t3 += 2 * h, o2.idDelta = [];
      for (var f = 0; f < h; f++)
        o2.idDelta.push(a3.readShort(r3, t3)), t3 += 2;
      for (o2.idRangeOffset = a3.readUshorts(r3, t3, h), t3 += 2 * h, o2.glyphIdArray = []; t3 < n2 + s; )
        o2.glyphIdArray.push(a3.readUshort(r3, t3)), t3 += 2;
      return o2;
    }, e2.cmap.parse6 = function(r3, t3) {
      var a3 = e2._bin, n2 = {};
      n2.format = a3.readUshort(r3, t3), t3 += 2, a3.readUshort(r3, t3), t3 += 2, a3.readUshort(r3, t3), t3 += 2, n2.firstCode = a3.readUshort(r3, t3), t3 += 2;
      var o2 = a3.readUshort(r3, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s = 0; s < o2; s++)
        n2.glyphIdArray.push(a3.readUshort(r3, t3)), t3 += 2;
      return n2;
    }, e2.cmap.parse12 = function(r3, t3) {
      var a3 = e2._bin, n2 = {};
      n2.format = a3.readUshort(r3, t3), t3 += 2, t3 += 2, a3.readUint(r3, t3), t3 += 4, a3.readUint(r3, t3), t3 += 4;
      var o2 = a3.readUint(r3, t3);
      t3 += 4, n2.groups = [];
      for (var s = 0; s < o2; s++) {
        var i4 = t3 + 12 * s, h = a3.readUint(r3, i4 + 0), f = a3.readUint(r3, i4 + 4), d2 = a3.readUint(r3, i4 + 8);
        n2.groups.push([h, f, d2]);
      }
      return n2;
    }, e2.glyf = {}, e2.glyf.parse = function(r3, e3, t3, a3) {
      for (var n2 = [], o2 = 0; o2 < a3.maxp.numGlyphs; o2++)
        n2.push(null);
      return n2;
    }, e2.glyf._parseGlyf = function(r3, t3) {
      var a3 = e2._bin, n2 = r3._data, o2 = e2._tabOffset(n2, "glyf", r3._offset) + r3.loca[t3];
      if (r3.loca[t3] == r3.loca[t3 + 1])
        return null;
      var s = {};
      if (s.noc = a3.readShort(n2, o2), o2 += 2, s.xMin = a3.readShort(n2, o2), o2 += 2, s.yMin = a3.readShort(n2, o2), o2 += 2, s.xMax = a3.readShort(n2, o2), o2 += 2, s.yMax = a3.readShort(n2, o2), o2 += 2, s.xMin >= s.xMax || s.yMin >= s.yMax)
        return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i4 = 0; i4 < s.noc; i4++)
          s.endPts.push(a3.readUshort(n2, o2)), o2 += 2;
        var h = a3.readUshort(n2, o2);
        if (o2 += 2, n2.length - o2 < h)
          return null;
        s.instructions = a3.readBytes(n2, o2, h), o2 += h;
        var f = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i4 = 0; i4 < f; i4++) {
          var d2 = n2[o2];
          if (o2++, s.flags.push(d2), (8 & d2) != 0) {
            var l2 = n2[o2];
            o2++;
            for (var u = 0; u < l2; u++)
              s.flags.push(d2), i4++;
          }
        }
        s.xs = [];
        for (i4 = 0; i4 < f; i4++) {
          var v4 = (2 & s.flags[i4]) != 0, c6 = (16 & s.flags[i4]) != 0;
          v4 ? (s.xs.push(c6 ? n2[o2] : -n2[o2]), o2++) : c6 ? s.xs.push(0) : (s.xs.push(a3.readShort(n2, o2)), o2 += 2);
        }
        s.ys = [];
        for (i4 = 0; i4 < f; i4++) {
          v4 = (4 & s.flags[i4]) != 0, c6 = (32 & s.flags[i4]) != 0;
          v4 ? (s.ys.push(c6 ? n2[o2] : -n2[o2]), o2++) : c6 ? s.ys.push(0) : (s.ys.push(a3.readShort(n2, o2)), o2 += 2);
        }
        var p = 0, U = 0;
        for (i4 = 0; i4 < f; i4++)
          p += s.xs[i4], U += s.ys[i4], s.xs[i4] = p, s.ys[i4] = U;
      } else {
        var g;
        s.parts = [];
        do {
          g = a3.readUshort(n2, o2), o2 += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a3.readUshort(n2, o2), o2 += 2, 1 & g) {
            var m = a3.readShort(n2, o2);
            o2 += 2;
            var b = a3.readShort(n2, o2);
            o2 += 2;
          } else {
            m = a3.readInt8(n2, o2);
            o2++;
            b = a3.readInt8(n2, o2);
            o2++;
          }
          2 & g ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g ? (S.m.a = S.m.d = a3.readF2dot14(n2, o2), o2 += 2) : 64 & g ? (S.m.a = a3.readF2dot14(n2, o2), o2 += 2, S.m.d = a3.readF2dot14(n2, o2), o2 += 2) : 128 & g && (S.m.a = a3.readF2dot14(n2, o2), o2 += 2, S.m.b = a3.readF2dot14(n2, o2), o2 += 2, S.m.c = a3.readF2dot14(n2, o2), o2 += 2, S.m.d = a3.readF2dot14(n2, o2), o2 += 2);
        } while (32 & g);
        if (256 & g) {
          var y = a3.readUshort(n2, o2);
          o2 += 2, s.instr = [];
          for (i4 = 0; i4 < y; i4++)
            s.instr.push(n2[o2]), o2++;
        }
      }
      return s;
    }, e2.GPOS = {}, e2.GPOS.parse = function(r3, t3, a3, n2) {
      return e2._lctf.parse(r3, t3, a3, n2, e2.GPOS.subt);
    }, e2.GPOS.subt = function(r3, t3, a3, n2) {
      var o2 = e2._bin, s = a3, i4 = {};
      if (i4.fmt = o2.readUshort(r3, a3), a3 += 2, t3 == 1 || t3 == 2 || t3 == 3 || t3 == 7 || t3 == 8 && i4.fmt <= 2) {
        var h = o2.readUshort(r3, a3);
        a3 += 2, i4.coverage = e2._lctf.readCoverage(r3, h + s);
      }
      if (t3 == 1 && i4.fmt == 1) {
        var f = o2.readUshort(r3, a3);
        a3 += 2;
        var d2 = e2._lctf.numOfOnes(f);
        f != 0 && (i4.pos = e2.GPOS.readValueRecord(r3, a3, f));
      } else if (t3 == 2 && i4.fmt >= 1 && i4.fmt <= 2) {
        f = o2.readUshort(r3, a3);
        a3 += 2;
        var l2 = o2.readUshort(r3, a3);
        a3 += 2;
        d2 = e2._lctf.numOfOnes(f);
        var u = e2._lctf.numOfOnes(l2);
        if (i4.fmt == 1) {
          i4.pairsets = [];
          var v4 = o2.readUshort(r3, a3);
          a3 += 2;
          for (var c6 = 0; c6 < v4; c6++) {
            var p = s + o2.readUshort(r3, a3);
            a3 += 2;
            var U = o2.readUshort(r3, p);
            p += 2;
            for (var g = [], S = 0; S < U; S++) {
              var m = o2.readUshort(r3, p);
              p += 2, f != 0 && (x = e2.GPOS.readValueRecord(r3, p, f), p += 2 * d2), l2 != 0 && (P = e2.GPOS.readValueRecord(r3, p, l2), p += 2 * u), g.push({ gid2: m, val1: x, val2: P });
            }
            i4.pairsets.push(g);
          }
        }
        if (i4.fmt == 2) {
          var b = o2.readUshort(r3, a3);
          a3 += 2;
          var y = o2.readUshort(r3, a3);
          a3 += 2;
          var F = o2.readUshort(r3, a3);
          a3 += 2;
          var _ = o2.readUshort(r3, a3);
          a3 += 2, i4.classDef1 = e2._lctf.readClassDef(r3, s + b), i4.classDef2 = e2._lctf.readClassDef(r3, s + y), i4.matrix = [];
          for (c6 = 0; c6 < F; c6++) {
            var C = [];
            for (S = 0; S < _; S++) {
              var x = null, P = null;
              f != 0 && (x = e2.GPOS.readValueRecord(r3, a3, f), a3 += 2 * d2), l2 != 0 && (P = e2.GPOS.readValueRecord(r3, a3, l2), a3 += 2 * u), C.push({ val1: x, val2: P });
            }
            i4.matrix.push(C);
          }
        }
      } else {
        if (t3 == 9 && i4.fmt == 1) {
          var I = o2.readUshort(r3, a3);
          a3 += 2;
          var w = o2.readUint(r3, a3);
          if (a3 += 4, n2.ltype == 9)
            n2.ltype = I;
          else if (n2.ltype != I)
            throw "invalid extension substitution";
          return e2.GPOS.subt(r3, n2.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i4.fmt);
      }
      return i4;
    }, e2.GPOS.readValueRecord = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = [];
      return o2.push(1 & a3 ? n2.readShort(r3, t3) : 0), t3 += 1 & a3 ? 2 : 0, o2.push(2 & a3 ? n2.readShort(r3, t3) : 0), t3 += 2 & a3 ? 2 : 0, o2.push(4 & a3 ? n2.readShort(r3, t3) : 0), t3 += 4 & a3 ? 2 : 0, o2.push(8 & a3 ? n2.readShort(r3, t3) : 0), t3 += 8 & a3 ? 2 : 0, o2;
    }, e2.GSUB = {}, e2.GSUB.parse = function(r3, t3, a3, n2) {
      return e2._lctf.parse(r3, t3, a3, n2, e2.GSUB.subt);
    }, e2.GSUB.subt = function(r3, t3, a3, n2) {
      var o2 = e2._bin, s = a3, i4 = {};
      if (i4.fmt = o2.readUshort(r3, a3), a3 += 2, t3 != 1 && t3 != 4 && t3 != 5 && t3 != 6)
        return null;
      if (t3 == 1 || t3 == 4 || t3 == 5 && i4.fmt <= 2 || t3 == 6 && i4.fmt <= 2) {
        var h = o2.readUshort(r3, a3);
        a3 += 2, i4.coverage = e2._lctf.readCoverage(r3, s + h);
      }
      if (t3 == 1 && i4.fmt >= 1 && i4.fmt <= 2) {
        if (i4.fmt == 1)
          i4.delta = o2.readShort(r3, a3), a3 += 2;
        else if (i4.fmt == 2) {
          var f = o2.readUshort(r3, a3);
          a3 += 2, i4.newg = o2.readUshorts(r3, a3, f), a3 += 2 * i4.newg.length;
        }
      } else if (t3 == 4) {
        i4.vals = [];
        f = o2.readUshort(r3, a3);
        a3 += 2;
        for (var d2 = 0; d2 < f; d2++) {
          var l2 = o2.readUshort(r3, a3);
          a3 += 2, i4.vals.push(e2.GSUB.readLigatureSet(r3, s + l2));
        }
      } else if (t3 == 5 && i4.fmt == 2) {
        if (i4.fmt == 2) {
          var u = o2.readUshort(r3, a3);
          a3 += 2, i4.cDef = e2._lctf.readClassDef(r3, s + u), i4.scset = [];
          var v4 = o2.readUshort(r3, a3);
          a3 += 2;
          for (d2 = 0; d2 < v4; d2++) {
            var c6 = o2.readUshort(r3, a3);
            a3 += 2, i4.scset.push(c6 == 0 ? null : e2.GSUB.readSubClassSet(r3, s + c6));
          }
        }
      } else if (t3 == 6 && i4.fmt == 3) {
        if (i4.fmt == 3) {
          for (d2 = 0; d2 < 3; d2++) {
            f = o2.readUshort(r3, a3);
            a3 += 2;
            for (var p = [], U = 0; U < f; U++)
              p.push(e2._lctf.readCoverage(r3, s + o2.readUshort(r3, a3 + 2 * U)));
            a3 += 2 * f, d2 == 0 && (i4.backCvg = p), d2 == 1 && (i4.inptCvg = p), d2 == 2 && (i4.ahedCvg = p);
          }
          f = o2.readUshort(r3, a3);
          a3 += 2, i4.lookupRec = e2.GSUB.readSubstLookupRecords(r3, a3, f);
        }
      } else {
        if (t3 == 7 && i4.fmt == 1) {
          var g = o2.readUshort(r3, a3);
          a3 += 2;
          var S = o2.readUint(r3, a3);
          if (a3 += 4, n2.ltype == 9)
            n2.ltype = g;
          else if (n2.ltype != g)
            throw "invalid extension substitution";
          return e2.GSUB.subt(r3, n2.ltype, s + S);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i4.fmt);
      }
      return i4;
    }, e2.GSUB.readSubClassSet = function(r3, t3) {
      var a3 = e2._bin.readUshort, n2 = t3, o2 = [], s = a3(r3, t3);
      t3 += 2;
      for (var i4 = 0; i4 < s; i4++) {
        var h = a3(r3, t3);
        t3 += 2, o2.push(e2.GSUB.readSubClassRule(r3, n2 + h));
      }
      return o2;
    }, e2.GSUB.readSubClassRule = function(r3, t3) {
      var a3 = e2._bin.readUshort, n2 = {}, o2 = a3(r3, t3), s = a3(r3, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i4 = 0; i4 < o2 - 1; i4++)
        n2.input.push(a3(r3, t3)), t3 += 2;
      return n2.substLookupRecords = e2.GSUB.readSubstLookupRecords(r3, t3, s), n2;
    }, e2.GSUB.readSubstLookupRecords = function(r3, t3, a3) {
      for (var n2 = e2._bin.readUshort, o2 = [], s = 0; s < a3; s++)
        o2.push(n2(r3, t3), n2(r3, t3 + 2)), t3 += 4;
      return o2;
    }, e2.GSUB.readChainSubClassSet = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = [], s = a3.readUshort(r3, t3);
      t3 += 2;
      for (var i4 = 0; i4 < s; i4++) {
        var h = a3.readUshort(r3, t3);
        t3 += 2, o2.push(e2.GSUB.readChainSubClassRule(r3, n2 + h));
      }
      return o2;
    }, e2.GSUB.readChainSubClassRule = function(r3, t3) {
      for (var a3 = e2._bin, n2 = {}, o2 = ["backtrack", "input", "lookahead"], s = 0; s < o2.length; s++) {
        var i4 = a3.readUshort(r3, t3);
        t3 += 2, s == 1 && i4--, n2[o2[s]] = a3.readUshorts(r3, t3, i4), t3 += 2 * n2[o2[s]].length;
      }
      i4 = a3.readUshort(r3, t3);
      return t3 += 2, n2.subst = a3.readUshorts(r3, t3, 2 * i4), t3 += 2 * n2.subst.length, n2;
    }, e2.GSUB.readLigatureSet = function(r3, t3) {
      var a3 = e2._bin, n2 = t3, o2 = [], s = a3.readUshort(r3, t3);
      t3 += 2;
      for (var i4 = 0; i4 < s; i4++) {
        var h = a3.readUshort(r3, t3);
        t3 += 2, o2.push(e2.GSUB.readLigature(r3, n2 + h));
      }
      return o2;
    }, e2.GSUB.readLigature = function(r3, t3) {
      var a3 = e2._bin, n2 = { chain: [] };
      n2.nglyph = a3.readUshort(r3, t3), t3 += 2;
      var o2 = a3.readUshort(r3, t3);
      t3 += 2;
      for (var s = 0; s < o2 - 1; s++)
        n2.chain.push(a3.readUshort(r3, t3)), t3 += 2;
      return n2;
    }, e2.head = {}, e2.head.parse = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = {};
      return n2.readFixed(r3, t3), t3 += 4, o2.fontRevision = n2.readFixed(r3, t3), t3 += 4, n2.readUint(r3, t3), t3 += 4, n2.readUint(r3, t3), t3 += 4, o2.flags = n2.readUshort(r3, t3), t3 += 2, o2.unitsPerEm = n2.readUshort(r3, t3), t3 += 2, o2.created = n2.readUint64(r3, t3), t3 += 8, o2.modified = n2.readUint64(r3, t3), t3 += 8, o2.xMin = n2.readShort(r3, t3), t3 += 2, o2.yMin = n2.readShort(r3, t3), t3 += 2, o2.xMax = n2.readShort(r3, t3), t3 += 2, o2.yMax = n2.readShort(r3, t3), t3 += 2, o2.macStyle = n2.readUshort(r3, t3), t3 += 2, o2.lowestRecPPEM = n2.readUshort(r3, t3), t3 += 2, o2.fontDirectionHint = n2.readShort(r3, t3), t3 += 2, o2.indexToLocFormat = n2.readShort(r3, t3), t3 += 2, o2.glyphDataFormat = n2.readShort(r3, t3), t3 += 2, o2;
    }, e2.hhea = {}, e2.hhea.parse = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = {};
      return n2.readFixed(r3, t3), t3 += 4, o2.ascender = n2.readShort(r3, t3), t3 += 2, o2.descender = n2.readShort(r3, t3), t3 += 2, o2.lineGap = n2.readShort(r3, t3), t3 += 2, o2.advanceWidthMax = n2.readUshort(r3, t3), t3 += 2, o2.minLeftSideBearing = n2.readShort(r3, t3), t3 += 2, o2.minRightSideBearing = n2.readShort(r3, t3), t3 += 2, o2.xMaxExtent = n2.readShort(r3, t3), t3 += 2, o2.caretSlopeRise = n2.readShort(r3, t3), t3 += 2, o2.caretSlopeRun = n2.readShort(r3, t3), t3 += 2, o2.caretOffset = n2.readShort(r3, t3), t3 += 2, t3 += 8, o2.metricDataFormat = n2.readShort(r3, t3), t3 += 2, o2.numberOfHMetrics = n2.readUshort(r3, t3), t3 += 2, o2;
    }, e2.hmtx = {}, e2.hmtx.parse = function(r3, t3, a3, n2) {
      for (var o2 = e2._bin, s = { aWidth: [], lsBearing: [] }, i4 = 0, h = 0, f = 0; f < n2.maxp.numGlyphs; f++)
        f < n2.hhea.numberOfHMetrics && (i4 = o2.readUshort(r3, t3), t3 += 2, h = o2.readShort(r3, t3), t3 += 2), s.aWidth.push(i4), s.lsBearing.push(h);
      return s;
    }, e2.kern = {}, e2.kern.parse = function(r3, t3, a3, n2) {
      var o2 = e2._bin, s = o2.readUshort(r3, t3);
      if (t3 += 2, s == 1)
        return e2.kern.parseV1(r3, t3 - 2, a3, n2);
      var i4 = o2.readUshort(r3, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, f = 0; f < i4; f++) {
        t3 += 2;
        a3 = o2.readUshort(r3, t3);
        t3 += 2;
        var d2 = o2.readUshort(r3, t3);
        t3 += 2;
        var l2 = d2 >>> 8;
        if ((l2 &= 15) != 0)
          throw "unknown kern table format: " + l2;
        t3 = e2.kern.readFormat0(r3, t3, h);
      }
      return h;
    }, e2.kern.parseV1 = function(r3, t3, a3, n2) {
      var o2 = e2._bin;
      o2.readFixed(r3, t3), t3 += 4;
      var s = o2.readUint(r3, t3);
      t3 += 4;
      for (var i4 = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o2.readUint(r3, t3), t3 += 4;
        var f = o2.readUshort(r3, t3);
        t3 += 2, o2.readUshort(r3, t3), t3 += 2;
        var d2 = f >>> 8;
        if ((d2 &= 15) != 0)
          throw "unknown kern table format: " + d2;
        t3 = e2.kern.readFormat0(r3, t3, i4);
      }
      return i4;
    }, e2.kern.readFormat0 = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = -1, s = n2.readUshort(r3, t3);
      t3 += 2, n2.readUshort(r3, t3), t3 += 2, n2.readUshort(r3, t3), t3 += 2, n2.readUshort(r3, t3), t3 += 2;
      for (var i4 = 0; i4 < s; i4++) {
        var h = n2.readUshort(r3, t3);
        t3 += 2;
        var f = n2.readUshort(r3, t3);
        t3 += 2;
        var d2 = n2.readShort(r3, t3);
        t3 += 2, h != o2 && (a3.glyph1.push(h), a3.rval.push({ glyph2: [], vals: [] }));
        var l2 = a3.rval[a3.rval.length - 1];
        l2.glyph2.push(f), l2.vals.push(d2), o2 = h;
      }
      return t3;
    }, e2.loca = {}, e2.loca.parse = function(r3, t3, a3, n2) {
      var o2 = e2._bin, s = [], i4 = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (i4 == 0)
        for (var f = 0; f < h; f++)
          s.push(o2.readUshort(r3, t3 + (f << 1)) << 1);
      if (i4 == 1)
        for (f = 0; f < h; f++)
          s.push(o2.readUint(r3, t3 + (f << 2)));
      return s;
    }, e2.maxp = {}, e2.maxp.parse = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = {}, s = n2.readUint(r3, t3);
      return t3 += 4, o2.numGlyphs = n2.readUshort(r3, t3), t3 += 2, s == 65536 && (o2.maxPoints = n2.readUshort(r3, t3), t3 += 2, o2.maxContours = n2.readUshort(r3, t3), t3 += 2, o2.maxCompositePoints = n2.readUshort(r3, t3), t3 += 2, o2.maxCompositeContours = n2.readUshort(r3, t3), t3 += 2, o2.maxZones = n2.readUshort(r3, t3), t3 += 2, o2.maxTwilightPoints = n2.readUshort(r3, t3), t3 += 2, o2.maxStorage = n2.readUshort(r3, t3), t3 += 2, o2.maxFunctionDefs = n2.readUshort(r3, t3), t3 += 2, o2.maxInstructionDefs = n2.readUshort(r3, t3), t3 += 2, o2.maxStackElements = n2.readUshort(r3, t3), t3 += 2, o2.maxSizeOfInstructions = n2.readUshort(r3, t3), t3 += 2, o2.maxComponentElements = n2.readUshort(r3, t3), t3 += 2, o2.maxComponentDepth = n2.readUshort(r3, t3), t3 += 2), o2;
    }, e2.name = {}, e2.name.parse = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = {};
      n2.readUshort(r3, t3), t3 += 2;
      var s = n2.readUshort(r3, t3);
      t3 += 2, n2.readUshort(r3, t3);
      for (var i4, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], f = t3 += 2, d2 = 0; d2 < s; d2++) {
        var l2 = n2.readUshort(r3, t3);
        t3 += 2;
        var u = n2.readUshort(r3, t3);
        t3 += 2;
        var v4 = n2.readUshort(r3, t3);
        t3 += 2;
        var c6 = n2.readUshort(r3, t3);
        t3 += 2;
        var p = n2.readUshort(r3, t3);
        t3 += 2;
        var U = n2.readUshort(r3, t3);
        t3 += 2;
        var g, S = h[c6], m = f + 12 * s + U;
        if (l2 == 0)
          g = n2.readUnicode(r3, m, p / 2);
        else if (l2 == 3 && u == 0)
          g = n2.readUnicode(r3, m, p / 2);
        else if (u == 0)
          g = n2.readASCII(r3, m, p);
        else if (u == 1)
          g = n2.readUnicode(r3, m, p / 2);
        else if (u == 3)
          g = n2.readUnicode(r3, m, p / 2);
        else {
          if (l2 != 1)
            throw "unknown encoding " + u + ", platformID: " + l2;
          g = n2.readASCII(r3, m, p), console.debug("reading unknown MAC encoding " + u + " as ASCII");
        }
        var b = "p" + l2 + "," + v4.toString(16);
        o2[b] == null && (o2[b] = {}), o2[b][S !== void 0 ? S : c6] = g, o2[b]._lang = v4;
      }
      for (var y in o2)
        if (o2[y].postScriptName != null && o2[y]._lang == 1033)
          return o2[y];
      for (var y in o2)
        if (o2[y].postScriptName != null && o2[y]._lang == 0)
          return o2[y];
      for (var y in o2)
        if (o2[y].postScriptName != null && o2[y]._lang == 3084)
          return o2[y];
      for (var y in o2)
        if (o2[y].postScriptName != null)
          return o2[y];
      for (var y in o2) {
        i4 = y;
        break;
      }
      return console.debug("returning name table with languageID " + o2[i4]._lang), o2[i4];
    }, e2["OS/2"] = {}, e2["OS/2"].parse = function(r3, t3, a3) {
      var n2 = e2._bin.readUshort(r3, t3);
      t3 += 2;
      var o2 = {};
      if (n2 == 0)
        e2["OS/2"].version0(r3, t3, o2);
      else if (n2 == 1)
        e2["OS/2"].version1(r3, t3, o2);
      else if (n2 == 2 || n2 == 3 || n2 == 4)
        e2["OS/2"].version2(r3, t3, o2);
      else {
        if (n2 != 5)
          throw "unknown OS/2 table version: " + n2;
        e2["OS/2"].version5(r3, t3, o2);
      }
      return o2;
    }, e2["OS/2"].version0 = function(r3, t3, a3) {
      var n2 = e2._bin;
      return a3.xAvgCharWidth = n2.readShort(r3, t3), t3 += 2, a3.usWeightClass = n2.readUshort(r3, t3), t3 += 2, a3.usWidthClass = n2.readUshort(r3, t3), t3 += 2, a3.fsType = n2.readUshort(r3, t3), t3 += 2, a3.ySubscriptXSize = n2.readShort(r3, t3), t3 += 2, a3.ySubscriptYSize = n2.readShort(r3, t3), t3 += 2, a3.ySubscriptXOffset = n2.readShort(r3, t3), t3 += 2, a3.ySubscriptYOffset = n2.readShort(r3, t3), t3 += 2, a3.ySuperscriptXSize = n2.readShort(r3, t3), t3 += 2, a3.ySuperscriptYSize = n2.readShort(r3, t3), t3 += 2, a3.ySuperscriptXOffset = n2.readShort(r3, t3), t3 += 2, a3.ySuperscriptYOffset = n2.readShort(r3, t3), t3 += 2, a3.yStrikeoutSize = n2.readShort(r3, t3), t3 += 2, a3.yStrikeoutPosition = n2.readShort(r3, t3), t3 += 2, a3.sFamilyClass = n2.readShort(r3, t3), t3 += 2, a3.panose = n2.readBytes(r3, t3, 10), t3 += 10, a3.ulUnicodeRange1 = n2.readUint(r3, t3), t3 += 4, a3.ulUnicodeRange2 = n2.readUint(r3, t3), t3 += 4, a3.ulUnicodeRange3 = n2.readUint(r3, t3), t3 += 4, a3.ulUnicodeRange4 = n2.readUint(r3, t3), t3 += 4, a3.achVendID = [n2.readInt8(r3, t3), n2.readInt8(r3, t3 + 1), n2.readInt8(r3, t3 + 2), n2.readInt8(r3, t3 + 3)], t3 += 4, a3.fsSelection = n2.readUshort(r3, t3), t3 += 2, a3.usFirstCharIndex = n2.readUshort(r3, t3), t3 += 2, a3.usLastCharIndex = n2.readUshort(r3, t3), t3 += 2, a3.sTypoAscender = n2.readShort(r3, t3), t3 += 2, a3.sTypoDescender = n2.readShort(r3, t3), t3 += 2, a3.sTypoLineGap = n2.readShort(r3, t3), t3 += 2, a3.usWinAscent = n2.readUshort(r3, t3), t3 += 2, a3.usWinDescent = n2.readUshort(r3, t3), t3 += 2;
    }, e2["OS/2"].version1 = function(r3, t3, a3) {
      var n2 = e2._bin;
      return t3 = e2["OS/2"].version0(r3, t3, a3), a3.ulCodePageRange1 = n2.readUint(r3, t3), t3 += 4, a3.ulCodePageRange2 = n2.readUint(r3, t3), t3 += 4;
    }, e2["OS/2"].version2 = function(r3, t3, a3) {
      var n2 = e2._bin;
      return t3 = e2["OS/2"].version1(r3, t3, a3), a3.sxHeight = n2.readShort(r3, t3), t3 += 2, a3.sCapHeight = n2.readShort(r3, t3), t3 += 2, a3.usDefault = n2.readUshort(r3, t3), t3 += 2, a3.usBreak = n2.readUshort(r3, t3), t3 += 2, a3.usMaxContext = n2.readUshort(r3, t3), t3 += 2;
    }, e2["OS/2"].version5 = function(r3, t3, a3) {
      var n2 = e2._bin;
      return t3 = e2["OS/2"].version2(r3, t3, a3), a3.usLowerOpticalPointSize = n2.readUshort(r3, t3), t3 += 2, a3.usUpperOpticalPointSize = n2.readUshort(r3, t3), t3 += 2;
    }, e2.post = {}, e2.post.parse = function(r3, t3, a3) {
      var n2 = e2._bin, o2 = {};
      return o2.version = n2.readFixed(r3, t3), t3 += 4, o2.italicAngle = n2.readFixed(r3, t3), t3 += 4, o2.underlinePosition = n2.readShort(r3, t3), t3 += 2, o2.underlineThickness = n2.readShort(r3, t3), t3 += 2, o2;
    }, e2 == null && (e2 = {}), e2.U == null && (e2.U = {}), e2.U.codeToGlyph = function(r3, e3) {
      var t3 = r3.cmap, a3 = -1;
      if (t3.p0e4 != null ? a3 = t3.p0e4 : t3.p3e1 != null ? a3 = t3.p3e1 : t3.p1e0 != null ? a3 = t3.p1e0 : t3.p0e3 != null && (a3 = t3.p0e3), a3 == -1)
        throw "no familiar platform and encoding!";
      var n2 = t3.tables[a3];
      if (n2.format == 0)
        return e3 >= n2.map.length ? 0 : n2.map[e3];
      if (n2.format == 4) {
        for (var o2 = -1, s = 0; s < n2.endCount.length; s++)
          if (e3 <= n2.endCount[s]) {
            o2 = s;
            break;
          }
        if (o2 == -1)
          return 0;
        if (n2.startCount[o2] > e3)
          return 0;
        return 65535 & (n2.idRangeOffset[o2] != 0 ? n2.glyphIdArray[e3 - n2.startCount[o2] + (n2.idRangeOffset[o2] >> 1) - (n2.idRangeOffset.length - o2)] : e3 + n2.idDelta[o2]);
      }
      if (n2.format == 12) {
        if (e3 > n2.groups[n2.groups.length - 1][1])
          return 0;
        for (s = 0; s < n2.groups.length; s++) {
          var i4 = n2.groups[s];
          if (i4[0] <= e3 && e3 <= i4[1])
            return i4[2] + (e3 - i4[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e2.U.glyphToPath = function(r3, t3) {
      var a3 = { cmds: [], crds: [] };
      if (r3.SVG && r3.SVG.entries[t3]) {
        var n2 = r3.SVG.entries[t3];
        return n2 == null ? a3 : (typeof n2 == "string" && (n2 = e2.SVG.toPath(n2), r3.SVG.entries[t3] = n2), n2);
      }
      if (r3.CFF) {
        var o2 = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r3.CFF.Private ? r3.CFF.Private.defaultWidthX : 0, open: false }, s = r3.CFF, i4 = r3.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; )
            h += 2;
          i4 = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e2.U._drawCFF(r3.CFF.CharStrings[t3], o2, s, i4, a3);
      } else
        r3.glyf && e2.U._drawGlyf(t3, r3, a3);
      return a3;
    }, e2.U._drawGlyf = function(r3, t3, a3) {
      var n2 = t3.glyf[r3];
      n2 == null && (n2 = t3.glyf[r3] = e2.glyf._parseGlyf(t3, r3)), n2 != null && (n2.noc > -1 ? e2.U._simpleGlyph(n2, a3) : e2.U._compoGlyph(n2, t3, a3));
    }, e2.U._simpleGlyph = function(r3, t3) {
      for (var a3 = 0; a3 < r3.noc; a3++) {
        for (var n2 = a3 == 0 ? 0 : r3.endPts[a3 - 1] + 1, o2 = r3.endPts[a3], s = n2; s <= o2; s++) {
          var i4 = s == n2 ? o2 : s - 1, h = s == o2 ? n2 : s + 1, f = 1 & r3.flags[s], d2 = 1 & r3.flags[i4], l2 = 1 & r3.flags[h], u = r3.xs[s], v4 = r3.ys[s];
          if (s == n2)
            if (f) {
              if (!d2) {
                e2.U.P.moveTo(t3, u, v4);
                continue;
              }
              e2.U.P.moveTo(t3, r3.xs[i4], r3.ys[i4]);
            } else
              d2 ? e2.U.P.moveTo(t3, r3.xs[i4], r3.ys[i4]) : e2.U.P.moveTo(t3, (r3.xs[i4] + u) / 2, (r3.ys[i4] + v4) / 2);
          f ? d2 && e2.U.P.lineTo(t3, u, v4) : l2 ? e2.U.P.qcurveTo(t3, u, v4, r3.xs[h], r3.ys[h]) : e2.U.P.qcurveTo(t3, u, v4, (u + r3.xs[h]) / 2, (v4 + r3.ys[h]) / 2);
        }
        e2.U.P.closePath(t3);
      }
    }, e2.U._compoGlyph = function(r3, t3, a3) {
      for (var n2 = 0; n2 < r3.parts.length; n2++) {
        var o2 = { cmds: [], crds: [] }, s = r3.parts[n2];
        e2.U._drawGlyf(s.glyphIndex, t3, o2);
        for (var i4 = s.m, h = 0; h < o2.crds.length; h += 2) {
          var f = o2.crds[h], d2 = o2.crds[h + 1];
          a3.crds.push(f * i4.a + d2 * i4.b + i4.tx), a3.crds.push(f * i4.c + d2 * i4.d + i4.ty);
        }
        for (h = 0; h < o2.cmds.length; h++)
          a3.cmds.push(o2.cmds[h]);
      }
    }, e2.U._getGlyphClass = function(r3, t3) {
      var a3 = e2._lctf.getInterval(t3, r3);
      return a3 == -1 ? 0 : t3[a3 + 2];
    }, e2.U.getPairAdjustment = function(r3, t3, a3) {
      var n2 = 0;
      if (r3.GPOS)
        for (var o2 = r3.GPOS, s = o2.lookupList, i4 = o2.featureList, h = [], f = 0; f < i4.length; f++) {
          var d2 = i4[f];
          if (d2.tag == "kern") {
            for (var l2 = 0; l2 < d2.tab.length; l2++)
              if (!h[d2.tab[l2]]) {
                h[d2.tab[l2]] = true;
                for (var u = s[d2.tab[l2]], v4 = 0; v4 < u.tabs.length; v4++)
                  if (u.tabs[v4] != null) {
                    var c6, p = u.tabs[v4];
                    if (!p.coverage || (c6 = e2._lctf.coverageIndex(p.coverage, t3)) != -1) {
                      if (u.ltype == 1)
                        ;
                      else if (u.ltype == 2) {
                        var U;
                        if (p.fmt == 1) {
                          var g = p.pairsets[c6];
                          for (f = 0; f < g.length; f++)
                            g[f].gid2 == a3 && (U = g[f]);
                        } else if (p.fmt == 2) {
                          var S = e2.U._getGlyphClass(t3, p.classDef1), m = e2.U._getGlyphClass(a3, p.classDef2);
                          U = p.matrix[S][m];
                        }
                        U && U.val1 && U.val1[2] && (n2 += U.val1[2]), U && U.val2 && U.val2[0] && (n2 += U.val2[0]);
                      }
                    }
                  }
              }
          }
        }
      if (r3.kern) {
        var b = r3.kern.glyph1.indexOf(t3);
        if (b != -1) {
          var y = r3.kern.rval[b].glyph2.indexOf(a3);
          y != -1 && (n2 += r3.kern.rval[b].vals[y]);
        }
      }
      return n2;
    }, e2.U._applySubs = function(r3, t3, a3, n2) {
      for (var o2 = r3.length - t3 - 1, s = 0; s < a3.tabs.length; s++)
        if (a3.tabs[s] != null) {
          var i4, h = a3.tabs[s];
          if (!h.coverage || (i4 = e2._lctf.coverageIndex(h.coverage, r3[t3])) != -1) {
            if (a3.ltype == 1)
              r3[t3], h.fmt == 1 ? r3[t3] = r3[t3] + h.delta : r3[t3] = h.newg[i4];
            else if (a3.ltype == 4)
              for (var f = h.vals[i4], d2 = 0; d2 < f.length; d2++) {
                var l2 = f[d2], u = l2.chain.length;
                if (!(u > o2)) {
                  for (var v4 = true, c6 = 0, p = 0; p < u; p++) {
                    for (; r3[t3 + c6 + (1 + p)] == -1; )
                      c6++;
                    l2.chain[p] != r3[t3 + c6 + (1 + p)] && (v4 = false);
                  }
                  if (v4) {
                    r3[t3] = l2.nglyph;
                    for (p = 0; p < u + c6; p++)
                      r3[t3 + p + 1] = -1;
                    break;
                  }
                }
              }
            else if (a3.ltype == 5 && h.fmt == 2)
              for (var U = e2._lctf.getInterval(h.cDef, r3[t3]), g = h.cDef[U + 2], S = h.scset[g], m = 0; m < S.length; m++) {
                var b = S[m], y = b.input;
                if (!(y.length > o2)) {
                  for (v4 = true, p = 0; p < y.length; p++) {
                    var F = e2._lctf.getInterval(h.cDef, r3[t3 + 1 + p]);
                    if (U == -1 && h.cDef[F + 2] != y[p]) {
                      v4 = false;
                      break;
                    }
                  }
                  if (v4) {
                    var _ = b.substLookupRecords;
                    for (d2 = 0; d2 < _.length; d2 += 2)
                      _[d2], _[d2 + 1];
                  }
                }
              }
            else if (a3.ltype == 6 && h.fmt == 3) {
              if (!e2.U._glsCovered(r3, h.backCvg, t3 - h.backCvg.length))
                continue;
              if (!e2.U._glsCovered(r3, h.inptCvg, t3))
                continue;
              if (!e2.U._glsCovered(r3, h.ahedCvg, t3 + h.inptCvg.length))
                continue;
              var C = h.lookupRec;
              for (m = 0; m < C.length; m += 2) {
                U = C[m];
                var x = n2[C[m + 1]];
                e2.U._applySubs(r3, t3 + U, x, n2);
              }
            }
          }
        }
    }, e2.U._glsCovered = function(r3, t3, a3) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (e2._lctf.coverageIndex(t3[n2], r3[a3 + n2]) == -1)
          return false;
      }
      return true;
    }, e2.U.glyphsToPath = function(r3, t3, a3) {
      for (var n2 = { cmds: [], crds: [] }, o2 = 0, s = 0; s < t3.length; s++) {
        var i4 = t3[s];
        if (i4 != -1) {
          for (var h = s < t3.length - 1 && t3[s + 1] != -1 ? t3[s + 1] : 0, f = e2.U.glyphToPath(r3, i4), d2 = 0; d2 < f.crds.length; d2 += 2)
            n2.crds.push(f.crds[d2] + o2), n2.crds.push(f.crds[d2 + 1]);
          a3 && n2.cmds.push(a3);
          for (d2 = 0; d2 < f.cmds.length; d2++)
            n2.cmds.push(f.cmds[d2]);
          a3 && n2.cmds.push("X"), o2 += r3.hmtx.aWidth[i4], s < t3.length - 1 && (o2 += e2.U.getPairAdjustment(r3, i4, h));
        }
      }
      return n2;
    }, e2.U.P = {}, e2.U.P.moveTo = function(r3, e3, t3) {
      r3.cmds.push("M"), r3.crds.push(e3, t3);
    }, e2.U.P.lineTo = function(r3, e3, t3) {
      r3.cmds.push("L"), r3.crds.push(e3, t3);
    }, e2.U.P.curveTo = function(r3, e3, t3, a3, n2, o2, s) {
      r3.cmds.push("C"), r3.crds.push(e3, t3, a3, n2, o2, s);
    }, e2.U.P.qcurveTo = function(r3, e3, t3, a3, n2) {
      r3.cmds.push("Q"), r3.crds.push(e3, t3, a3, n2);
    }, e2.U.P.closePath = function(r3) {
      r3.cmds.push("Z");
    }, e2.U._drawCFF = function(r3, t3, a3, n2, o2) {
      for (var s = t3.stack, i4 = t3.nStems, h = t3.haveWidth, f = t3.width, d2 = t3.open, l2 = 0, u = t3.x, v4 = t3.y, c6 = 0, p = 0, U = 0, g = 0, S = 0, m = 0, b = 0, y = 0, F = 0, _ = 0, C = { val: 0, size: 0 }; l2 < r3.length; ) {
        e2.CFF.getCharString(r3, l2, C);
        var x = C.val;
        if (l2 += C.size, x == "o1" || x == "o18")
          s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i4 += s.length >> 1, s.length = 0, h = true;
        else if (x == "o3" || x == "o23") {
          s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i4 += s.length >> 1, s.length = 0, h = true;
        } else if (x == "o4")
          s.length > 1 && !h && (f = s.shift() + n2.nominalWidthX, h = true), d2 && e2.U.P.closePath(o2), v4 += s.pop(), e2.U.P.moveTo(o2, u, v4), d2 = true;
        else if (x == "o5")
          for (; s.length > 0; )
            u += s.shift(), v4 += s.shift(), e2.U.P.lineTo(o2, u, v4);
        else if (x == "o6" || x == "o7")
          for (var P = s.length, I = x == "o6", w = 0; w < P; w++) {
            var O = s.shift();
            I ? u += O : v4 += O, I = !I, e2.U.P.lineTo(o2, u, v4);
          }
        else if (x == "o8" || x == "o24") {
          P = s.length;
          for (var T = 0; T + 6 <= P; )
            c6 = u + s.shift(), p = v4 + s.shift(), U = c6 + s.shift(), g = p + s.shift(), u = U + s.shift(), v4 = g + s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, u, v4), T += 6;
          x == "o24" && (u += s.shift(), v4 += s.shift(), e2.U.P.lineTo(o2, u, v4));
        } else {
          if (x == "o11")
            break;
          if (x == "o1234" || x == "o1235" || x == "o1236" || x == "o1237")
            x == "o1234" && (p = v4, U = (c6 = u + s.shift()) + s.shift(), _ = g = p + s.shift(), m = g, y = v4, u = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, u, v4)), x == "o1235" && (c6 = u + s.shift(), p = v4 + s.shift(), U = c6 + s.shift(), g = p + s.shift(), F = U + s.shift(), _ = g + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), u = b + s.shift(), v4 = y + s.shift(), s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, u, v4)), x == "o1236" && (c6 = u + s.shift(), p = v4 + s.shift(), U = c6 + s.shift(), _ = g = p + s.shift(), m = g, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), u = b + s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, u, v4)), x == "o1237" && (c6 = u + s.shift(), p = v4 + s.shift(), U = c6 + s.shift(), g = p + s.shift(), F = U + s.shift(), _ = g + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - u) > Math.abs(y - v4) ? u = b + s.shift() : v4 = y + s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, F, _), e2.U.P.curveTo(o2, S, m, b, y, u, v4));
          else if (x == "o14") {
            if (s.length > 0 && !h && (f = s.shift() + a3.nominalWidthX, h = true), s.length == 4) {
              var k = s.shift(), G = s.shift(), D = s.shift(), B = s.shift(), L = e2.CFF.glyphBySE(a3, D), R = e2.CFF.glyphBySE(a3, B);
              e2.U._drawCFF(a3.CharStrings[L], t3, a3, n2, o2), t3.x = k, t3.y = G, e2.U._drawCFF(a3.CharStrings[R], t3, a3, n2, o2);
            }
            d2 && (e2.U.P.closePath(o2), d2 = false);
          } else if (x == "o19" || x == "o20") {
            s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i4 += s.length >> 1, s.length = 0, h = true, l2 += i4 + 7 >> 3;
          } else if (x == "o21")
            s.length > 2 && !h && (f = s.shift() + n2.nominalWidthX, h = true), v4 += s.pop(), u += s.pop(), d2 && e2.U.P.closePath(o2), e2.U.P.moveTo(o2, u, v4), d2 = true;
          else if (x == "o22")
            s.length > 1 && !h && (f = s.shift() + n2.nominalWidthX, h = true), u += s.pop(), d2 && e2.U.P.closePath(o2), e2.U.P.moveTo(o2, u, v4), d2 = true;
          else if (x == "o25") {
            for (; s.length > 6; )
              u += s.shift(), v4 += s.shift(), e2.U.P.lineTo(o2, u, v4);
            c6 = u + s.shift(), p = v4 + s.shift(), U = c6 + s.shift(), g = p + s.shift(), u = U + s.shift(), v4 = g + s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, u, v4);
          } else if (x == "o26")
            for (s.length % 2 && (u += s.shift()); s.length > 0; )
              c6 = u, p = v4 + s.shift(), u = U = c6 + s.shift(), v4 = (g = p + s.shift()) + s.shift(), e2.U.P.curveTo(o2, c6, p, U, g, u, v4);
          else if (x == "o27")
            for (s.length % 2 && (v4 += s.shift()); s.length > 0; )
              p = v4, U = (c6 = u + s.shift()) + s.shift(), g = p + s.shift(), u = U + s.shift(), v4 = g, e2.U.P.curveTo(o2, c6, p, U, g, u, v4);
          else if (x == "o10" || x == "o29") {
            var A = x == "o10" ? n2 : a3;
            if (s.length == 0)
              console.debug("error: empty stack");
            else {
              var W = s.pop(), M = A.Subrs[W + A.Bias];
              t3.x = u, t3.y = v4, t3.nStems = i4, t3.haveWidth = h, t3.width = f, t3.open = d2, e2.U._drawCFF(M, t3, a3, n2, o2), u = t3.x, v4 = t3.y, i4 = t3.nStems, h = t3.haveWidth, f = t3.width, d2 = t3.open;
            }
          } else if (x == "o30" || x == "o31") {
            var V2 = s.length, N = (T = 0, x == "o31");
            for (T += V2 - (P = -3 & V2); T < P; )
              N ? (p = v4, U = (c6 = u + s.shift()) + s.shift(), v4 = (g = p + s.shift()) + s.shift(), P - T == 5 ? (u = U + s.shift(), T++) : u = U, N = false) : (c6 = u, p = v4 + s.shift(), U = c6 + s.shift(), g = p + s.shift(), u = U + s.shift(), P - T == 5 ? (v4 = g + s.shift(), T++) : v4 = g, N = true), e2.U.P.curveTo(o2, c6, p, U, g, u, v4), T += 4;
          } else {
            if ((x + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + x, r3), x;
            s.push(x);
          }
        }
      }
      t3.x = u, t3.y = v4, t3.nStems = i4, t3.haveWidth = h, t3.width = f, t3.open = d2;
    };
    var t2 = e2, a2 = { Typr: t2 };
    return r2.Typr = t2, r2.default = a2, Object.defineProperty(r2, "__esModule", { value: true }), r2;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r2) {
    var e2 = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a2 = new e2([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i4 = new e2([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o2 = new e2([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r3, e3) {
      for (var a3 = new n2(31), i5 = 0; i5 < 31; ++i5)
        a3[i5] = e3 += 1 << r3[i5 - 1];
      var o3 = new t2(a3[30]);
      for (i5 = 1; i5 < 30; ++i5)
        for (var f2 = a3[i5]; f2 < a3[i5 + 1]; ++f2)
          o3[f2] = f2 - a3[i5] << 5 | i5;
      return [a3, o3];
    }, u = f(a2, 2), v4 = u[0], s = u[1];
    v4[28] = 258, s[258] = 28;
    for (var l2 = f(i4, 0)[0], c6 = new n2(32768), g = 0; g < 32768; ++g) {
      var h = (43690 & g) >>> 1 | (21845 & g) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c6[g] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r3, e3, t3) {
      for (var a3 = r3.length, i5 = 0, o3 = new n2(e3); i5 < a3; ++i5)
        ++o3[r3[i5] - 1];
      var f2, u2 = new n2(e3);
      for (i5 = 0; i5 < e3; ++i5)
        u2[i5] = u2[i5 - 1] + o3[i5 - 1] << 1;
      if (t3) {
        f2 = new n2(1 << e3);
        var v5 = 15 - e3;
        for (i5 = 0; i5 < a3; ++i5)
          if (r3[i5])
            for (var s2 = i5 << 4 | r3[i5], l3 = e3 - r3[i5], g2 = u2[r3[i5] - 1]++ << l3, h2 = g2 | (1 << l3) - 1; g2 <= h2; ++g2)
              f2[c6[g2] >>> v5] = s2;
      } else
        for (f2 = new n2(a3), i5 = 0; i5 < a3; ++i5)
          r3[i5] && (f2[i5] = c6[u2[r3[i5] - 1]++] >>> 15 - r3[i5]);
      return f2;
    }, d2 = new e2(288);
    for (g = 0; g < 144; ++g)
      d2[g] = 8;
    for (g = 144; g < 256; ++g)
      d2[g] = 9;
    for (g = 256; g < 280; ++g)
      d2[g] = 7;
    for (g = 280; g < 288; ++g)
      d2[g] = 8;
    var m = new e2(32);
    for (g = 0; g < 32; ++g)
      m[g] = 5;
    var b = w(d2, 9, 1), p = w(m, 5, 1), y = function(r3) {
      for (var e3 = r3[0], n3 = 1; n3 < r3.length; ++n3)
        r3[n3] > e3 && (e3 = r3[n3]);
      return e3;
    }, L = function(r3, e3, n3) {
      var t3 = e3 / 8 | 0;
      return (r3[t3] | r3[t3 + 1] << 8) >> (7 & e3) & n3;
    }, U = function(r3, e3) {
      var n3 = e3 / 8 | 0;
      return (r3[n3] | r3[n3 + 1] << 8 | r3[n3 + 2] << 16) >> (7 & e3);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(r3, e3, n3) {
      var t3 = new Error(e3 || k[r3]);
      if (t3.code = r3, Error.captureStackTrace && Error.captureStackTrace(t3, T), !n3)
        throw t3;
      return t3;
    }, O = function(r3, f2, u2) {
      var s2 = r3.length;
      if (!s2 || u2 && !u2.l && s2 < 5)
        return f2 || new e2(0);
      var c7 = !f2 || u2, g2 = !u2 || u2.i;
      u2 || (u2 = {}), f2 || (f2 = new e2(3 * s2));
      var h2, d3 = function(r4) {
        var n3 = f2.length;
        if (r4 > n3) {
          var t3 = new e2(Math.max(2 * n3, r4));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u2.f || 0, k2 = u2.p || 0, O2 = u2.b || 0, A2 = u2.l, x2 = u2.d, E = u2.m, D = u2.n, M = 8 * s2;
      do {
        if (!A2) {
          u2.f = m2 = L(r3, k2, 1);
          var S = L(r3, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V2 = r3[(I = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r3[I - 3] << 8, _ = I + V2;
            if (_ > s2) {
              g2 && T(0);
              break;
            }
            c7 && d3(O2 + V2), f2.set(r3.subarray(I, _), O2), u2.b = O2 += V2, u2.p = k2 = 8 * _;
            continue;
          }
          if (S == 1)
            A2 = b, x2 = p, E = 9, D = 5;
          else if (S == 2) {
            var j = L(r3, k2, 31) + 257, z = L(r3, k2 + 10, 15) + 4, C = j + L(r3, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e2(C), P = new e2(19), q = 0; q < z; ++q)
              P[o2[q]] = L(r3, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B = y(P), G = (1 << B) - 1, H = w(P, B, 1);
            for (q = 0; q < C; ) {
              var I, J = H[L(r3, k2, G)];
              if (k2 += 15 & J, (I = J >>> 4) < 16)
                F[q++] = I;
              else {
                var K = 0, N = 0;
                for (I == 16 ? (N = 3 + L(r3, k2, 3), k2 += 2, K = F[q - 1]) : I == 17 ? (N = 3 + L(r3, k2, 7), k2 += 3) : I == 18 && (N = 11 + L(r3, k2, 127), k2 += 7); N--; )
                  F[q++] = K;
              }
            }
            var Q = F.subarray(0, j), R = F.subarray(j);
            E = y(Q), D = y(R), A2 = w(Q, E, 1), x2 = w(R, D, 1);
          } else
            T(1);
          if (k2 > M) {
            g2 && T(0);
            break;
          }
        }
        c7 && d3(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K = A2[U(r3, k2) & W]) >>> 4;
          if ((k2 += 15 & K) > M) {
            g2 && T(0);
            break;
          }
          if (K || T(2), Z < 256)
            f2[O2++] = Z;
          else {
            if (Z == 256) {
              Y = k2, A2 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a2[q = Z - 257];
              $ = L(r3, k2, (1 << rr) - 1) + v4[q], k2 += rr;
            }
            var er = x2[U(r3, k2) & X], nr = er >>> 4;
            er || T(3), k2 += 15 & er;
            R = l2[nr];
            if (nr > 3) {
              rr = i4[nr];
              R += U(r3, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g2 && T(0);
              break;
            }
            c7 && d3(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4)
              f2[O2] = f2[O2 - R], f2[O2 + 1] = f2[O2 + 1 - R], f2[O2 + 2] = f2[O2 + 2 - R], f2[O2 + 3] = f2[O2 + 3 - R];
            O2 = tr;
          }
        }
        u2.l = A2, u2.p = Y, u2.b = O2, A2 && (m2 = 1, u2.m = E, u2.d = x2, u2.n = D);
      } while (!m2);
      return O2 == f2.length ? f2 : function(r4, a3, i5) {
        (a3 == null || a3 < 0) && (a3 = 0), (i5 == null || i5 > r4.length) && (i5 = r4.length);
        var o3 = new (r4 instanceof n2 ? n2 : r4 instanceof t2 ? t2 : e2)(i5 - a3);
        return o3.set(r4.subarray(a3, i5)), o3;
      }(f2, 0, O2);
    }, A = new e2(0);
    var x = typeof TextDecoder != "undefined" && new TextDecoder();
    try {
      x.decode(A, { stream: true }), 1;
    } catch (r3) {
    }
    return r2.convert_streams = function(r3) {
      var e3 = new DataView(r3), n3 = 0;
      function t3() {
        var r4 = e3.getUint16(n3);
        return n3 += 2, r4;
      }
      function a3() {
        var r4 = e3.getUint32(n3);
        return n3 += 4, r4;
      }
      function i5(r4) {
        m2.setUint16(b2, r4), b2 += 2;
      }
      function o3(r4) {
        m2.setUint32(b2, r4), b2 += 4;
      }
      for (var f2 = { signature: a3(), flavor: a3(), length: a3(), numTables: t3(), reserved: t3(), totalSfntSize: a3(), majorVersion: t3(), minorVersion: t3(), metaOffset: a3(), metaLength: a3(), metaOrigLength: a3(), privOffset: a3(), privLength: a3() }, u2 = 0; Math.pow(2, u2) <= f2.numTables; )
        u2++;
      u2--;
      for (var v5 = 16 * Math.pow(2, u2), s2 = 16 * f2.numTables - v5, l3 = 12, c7 = [], g2 = 0; g2 < f2.numTables; g2++)
        c7.push({ tag: a3(), offset: a3(), compLength: a3(), origLength: a3(), origChecksum: a3() }), l3 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c7.length + c7.reduce(function(r4, e4) {
        return r4 + e4.origLength + 4;
      }, 0)), d3 = w2.buffer, m2 = new DataView(d3), b2 = 0;
      return o3(f2.flavor), i5(f2.numTables), i5(v5), i5(u2), i5(s2), c7.forEach(function(r4) {
        o3(r4.tag), o3(r4.origChecksum), o3(l3), o3(r4.origLength), r4.outOffset = l3, (l3 += r4.origLength) % 4 != 0 && (l3 += 4 - l3 % 4);
      }), c7.forEach(function(e4) {
        var n4, t4 = r3.slice(e4.offset, e4.offset + e4.compLength);
        if (e4.compLength != e4.origLength) {
          var a4 = new Uint8Array(e4.origLength);
          n4 = new Uint8Array(t4, 2), O(n4, a4);
        } else
          a4 = new Uint8Array(t4);
        w2.set(a4, e4.outOffset);
        var i6 = 0;
        (l3 = e4.outOffset + e4.origLength) % 4 != 0 && (i6 = 4 - l3 % 4), w2.set(new Uint8Array(i6).buffer, e4.outOffset + e4.origLength), h2 = l3 + i6;
      }), d3.slice(0, h2);
    }, Object.defineProperty(r2, "__esModule", { value: true }), r2;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i4 = step; i4--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i4 = 0; i4 < str.length; i4++) {
      const code = str.codePointAt(i4);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i4] = form;
      prevJoiningType = joiningType;
      prevIndex = i4;
      if (code > 65535)
        i4++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i4 = 0; i4 < str.length; i4++) {
      const cc = str.codePointAt(i4);
      if (cc > 65535)
        i4++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]])
              continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function wrapFontObj(typrFont) {
    const glyphMap = Object.create(null);
    const fontObj = {
      unitsPerEm: typrFont.head.unitsPerEm,
      ascender: typrFont.hhea.ascender,
      descender: typrFont.hhea.descender,
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let glyphX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIndices = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        let prevGlyphIndex = -1;
        glyphIndices.forEach((glyphIndex, i4) => {
          if (glyphIndex !== -1) {
            let glyphObj = glyphMap[glyphIndex];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphIndex);
              let path = "";
              let crdsIdx = 0;
              for (let i5 = 0, len = cmds.length; i5 < len; i5++) {
                const numArgs = cmdArgLengths[cmds[i5]];
                path += cmds[i5];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i5 = 0, len = crds.length; i5 < len; i5 += 2) {
                  let x = crds[i5];
                  let y = crds[i5 + 1];
                  if (x < xMin)
                    xMin = x;
                  if (y < yMin)
                    yMin = y;
                  if (x > xMax)
                    xMax = x;
                  if (y > yMax)
                    yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphIndex] = {
                index: glyphIndex,
                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
                xMin,
                yMin,
                xMax,
                yMax,
                path,
                pathCommandCount: cmds.length
              };
            }
            if (prevGlyphIndex !== -1) {
              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
            }
            callback.call(null, glyphObj, glyphX, charIndex);
            if (glyphObj.advanceWidth) {
              glyphX += glyphObj.advanceWidth * fontScale;
            }
            if (letterSpacing) {
              glyphX += letterSpacing * fontSize;
            }
            prevGlyphIndex = glyphIndex;
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return glyphX;
      }
    };
    return fontObj;
  }
  return function parse2(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
var CONFIG = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor = new Color();
var hasRequested = false;
function now() {
  return (self.performance || Date).now();
}
var atlases = Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign3({}, args);
  const totalStart = now();
  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  if (args.colorRanges != null) {
    let colors3 = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors3[key] = val;
      }
    }
    args.colorRanges = colors3;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  let atlasKey = `${args.font}@${sdfGlyphSize}`;
  let atlas = atlases[atlasKey];
  if (!atlas) {
    atlas = atlases[atlasKey] = {
      count: 0,
      glyphs: new Map(),
      sdfTexture: new DataTexture(new Uint8Array(sdfGlyphSize * textureWidth * 4), textureWidth, sdfGlyphSize, RGBAFormat, void 0, void 0, void 0, void 0, LinearFilter, LinearFilter)
    };
    atlas.sdfTexture.font = args.font;
  }
  typesetInWorker(args).then((result) => {
    const { glyphIds, glyphPositions, fontSize, unitsPerEm, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    const fontSizeMult = fontSize / unitsPerEm;
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now();
    glyphIds.forEach((glyphId, i4) => {
      let glyphInfo = atlas.glyphs.get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.count++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        atlas.glyphs.set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i4] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now() - quadsStart);
    const sdfStart = now();
    timings.sdf = {};
    DefaultThenable.all(neededSDFs.map(({ path, atlasIndex, sdfViewBox }) => {
      const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
      return generateSDFInWorker(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, CONFIG.sdfExponent).then(({ textureData, timing }) => {
        timings.sdf[atlasIndex] = timing;
        return { atlasIndex, textureData, timing };
      });
    })).then((sdfResults) => {
      if (sdfResults.length) {
        sdfResults.forEach(({ atlasIndex, textureData, timing }) => {
          const texImg = atlas.sdfTexture.image;
          while (texImg.data.length < (atlasIndex + 1) * sdfGlyphSize * sdfGlyphSize) {
            const biggerArray = new Uint8Array(texImg.data.length * 2);
            biggerArray.set(texImg.data);
            texImg.data = biggerArray;
            texImg.height *= 2;
          }
          const squareIndex = Math.floor(atlasIndex / 4);
          const cols = texImg.width / sdfGlyphSize;
          const baseStartIndex = Math.floor(squareIndex / cols) * texImg.width * sdfGlyphSize * 4 + squareIndex % cols * sdfGlyphSize * 4 + atlasIndex % 4;
          for (let y = 0; y < sdfGlyphSize; y++) {
            const srcStartIndex = y * sdfGlyphSize;
            const rowStartIndex = baseStartIndex + y * texImg.width * 4;
            for (let x = 0; x < sdfGlyphSize; x++) {
              texImg.data[rowStartIndex + x * 4] = textureData[srcStartIndex + x];
            }
          }
        });
        atlas.sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now() - sdfStart;
      timings.total = now() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture: atlas.sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        caretHeight: result.caretHeight,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings,
        get totalBounds() {
          console.log("totalBounds deprecated, use blockBounds instead");
          return result.blockBounds;
        },
        get totalBlockSize() {
          console.log("totalBlockSize deprecated, use blockBounds instead");
          const [x0, y0, x1, y1] = result.blockBounds;
          return [x1 - x0, y1 - y0];
        }
      }));
    });
  });
}
function assign3(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    CONFIG,
    workerModule,
    createTypesetter,
    bidi_default
  ],
  init(config2, fontParser, createTypesetter2, bidiFactory2) {
    const { defaultFontURL } = config2;
    return createTypesetter2(fontParser, bidiFactory2(), { defaultFontURL });
  }
});
var generateSDFInWorker = function() {
  const threadCount = 4;
  const idleTimeout = 2e3;
  const threads = {};
  let callNum = 0;
  return function(...args) {
    const workerId = "TroikaTextSDFGenerator_" + callNum++ % threadCount;
    let thread = threads[workerId];
    if (!thread) {
      thread = threads[workerId] = {
        workerModule: defineWorkerModule({
          name: workerId,
          workerId,
          dependencies: [
            CONFIG,
            createGlyphSegmentsIndex,
            createSDFGenerator
          ],
          init(config2, createGlyphSegmentsIndex2, createSDFGenerator2) {
            const { sdfExponent, sdfMargin } = config2;
            return createSDFGenerator2(createGlyphSegmentsIndex2, { sdfExponent, sdfMargin });
          },
          getTransferables(result) {
            return [result.textureData.buffer];
          }
        }),
        requests: 0,
        idleTimer: null
      };
    }
    thread.requests++;
    clearTimeout(thread.idleTimer);
    return thread.workerModule(...args).then((result) => {
      if (--thread.requests === 0) {
        thread.idleTimer = setTimeout(() => {
          terminateWorker(workerId);
        }, idleTimeout);
      }
      return result;
    });
  };
}();
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule,
    ThenableWorkerModule
  ],
  init(typesetter, Thenable) {
    return function(args) {
      const thenable = new Thenable();
      typesetter.typeset(args, thenable.resolve);
      return thenable;
    };
  },
  getTransferables(result) {
    const transferables = [
      result.glyphPositions.buffer,
      result.glyphIds.buffer
    ];
    if (result.caretPositions) {
      transferables.push(result.caretPositions.buffer);
    }
    return transferables;
  }
});
var GlyphsGeometry = (() => {
  const templateGeometries = {};
  function getTemplateGeometry(detail) {
    let geom = templateGeometries[detail];
    if (!geom) {
      geom = templateGeometries[detail] = new PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);
    }
    return geom;
  }
  new Vector3();
  const glyphBoundsAttrName = "aTroikaGlyphBounds";
  const glyphIndexAttrName = "aTroikaGlyphIndex";
  const glyphColorAttrName = "aTroikaGlyphColor";
  class GlyphsGeometry2 extends InstancedBufferGeometry {
    constructor() {
      super();
      this.detail = 1;
      this.curveRadius = 0;
      this.groups = [
        { start: 0, count: Infinity, materialIndex: 0 },
        { start: 0, count: Infinity, materialIndex: 1 }
      ];
      this.boundingSphere = new Sphere();
      this.boundingBox = new Box3();
    }
    computeBoundingSphere() {
    }
    computeBoundingBox() {
    }
    set detail(detail) {
      if (detail !== this._detail) {
        this._detail = detail;
        if (typeof detail !== "number" || detail < 1) {
          detail = 1;
        }
        let tpl = getTemplateGeometry(detail);
        ["position", "normal", "uv"].forEach((attr) => {
          this.attributes[attr] = tpl.attributes[attr].clone();
        });
        this.setIndex(tpl.getIndex().clone());
      }
    }
    get detail() {
      return this._detail;
    }
    set curveRadius(r2) {
      if (r2 !== this._curveRadius) {
        this._curveRadius = r2;
        this._updateBounds();
      }
    }
    get curveRadius() {
      return this._curveRadius;
    }
    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
      this._blockBounds = blockBounds;
      this._chunkedBounds = chunkedBounds;
      setInstanceCount(this, glyphAtlasIndices.length);
      this._updateBounds();
    }
    _updateBounds() {
      const bounds = this._blockBounds;
      if (bounds) {
        const { curveRadius, boundingBox: bbox } = this;
        if (curveRadius) {
          const { PI, floor, min, max, sin, cos } = Math;
          const halfPi = PI / 2;
          const twoPi = PI * 2;
          const absR = Math.abs(curveRadius);
          const leftAngle = bounds[0] / absR;
          const rightAngle = bounds[2] / absR;
          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
        } else {
          bbox.min.set(bounds[0], bounds[1], 0);
          bbox.max.set(bounds[2], bounds[3], 0);
        }
        bbox.getBoundingSphere(this.boundingSphere);
      }
    }
    applyClipRect(clipRect) {
      let count = this.getAttribute(glyphIndexAttrName).count;
      let chunks = this._chunkedBounds;
      if (chunks) {
        for (let i4 = chunks.length; i4--; ) {
          count = chunks[i4].end;
          let rect = chunks[i4].rect;
          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
            break;
          }
        }
      }
      setInstanceCount(this, count);
    }
  }
  if (!GlyphsGeometry2.prototype.setAttribute) {
    GlyphsGeometry2.prototype.setAttribute = function(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    };
  }
  function updateBufferAttr(geom, attrName, newArray, itemSize) {
    const attr = geom.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete geom._maxInstanceCount;
        geom.dispose();
      }
    } else if (attr) {
      geom.deleteAttribute(attrName);
    }
  }
  function setInstanceCount(geom, count) {
    geom[geom.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = count;
  }
  return GlyphsGeometry2;
})();
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of encoding in SDFGenerator.js
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float distance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(distance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  distance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader, fragmentShader }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader)) {
        fragmentShader = fragmentShader.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader)) {
          vertexShader = vertexShader.replace(voidMainRegExp, "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n");
        }
      }
      return { vertexShader, fragmentShader };
    }
  });
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var Text = (() => {
  const defaultMaterial = new MeshBasicMaterial({
    color: 16777215,
    side: DoubleSide,
    transparent: true
  });
  const defaultStrokeColor = 8421504;
  const tempMat4 = new Matrix4();
  const tempVec3a = new Vector3();
  const tempVec3b = new Vector3();
  const tempArray = [];
  const origin = new Vector3();
  const defaultOrient = "+x+y";
  function first(o2) {
    return Array.isArray(o2) ? o2[0] : o2;
  }
  let getFlatRaycastMesh = () => {
    const mesh = new Mesh(new PlaneGeometry(1, 1), defaultMaterial);
    getFlatRaycastMesh = () => mesh;
    return mesh;
  };
  let getCurvedRaycastMesh = () => {
    const mesh = new Mesh(new PlaneGeometry(1, 1, 32, 1), defaultMaterial);
    getCurvedRaycastMesh = () => mesh;
    return mesh;
  };
  const syncStartEvent = { type: "syncstart" };
  const syncCompleteEvent = { type: "synccomplete" };
  const SYNCABLE_PROPS = [
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize"
  ];
  const COPYABLE_PROPS = SYNCABLE_PROPS.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
  class Text3 extends Mesh {
    constructor() {
      const geometry = new GlyphsGeometry();
      super(geometry, null);
      this.text = "";
      this.anchorX = 0;
      this.anchorY = 0;
      this.curveRadius = 0;
      this.direction = "auto";
      this.font = null;
      this.fontSize = 0.1;
      this.letterSpacing = 0;
      this.lineHeight = "normal";
      this.maxWidth = Infinity;
      this.overflowWrap = "normal";
      this.textAlign = "left";
      this.textIndent = 0;
      this.whiteSpace = "normal";
      this.material = null;
      this.color = null;
      this.colorRanges = null;
      this.outlineWidth = 0;
      this.outlineColor = 0;
      this.outlineOpacity = 1;
      this.outlineBlur = 0;
      this.outlineOffsetX = 0;
      this.outlineOffsetY = 0;
      this.strokeWidth = 0;
      this.strokeColor = defaultStrokeColor;
      this.strokeOpacity = 1;
      this.fillOpacity = 1;
      this.depthOffset = 0;
      this.clipRect = null;
      this.orientation = defaultOrient;
      this.glyphGeometryDetail = 1;
      this.sdfGlyphSize = null;
      this.debugSDF = false;
    }
    sync(callback) {
      if (this._needsSync) {
        this._needsSync = false;
        if (this._isSyncing) {
          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
        } else {
          this._isSyncing = true;
          this.dispatchEvent(syncStartEvent);
          getTextRenderInfo({
            text: this.text,
            font: this.font,
            fontSize: this.fontSize || 0.1,
            letterSpacing: this.letterSpacing || 0,
            lineHeight: this.lineHeight || "normal",
            maxWidth: this.maxWidth,
            direction: this.direction || "auto",
            textAlign: this.textAlign,
            textIndent: this.textIndent,
            whiteSpace: this.whiteSpace,
            overflowWrap: this.overflowWrap,
            anchorX: this.anchorX,
            anchorY: this.anchorY,
            colorRanges: this.colorRanges,
            includeCaretPositions: true,
            sdfGlyphSize: this.sdfGlyphSize
          }, (textRenderInfo) => {
            this._isSyncing = false;
            this._textRenderInfo = textRenderInfo;
            this.geometry.updateGlyphs(textRenderInfo.glyphBounds, textRenderInfo.glyphAtlasIndices, textRenderInfo.blockBounds, textRenderInfo.chunkedBounds, textRenderInfo.glyphColors);
            const queued = this._queuedSyncs;
            if (queued) {
              this._queuedSyncs = null;
              this._needsSync = true;
              this.sync(() => {
                queued.forEach((fn) => fn && fn());
              });
            }
            this.dispatchEvent(syncCompleteEvent);
            if (callback) {
              callback();
            }
          });
        }
      }
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
      this.sync();
      if (material.isTroikaTextMaterial) {
        this._prepareForRender(material);
      }
    }
    dispose() {
      this.geometry.dispose();
    }
    get textRenderInfo() {
      return this._textRenderInfo || null;
    }
    get material() {
      let derivedMaterial = this._derivedMaterial;
      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
        baseMaterial.addEventListener("dispose", function onDispose() {
          baseMaterial.removeEventListener("dispose", onDispose);
          derivedMaterial.dispose();
        });
      }
      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
        let outlineMaterial = derivedMaterial._outlineMtl;
        if (!outlineMaterial) {
          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
            id: { value: derivedMaterial.id + 0.1 }
          });
          outlineMaterial.isTextOutlineMaterial = true;
          outlineMaterial.depthWrite = false;
          outlineMaterial.map = null;
          derivedMaterial.addEventListener("dispose", function onDispose() {
            derivedMaterial.removeEventListener("dispose", onDispose);
            outlineMaterial.dispose();
          });
        }
        return [
          outlineMaterial,
          derivedMaterial
        ];
      } else {
        return derivedMaterial;
      }
    }
    set material(baseMaterial) {
      if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
        this._derivedMaterial = baseMaterial;
        this._baseMaterial = baseMaterial.baseMaterial;
      } else {
        this._baseMaterial = baseMaterial;
      }
    }
    get glyphGeometryDetail() {
      return this.geometry.detail;
    }
    set glyphGeometryDetail(detail) {
      this.geometry.detail = detail;
    }
    get curveRadius() {
      return this.geometry.curveRadius;
    }
    set curveRadius(r2) {
      this.geometry.curveRadius = r2;
    }
    get customDepthMaterial() {
      return first(this.material).getDepthMaterial();
    }
    get customDistanceMaterial() {
      return first(this.material).getDistanceMaterial();
    }
    _prepareForRender(material) {
      const isOutline = material.isTextOutlineMaterial;
      const uniforms = material.uniforms;
      const textInfo = this.textRenderInfo;
      if (textInfo) {
        const { sdfTexture, blockBounds } = textInfo;
        uniforms.uTroikaSDFTexture.value = sdfTexture;
        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
        let distanceOffset = 0;
        let blurRadius = 0;
        let strokeWidth = 0;
        let fillOpacity;
        let strokeOpacity;
        let strokeColor;
        let offsetX = 0;
        let offsetY = 0;
        if (isOutline) {
          let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
          distanceOffset = this._parsePercent(outlineWidth) || 0;
          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
          fillOpacity = outlineOpacity;
          offsetX = this._parsePercent(outlineOffsetX) || 0;
          offsetY = this._parsePercent(outlineOffsetY) || 0;
        } else {
          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
          if (strokeWidth) {
            strokeColor = this.strokeColor;
            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
            strokeOpacity = this.strokeOpacity;
            if (strokeOpacity == null)
              strokeOpacity = 1;
          }
          fillOpacity = this.fillOpacity;
        }
        uniforms.uTroikaDistanceOffset.value = distanceOffset;
        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
        uniforms.uTroikaBlurRadius.value = blurRadius;
        uniforms.uTroikaStrokeWidth.value = strokeWidth;
        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
        let clipRect = this.clipRect;
        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
          uniforms.uTroikaClipRect.value.fromArray(clipRect);
        } else {
          const pad = (this.fontSize || 0.1) * 100;
          uniforms.uTroikaClipRect.value.set(blockBounds[0] - pad, blockBounds[1] - pad, blockBounds[2] + pad, blockBounds[3] + pad);
        }
        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
      }
      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
      material.polygonOffset = !!this.depthOffset;
      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
      const color3 = isOutline ? this.outlineColor || 0 : this.color;
      if (color3 == null) {
        delete material.color;
      } else {
        const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
        if (color3 !== colorObj._input || typeof color3 === "object") {
          colorObj.set(colorObj._input = color3);
        }
      }
      let orient = this.orientation || defaultOrient;
      if (orient !== material._orientation) {
        let rotMat = uniforms.uTroikaOrient.value;
        orient = orient.replace(/[^-+xyz]/g, "");
        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
        if (match) {
          let [, hSign, hAxis, vSign, vAxis] = match;
          tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
          tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
          rotMat.setFromMatrix4(tempMat4);
        } else {
          rotMat.identity();
        }
        material._orientation = orient;
      }
    }
    _parsePercent(value) {
      if (typeof value === "string") {
        let match = value.match(/^(-?[\d.]+)%$/);
        let pct = match ? parseFloat(match[1]) : NaN;
        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
      }
      return value;
    }
    localPositionToTextCoords(position2, target2 = new Vector2()) {
      target2.copy(position2);
      const r2 = this.curveRadius;
      if (r2) {
        target2.x = Math.atan2(position2.x, Math.abs(r2) - Math.abs(position2.z)) * Math.abs(r2);
      }
      return target2;
    }
    worldPositionToTextCoords(position2, target2 = new Vector2()) {
      tempVec3a.copy(position2);
      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target2);
    }
    raycast(raycaster, intersects) {
      const { textRenderInfo, curveRadius } = this;
      if (textRenderInfo) {
        const bounds = textRenderInfo.blockBounds;
        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
        const geom = raycastMesh.geometry;
        const { position: position2, uv } = geom.attributes;
        for (let i4 = 0; i4 < uv.count; i4++) {
          let x = bounds[0] + uv.getX(i4) * (bounds[2] - bounds[0]);
          const y = bounds[1] + uv.getY(i4) * (bounds[3] - bounds[1]);
          let z = 0;
          if (curveRadius) {
            z = curveRadius - Math.cos(x / curveRadius) * curveRadius;
            x = Math.sin(x / curveRadius) * curveRadius;
          }
          position2.setXYZ(i4, x, y, z);
        }
        geom.boundingSphere = this.geometry.boundingSphere;
        geom.boundingBox = this.geometry.boundingBox;
        raycastMesh.matrixWorld = this.matrixWorld;
        raycastMesh.material.side = this.material.side;
        tempArray.length = 0;
        raycastMesh.raycast(raycaster, tempArray);
        for (let i4 = 0; i4 < tempArray.length; i4++) {
          tempArray[i4].object = this;
          intersects.push(tempArray[i4]);
        }
      }
    }
    copy(source) {
      const geom = this.geometry;
      super.copy(source);
      this.geometry = geom;
      COPYABLE_PROPS.forEach((prop) => {
        this[prop] = source[prop];
      });
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  SYNCABLE_PROPS.forEach((prop) => {
    const privateKey = "_private_" + prop;
    Object.defineProperty(Text3.prototype, prop, {
      get() {
        return this[privateKey];
      },
      set(value) {
        if (value !== this[privateKey]) {
          this[privateKey] = value;
          this._needsSync = true;
        }
      }
    });
  });
  let deprMsgShown = false;
  Object.defineProperty(Text3.prototype, "anchor", {
    get() {
      return this._deprecated_anchor;
    },
    set(val) {
      this._deprecated_anchor = val;
      if (!deprMsgShown) {
        console.warn("TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead.");
        deprMsgShown = true;
      }
      if (Array.isArray(val)) {
        this.anchorX = `${(+val[0] || 0) * 100}%`;
        this.anchorY = `${(+val[1] || 0) * 100}%`;
      } else {
        this.anchorX = this.anchorY = 0;
      }
    }
  });
  return Text3;
})();
var _rectsCache = new WeakMap();
var _caretsByRowCache = new WeakMap();

// node_modules/@react-three/drei/core/Text.js
var Text2 = React17.forwardRef((_a, ref) => {
  var _b = _a, {
    anchorX = "center",
    anchorY = "middle",
    children,
    onSync
  } = _b, props = __objRest(_b, [
    "anchorX",
    "anchorY",
    "children",
    "onSync"
  ]);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const [troikaMesh] = React17.useState(() => new Text());
  const [nodes, text] = React17.useMemo(() => {
    const n2 = [];
    let t2 = "";
    React17.Children.forEach(children, (child) => {
      if (typeof child === "string" || typeof child === "number") {
        t2 += child;
      } else {
        n2.push(child);
      }
    });
    return [n2, t2];
  }, [children]);
  React17.useLayoutEffect(() => void troikaMesh.sync(() => {
    invalidate();
    if (onSync)
      onSync(troikaMesh);
  }));
  React17.useEffect(() => {
    return () => troikaMesh.dispose();
  }, [troikaMesh]);
  return React17.createElement("primitive", _extends({
    object: troikaMesh,
    ref,
    text,
    anchorX,
    anchorY
  }, props), nodes);
});

// node_modules/@react-three/drei/core/Effects.js
var React18 = __toModule(require_react());
extend({
  EffectComposer,
  RenderPass,
  ShaderPass
});
var isWebGL2Available = () => {
  try {
    var canvas = document.createElement("canvas");
    return !!(window.WebGL2RenderingContext && canvas.getContext("webgl2"));
  } catch (e2) {
    return false;
  }
};
var Effects = React18.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    multisamping = 8,
    renderIndex = 1,
    disableGamma = false,
    disableRenderPass = false
  } = _b, props = __objRest(_b, [
    "children",
    "multisamping",
    "renderIndex",
    "disableGamma",
    "disableRenderPass"
  ]);
  const composer = React18.useRef();
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const size = useThree(({
    size: size2
  }) => size2);
  const [target2] = React18.useState(() => {
    if (isWebGL2Available() && multisamping > 0) {
      const t2 = new WebGLMultisampleRenderTarget(size.width, size.height, {
        format: RGBAFormat,
        encoding: sRGBEncoding
      });
      t2.samples = 8;
      return t2;
    }
  });
  React18.useEffect(() => {
    var _composer$current, _composer$current2;
    (_composer$current = composer.current) == null ? void 0 : _composer$current.setSize(size.width, size.height);
    (_composer$current2 = composer.current) == null ? void 0 : _composer$current2.setPixelRatio(gl.getPixelRatio());
  }, [gl, size]);
  useFrame(() => {
    var _composer$current3;
    return (_composer$current3 = composer.current) == null ? void 0 : _composer$current3.render();
  }, renderIndex);
  return React18.createElement("effectComposer", _extends({
    ref: react_merge_refs_esm_default([ref, composer]),
    args: [gl, target2]
  }, props), !disableRenderPass && React18.createElement("renderPass", {
    attachArray: "passes",
    args: [scene, camera]
  }), !disableGamma && React18.createElement("shaderPass", {
    attachArray: "passes",
    args: [GammaCorrectionShader]
  }), children);
});

// node_modules/@react-three/drei/core/GradientTexture.js
var React19 = __toModule(require_react());
function GradientTexture(_a) {
  var _b = _a, {
    stops,
    colors: colors3,
    size = 2048
  } = _b, props = __objRest(_b, [
    "stops",
    "colors",
    "size"
  ]);
  const texture = React19.useMemo(() => {
    const canvas = document.createElement("canvas");
    const context7 = canvas.getContext("2d");
    canvas.width = 16;
    canvas.height = size;
    const gradient = context7.createLinearGradient(0, 0, 0, size);
    let i4 = stops.length;
    while (i4--) {
      gradient.addColorStop(stops[i4], colors3[i4]);
    }
    context7.fillStyle = gradient;
    context7.fillRect(0, 0, 16, size);
    const texture2 = new Texture(canvas);
    texture2.needsUpdate = true;
    return texture2;
  }, [stops]);
  React19.useEffect(() => () => void texture.dispose(), [texture]);
  return React19.createElement("primitive", _extends({
    object: texture,
    attach: "map"
  }, props));
}

// node_modules/@react-three/drei/core/Image.js
var React20 = __toModule(require_react());

// node_modules/@react-three/drei/core/shaderMaterial.js
function shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {
  return class extends ShaderMaterial {
    constructor() {
      const entries = Object.entries(uniforms);
      super({
        uniforms: entries.reduce((acc, [name, value]) => {
          const uniform = UniformsUtils.clone({
            [name]: {
              value
            }
          });
          return __spreadValues(__spreadValues({}, acc), uniform);
        }, {}),
        vertexShader,
        fragmentShader
      });
      entries.forEach(([name]) => Object.defineProperty(this, name, {
        get: () => this.uniforms[name].value,
        set: (v4) => this.uniforms[name].value = v4
      }));
      if (onInit)
        onInit(this);
    }
  };
}

// node_modules/@react-three/drei/core/useTexture.js
var import_react6 = __toModule(require_react());
var IsObject = (url) => url === Object(url) && !Array.isArray(url) && typeof url !== "function";
function useTexture(input) {
  const gl = useThree((state) => state.gl);
  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input);
  (0, import_react6.useEffect)(() => {
    const array = Array.isArray(textures) ? textures : [textures];
    array.forEach(gl.initTexture);
  }, [gl, textures]);
  if (IsObject(input)) {
    const keys = Object.keys(input);
    const keyed = {};
    keys.forEach((key) => Object.assign(keyed, {
      [key]: textures[keys.indexOf(key)]
    }));
    return keyed;
  } else {
    return textures;
  }
}
useTexture.preload = (url) => useLoader.preload(TextureLoader, url);
useTexture.clear = (input) => useLoader.clear(TextureLoader, input);

// node_modules/@react-three/drei/core/Image.js
var ImageMaterialImpl = shaderMaterial({
  color: new Color("white"),
  scale: [1, 1],
  imageBounds: [1, 1],
  map: null,
  zoom: 1,
  grayscale: 0
}, `
  varying vec2 vUv;
  void main() {
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
    vUv = uv;
  }
`, `
  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
  varying vec2 vUv;
  uniform vec2 scale;
  uniform vec2 imageBounds;
  uniform vec3 color;
  uniform sampler2D map;
  uniform float zoom;
  uniform float grayscale;
  const vec3 luma = vec3(.299, 0.587, 0.114);
  vec4 toGrayscale(vec4 color, float intensity) {
    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
  }
  vec2 aspect(vec2 size) {
    return size / min(size.x, size.y);
  }
  void main() {
    vec2 s = aspect(scale);
    vec2 i = aspect(imageBounds);
    float rs = s.x / s.y;
    float ri = i.x / i.y;
    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
    vec2 uv = vUv * s / new + offset;
    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);
    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, 1.0), grayscale);
  }
`);
var Image = React20.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    color: color3,
    segments = 1,
    scale: scale2 = 1,
    zoom = 1,
    grayscale = 0,
    url
  } = _b, props = __objRest(_b, [
    "children",
    "color",
    "segments",
    "scale",
    "zoom",
    "grayscale",
    "url"
  ]);
  extend({
    ImageMaterial: ImageMaterialImpl
  });
  const texture = useTexture(url);
  const planeBounds = Array.isArray(scale2) ? [scale2[0], scale2[1]] : [scale2, scale2];
  const imageBounds = [texture.image.width, texture.image.height];
  return React20.createElement("mesh", _extends({
    ref,
    scale: scale2
  }, props), React20.createElement("planeGeometry", {
    args: [1, 1, segments, segments]
  }), React20.createElement("imageMaterial", {
    color: color3,
    map: texture,
    zoom,
    grayscale,
    scale: planeBounds,
    imageBounds
  }), children);
});

// node_modules/@react-three/drei/core/Edges.js
var React21 = __toModule(require_react());
function Edges(_a) {
  var _b = _a, {
    userData,
    children,
    geometry,
    threshold = 15,
    color: color3 = "black"
  } = _b, props = __objRest(_b, [
    "userData",
    "children",
    "geometry",
    "threshold",
    "color"
  ]);
  const ref = React21.useRef(null);
  React21.useLayoutEffect(() => {
    const parent = ref.current.parent;
    if (parent) {
      const geom = geometry || parent.geometry;
      if (geom !== ref.current.userData.currentGeom || threshold !== ref.current.userData.currentThreshold) {
        ref.current.userData.currentGeom = geom;
        ref.current.userData.currentThreshold = threshold;
        ref.current.geometry = new EdgesGeometry(geom, threshold);
      }
    }
  });
  return React21.createElement("lineSegments", _extends({
    ref,
    raycast: () => null
  }, props), children ? children : React21.createElement("lineBasicMaterial", {
    color: color3
  }));
}

// node_modules/@react-three/drei/core/OrthographicCamera.js
var React22 = __toModule(require_react());
var OrthographicCamera2 = React22.forwardRef((_a, ref) => {
  var _b = _a, {
    makeDefault
  } = _b, props = __objRest(_b, [
    "makeDefault"
  ]);
  const set = useThree(({
    set: set2
  }) => set2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const size = useThree(({
    size: size2
  }) => size2);
  const cameraRef = React22.useRef();
  React22.useLayoutEffect(() => {
    if (cameraRef.current && !props.manual) {
      cameraRef.current.updateProjectionMatrix();
    }
  }, [size, props]);
  React22.useLayoutEffect(() => {
    if (makeDefault && cameraRef.current) {
      const oldCam = camera;
      set(() => ({
        camera: cameraRef.current
      }));
      return () => set(() => ({
        camera: oldCam
      }));
    }
  }, [camera, cameraRef, makeDefault, set]);
  return React22.createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: react_merge_refs_esm_default([cameraRef, ref])
  }, props));
});

// node_modules/@react-three/drei/core/PerspectiveCamera.js
var React23 = __toModule(require_react());
var PerspectiveCamera2 = React23.forwardRef((_a, ref) => {
  var _b = _a, {
    makeDefault
  } = _b, props = __objRest(_b, [
    "makeDefault"
  ]);
  const set = useThree(({
    set: set2
  }) => set2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const size = useThree(({
    size: size2
  }) => size2);
  const cameraRef = React23.useRef();
  React23.useLayoutEffect(() => {
    const {
      current: cam
    } = cameraRef;
    if (cam && !props.manual) {
      cam.aspect = size.width / size.height;
      cam.updateProjectionMatrix();
    }
  }, [size, props]);
  React23.useLayoutEffect(() => {
    if (makeDefault && cameraRef.current) {
      const oldCam = camera;
      set(() => ({
        camera: cameraRef.current
      }));
      return () => set(() => ({
        camera: oldCam
      }));
    }
  }, [camera, cameraRef, makeDefault, set]);
  return React23.createElement("perspectiveCamera", _extends({
    ref: react_merge_refs_esm_default([cameraRef, ref])
  }, props));
});

// node_modules/@react-three/drei/core/CubeCamera.js
var React24 = __toModule(require_react());
function CubeCamera2(_a) {
  var _b = _a, {
    children,
    fog,
    frames = Infinity,
    resolution = 256,
    near = 1,
    far = 1e3
  } = _b, props = __objRest(_b, [
    "children",
    "fog",
    "frames",
    "resolution",
    "near",
    "far"
  ]);
  const ref = React24.useRef();
  const [camera, setCamera] = React24.useState();
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const fbo = React24.useMemo(() => new WebGLCubeRenderTarget(resolution, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBFormat,
    encoding: gl.outputEncoding
  }), [resolution]);
  let count = 0;
  useFrame(() => {
    if (camera && ref.current && (frames === Infinity || count < frames)) {
      ref.current.traverse((obj) => obj.visible = false);
      const originalFog = scene.fog;
      scene.fog = fog || originalFog;
      camera.update(gl, scene);
      scene.fog = originalFog;
      ref.current.traverse((obj) => obj.visible = true);
      count++;
    }
  });
  return React24.createElement("group", props, React24.createElement("cubeCamera", {
    ref: setCamera,
    args: [near, far, fbo]
  }), React24.createElement("group", {
    ref
  }, children(fbo.texture)));
}

// node_modules/@react-three/drei/core/DeviceOrientationControls.js
var React25 = __toModule(require_react());
var DeviceOrientationControls2 = React25.forwardRef((props, ref) => {
  const _a = props, {
    camera,
    onChange
  } = _a, rest = __objRest(_a, [
    "camera",
    "onChange"
  ]);
  const defaultCamera = useThree(({
    camera: camera2
  }) => camera2);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const explCamera = camera || defaultCamera;
  const [controls] = React25.useState(() => new DeviceOrientationControls(explCamera));
  React25.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("change", callback);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("change", callback);
  }, [onChange, controls, invalidate]);
  useFrame(() => controls == null ? void 0 : controls.update());
  React25.useEffect(() => {
    const current = controls;
    current == null ? void 0 : current.connect();
    return () => current == null ? void 0 : current.dispose();
  }, [controls]);
  return controls ? React25.createElement("primitive", _extends({
    ref,
    dispose: void 0,
    object: controls
  }, rest)) : null;
});

// node_modules/@react-three/drei/core/FlyControls.js
var React26 = __toModule(require_react());
var FlyControls2 = React26.forwardRef((props, ref) => {
  const _a = props, {
    onChange
  } = _a, rest = __objRest(_a, [
    "onChange"
  ]);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const [controls] = React26.useState(() => new FlyControls(camera, gl.domElement));
  React26.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("change", callback);
    return () => controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("change", callback);
  }, [onChange, controls, invalidate]);
  useFrame((_, delta) => controls == null ? void 0 : controls.update(delta));
  return controls ? React26.createElement("primitive", _extends({
    ref,
    dispose: void 0,
    object: controls
  }, rest)) : null;
});

// node_modules/@react-three/drei/core/MapControls.js
var React27 = __toModule(require_react());
var MapControls2 = React27.forwardRef((props = {
  enableDamping: true
}, ref) => {
  const _a = props, {
    camera,
    onChange,
    onStart,
    onEnd
  } = _a, rest = __objRest(_a, [
    "camera",
    "onChange",
    "onStart",
    "onEnd"
  ]);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const defaultCamera = useThree(({
    camera: camera2
  }) => camera2);
  const domElement = useThree(({
    gl
  }) => gl.domElement);
  const explCamera = camera || defaultCamera;
  const controls = React27.useMemo(() => new MapControls(explCamera), [explCamera]);
  React27.useEffect(() => {
    controls.connect(domElement);
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      controls.dispose();
      controls.removeEventListener("change", callback);
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
    };
  }, [onChange, onStart, onEnd, controls, invalidate, domElement]);
  useFrame(() => controls.update());
  return React27.createElement("primitive", _extends({
    ref,
    dispose: void 0,
    object: controls,
    enableDamping: true
  }, rest));
});

// node_modules/@react-three/drei/core/OrbitControls.js
var React28 = __toModule(require_react());
var OrbitControls2 = React28.forwardRef((_a, ref) => {
  var _b = _a, {
    makeDefault,
    camera,
    regress,
    domElement,
    enableDamping = true,
    onChange,
    onStart,
    onEnd
  } = _b, restProps = __objRest(_b, [
    "makeDefault",
    "camera",
    "regress",
    "domElement",
    "enableDamping",
    "onChange",
    "onStart",
    "onEnd"
  ]);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const defaultCamera = useThree(({
    camera: camera2
  }) => camera2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const events = useThree(({
    events: events2
  }) => events2);
  const set = useThree(({
    set: set2
  }) => set2);
  const get = useThree(({
    get: get2
  }) => get2);
  const performance2 = useThree(({
    performance: performance3
  }) => performance3);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || (typeof events.connected !== "boolean" ? events.connected : gl.domElement);
  const controls = React28.useMemo(() => new OrbitControls(explCamera), [explCamera]);
  useFrame(() => {
    if (controls.enabled)
      controls.update();
  });
  React28.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    controls.connect(explDomElement);
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      controls.removeEventListener("change", callback);
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
      controls.dispose();
    };
  }, [explDomElement, onChange, onStart, onEnd, regress, controls, invalidate]);
  React28.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React28.createElement("primitive", _extends({
    ref,
    object: controls,
    enableDamping
  }, restProps));
});

// node_modules/@react-three/drei/core/TrackballControls.js
var React29 = __toModule(require_react());
var TrackballControls2 = React29.forwardRef((_a, ref) => {
  var _b = _a, {
    makeDefault,
    camera,
    domElement,
    regress,
    onChange,
    onStart,
    onEnd
  } = _b, restProps = __objRest(_b, [
    "makeDefault",
    "camera",
    "domElement",
    "regress",
    "onChange",
    "onStart",
    "onEnd"
  ]);
  const {
    invalidate,
    camera: defaultCamera,
    gl,
    events,
    set,
    get,
    performance: performance2,
    viewport
  } = useThree();
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || (typeof events.connected !== "boolean" ? events.connected : gl.domElement);
  const controls = React29.useMemo(() => new TrackballControls(explCamera), [explCamera]);
  useFrame(() => {
    if (controls.enabled)
      controls.update();
  });
  React29.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    controls.connect(explDomElement);
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      controls.removeEventListener("change", callback);
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
      controls.dispose();
    };
  }, [explDomElement, onChange, onStart, onEnd, regress, controls, invalidate]);
  React29.useEffect(() => {
    controls.handleResize();
  }, [viewport]);
  React29.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React29.createElement("primitive", _extends({
    ref,
    object: controls
  }, restProps));
});

// node_modules/@react-three/drei/core/ArcballControls.js
var React30 = __toModule(require_react());
var ArcballControls2 = React30.forwardRef((_a, ref) => {
  var _b = _a, {
    makeDefault,
    camera,
    regress,
    domElement,
    onChange,
    onStart,
    onEnd
  } = _b, restProps = __objRest(_b, [
    "makeDefault",
    "camera",
    "regress",
    "domElement",
    "onChange",
    "onStart",
    "onEnd"
  ]);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const defaultCamera = useThree(({
    camera: camera2
  }) => camera2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const events = useThree(({
    events: events2
  }) => events2);
  const set = useThree(({
    set: set2
  }) => set2);
  const get = useThree(({
    get: get2
  }) => get2);
  const performance2 = useThree(({
    performance: performance3
  }) => performance3);
  const explCamera = camera || defaultCamera;
  const explDomElement = domElement || (typeof events.connected !== "boolean" ? events.connected : gl.domElement);
  const controls = React30.useMemo(() => new ArcballControls(explCamera), [explCamera]);
  useFrame(() => {
    if (controls.enabled)
      controls.update();
  });
  React30.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (regress)
        performance2.regress();
      if (onChange)
        onChange(e2);
    };
    controls.connect(explDomElement);
    controls.addEventListener("change", callback);
    if (onStart)
      controls.addEventListener("start", onStart);
    if (onEnd)
      controls.addEventListener("end", onEnd);
    return () => {
      controls.removeEventListener("change", callback);
      if (onStart)
        controls.removeEventListener("start", onStart);
      if (onEnd)
        controls.removeEventListener("end", onEnd);
      controls.dispose();
    };
  }, [explDomElement, onChange, onStart, onEnd, regress, controls, invalidate]);
  React30.useEffect(() => {
    if (makeDefault) {
      const old = get().controls;
      set({
        controls
      });
      return () => set({
        controls: old
      });
    }
  }, [makeDefault, controls]);
  return React30.createElement("primitive", _extends({
    ref,
    object: controls
  }, restProps));
});

// node_modules/@react-three/drei/core/TransformControls.js
var import_lodash = __toModule(require_lodash());
var import_lodash2 = __toModule(require_lodash2());
var React31 = __toModule(require_react());
var TransformControls2 = React31.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    domElement,
    onChange,
    onMouseDown,
    onMouseUp,
    onObjectChange,
    object
  } = _b, props = __objRest(_b, [
    "children",
    "domElement",
    "onChange",
    "onMouseDown",
    "onMouseUp",
    "onObjectChange",
    "object"
  ]);
  const transformOnlyPropNames = ["enabled", "axis", "mode", "translationSnap", "rotationSnap", "scaleSnap", "space", "size", "showX", "showY", "showZ"];
  const _a2 = props, {
    camera
  } = _a2, rest = __objRest(_a2, [
    "camera"
  ]);
  const transformProps = (0, import_lodash2.default)(rest, transformOnlyPropNames);
  const objectProps = (0, import_lodash.default)(rest, transformOnlyPropNames);
  const defaultControls = useThree((state) => state.controls);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const defaultCamera = useThree(({
    camera: camera2
  }) => camera2);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const explCamera = camera || defaultCamera;
  const controls = React31.useMemo(() => new TransformControls(explCamera, domElement || gl.domElement), [explCamera, domElement, gl.domElement]);
  const group = React31.useRef();
  React31.useLayoutEffect(() => {
    if (object)
      controls == null ? void 0 : controls.attach(object instanceof Object3D ? object : object.current);
    else
      controls == null ? void 0 : controls.attach(group.current);
  }, [object, children, controls]);
  React31.useEffect(() => {
    if (defaultControls) {
      const callback = (event) => defaultControls.enabled = !event.value;
      controls.addEventListener("dragging-changed", callback);
      return () => controls.removeEventListener("dragging-changed", callback);
    }
  }, [controls, defaultControls]);
  React31.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("change", callback);
    if (onMouseDown)
      controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("mouseDown", onMouseDown);
    if (onMouseUp)
      controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("mouseUp", onMouseUp);
    if (onObjectChange)
      controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("objectChange", onObjectChange);
    return () => {
      controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("change", callback);
      if (onMouseDown)
        controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("mouseDown", onMouseDown);
      if (onMouseUp)
        controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("mouseUp", onMouseUp);
      if (onObjectChange)
        controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("objectChange", onObjectChange);
    };
  }, [onChange, onMouseDown, onMouseUp, onObjectChange, controls, invalidate]);
  return controls ? React31.createElement(React31.Fragment, null, React31.createElement("primitive", _extends({
    ref,
    dispose: void 0,
    object: controls
  }, transformProps)), React31.createElement("group", _extends({
    ref: group
  }, objectProps), children)) : null;
});

// node_modules/@react-three/drei/core/PointerLockControls.js
var React32 = __toModule(require_react());
var PointerLockControls2 = React32.forwardRef((_a, ref) => {
  var _b = _a, {
    selector,
    onChange,
    onLock,
    onUnlock
  } = _b, props = __objRest(_b, [
    "selector",
    "onChange",
    "onLock",
    "onUnlock"
  ]);
  const _a2 = props, {
    camera
  } = _a2, rest = __objRest(_a2, [
    "camera"
  ]);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const defaultCamera = useThree(({
    camera: camera2
  }) => camera2);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const explCamera = camera || defaultCamera;
  const [controls] = React32.useState(() => new PointerLockControls(explCamera, gl.domElement));
  React32.useEffect(() => {
    const callback = (e2) => {
      invalidate();
      if (onChange)
        onChange(e2);
    };
    controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("change", callback);
    if (onLock)
      controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("lock", onLock);
    if (onUnlock)
      controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("unlock", onUnlock);
    return () => {
      controls == null ? void 0 : controls.removeEventListener == null ? void 0 : controls.removeEventListener("change", callback);
      if (onLock)
        controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("lock", onLock);
      if (onUnlock)
        controls == null ? void 0 : controls.addEventListener == null ? void 0 : controls.addEventListener("unlock", onUnlock);
    };
  }, [onChange, onLock, onUnlock, controls, invalidate]);
  React32.useEffect(() => {
    const handler = () => controls == null ? void 0 : controls.lock();
    const elements = selector ? Array.from(document.querySelectorAll(selector)) : [document];
    elements.forEach((element) => element && element.addEventListener("click", handler));
    return () => {
      elements.forEach((element) => element ? element.removeEventListener("click", handler) : void 0);
    };
  }, [controls, selector]);
  return controls ? React32.createElement("primitive", _extends({
    ref,
    dispose: void 0,
    object: controls
  }, rest)) : null;
});

// node_modules/@react-three/drei/core/FirstPersonControls.js
var React33 = __toModule(require_react());
var FirstPersonControls2 = React33.forwardRef((props, ref) => {
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const [controls] = React33.useState(() => new FirstPersonControls(camera, gl.domElement));
  useFrame((_, delta) => {
    controls.update(delta);
  });
  return controls ? React33.createElement("primitive", _extends({
    ref,
    object: controls
  }, props)) : null;
});

// node_modules/@react-three/drei/core/GizmoHelper.js
var React35 = __toModule(require_react());

// node_modules/@react-three/drei/core/useCamera.js
var React34 = __toModule(require_react());
function useCamera(camera, props) {
  const mouse = useThree((state) => state.mouse);
  const [raycast2] = React34.useState(() => {
    const raycaster = new Raycaster();
    if (props)
      applyProps(raycaster, props, {});
    return function(_, intersects) {
      raycaster.setFromCamera(mouse, camera instanceof Camera ? camera : camera.current);
      const rc = this.constructor.prototype.raycast.bind(this);
      if (rc)
        rc(raycaster, intersects);
    };
  });
  return raycast2;
}

// node_modules/@react-three/drei/core/GizmoHelper.js
var Context = React35.createContext({});
var useGizmoContext = () => {
  return React35.useContext(Context);
};
var turnRate = 2 * Math.PI;
var dummy = new Object3D();
var matrix = new Matrix4();
var [q1, q2] = [new Quaternion(), new Quaternion()];
var target = new Vector3();
var targetPosition = new Vector3();
var GizmoHelper = ({
  alignment = "bottom-right",
  margin = [80, 80],
  renderPriority = 0,
  onUpdate,
  onTarget,
  children: GizmoHelperComponent
}) => {
  const size = useThree(({
    size: size2
  }) => size2);
  const mainCamera = useThree(({
    camera
  }) => camera);
  const defaultControls = useThree(({
    controls
  }) => controls);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  const invalidate = useThree(({
    invalidate: invalidate2
  }) => invalidate2);
  const backgroundRef = React35.useRef();
  const gizmoRef = React35.useRef();
  const virtualCam = React35.useRef(null);
  const [virtualScene] = React35.useState(() => new Scene());
  const animating = React35.useRef(false);
  const radius = React35.useRef(0);
  const focusPoint = React35.useRef(new Vector3(0, 0, 0));
  const tweenCamera = (direction) => {
    animating.current = true;
    if (defaultControls || onTarget)
      focusPoint.current = (defaultControls == null ? void 0 : defaultControls.target) || (onTarget == null ? void 0 : onTarget());
    radius.current = mainCamera.position.distanceTo(target);
    q1.copy(mainCamera.quaternion);
    targetPosition.copy(direction).multiplyScalar(radius.current).add(target);
    dummy.lookAt(targetPosition);
    q2.copy(dummy.quaternion);
    invalidate();
  };
  const animateStep = (delta) => {
    if (!animating.current)
      return;
    if (q1.angleTo(q2) < 0.01) {
      animating.current = false;
      return;
    }
    const step = delta * turnRate;
    q1.rotateTowards(q2, step);
    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current);
    mainCamera.up.set(0, 1, 0).applyQuaternion(q1).normalize();
    mainCamera.quaternion.copy(q1);
    if (onUpdate)
      onUpdate();
    else if (defaultControls)
      defaultControls.update();
    invalidate();
  };
  React35.useEffect(() => {
    if (scene.background) {
      backgroundRef.current = scene.background;
      scene.background = null;
      virtualScene.background = backgroundRef.current;
    }
    return () => {
      if (backgroundRef.current) {
        scene.background = backgroundRef.current;
      }
    };
  }, []);
  const beforeRender = () => {
    var _gizmoRef$current;
    matrix.copy(mainCamera.matrix).invert();
    (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);
  };
  useFrame((_, delta) => {
    if (virtualCam.current && gizmoRef.current) {
      animateStep(delta);
      beforeRender();
      gl.autoClear = false;
      gl.clearDepth();
      gl.render(virtualScene, virtualCam.current);
    }
  }, renderPriority);
  const gizmoHelperContext = {
    tweenCamera,
    raycast: useCamera(virtualCam)
  };
  const [marginX, marginY] = margin;
  const x = alignment.endsWith("-left") ? -size.width / 2 + marginX : size.width / 2 - marginX;
  const y = alignment.startsWith("top-") ? size.height / 2 - marginY : -size.height / 2 + marginY;
  return createPortal(React35.createElement(Context.Provider, {
    value: gizmoHelperContext
  }, React35.createElement(OrthographicCamera2, {
    ref: virtualCam,
    makeDefault: false,
    position: [0, 0, 200]
  }), React35.createElement("group", {
    ref: gizmoRef,
    position: [x, y, 0]
  }, GizmoHelperComponent)), virtualScene);
};

// node_modules/@react-three/drei/core/GizmoViewcube.js
var React36 = __toModule(require_react());
var colors2 = {
  bg: "#f0f0f0",
  hover: "#999",
  text: "black",
  stroke: "black"
};
var defaultFaces = ["Right", "Left", "Top", "Bottom", "Front", "Back"];
var makePositionVector = (xyz) => new Vector3(...xyz).multiplyScalar(0.38);
var corners = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]].map(makePositionVector);
var cornerDimensions = [0.25, 0.25, 0.25];
var edges = [[1, 1, 0], [1, 0, 1], [1, 0, -1], [1, -1, 0], [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1], [-1, 1, 0], [-1, 0, 1], [-1, 0, -1], [-1, -1, 0]].map(makePositionVector);
var edgeDimensions = edges.map((edge) => edge.toArray().map((axis) => axis == 0 ? 0.5 : 0.25));
var FaceMaterial = ({
  hover,
  index,
  font = "20px Inter var, Arial, sans-serif",
  faces = defaultFaces,
  color: color3 = colors2.bg,
  hoverColor = colors2.hover,
  textColor = colors2.text,
  strokeColor = colors2.stroke,
  opacity = 1
}) => {
  const gl = useThree((state) => state.gl);
  const texture = React36.useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 128;
    canvas.height = 128;
    const context7 = canvas.getContext("2d");
    context7.fillStyle = color3;
    context7.fillRect(0, 0, canvas.width, canvas.height);
    context7.strokeStyle = strokeColor;
    context7.strokeRect(0, 0, canvas.width, canvas.height);
    context7.font = font;
    context7.textAlign = "center";
    context7.fillStyle = textColor;
    context7.fillText(faces[index].toUpperCase(), 64, 76);
    return new CanvasTexture(canvas);
  }, [index, faces, font, color3, textColor, strokeColor]);
  return React36.createElement("meshLambertMaterial", {
    map: texture,
    "map-anisotropy": gl.capabilities.getMaxAnisotropy() || 1,
    attachArray: "material",
    color: hover ? hoverColor : "white",
    transparent: true,
    opacity
  });
};
var FaceCube = (props) => {
  const {
    tweenCamera,
    raycast: raycast2
  } = useGizmoContext();
  const [hover, setHover] = React36.useState(null);
  const handlePointerOut = (e2) => {
    e2.stopPropagation();
    setHover(null);
  };
  const handleClick = (e2) => {
    e2.stopPropagation();
    tweenCamera(e2.face.normal);
  };
  const handlePointerMove = (e2) => {
    e2.stopPropagation();
    setHover(Math.floor(e2.faceIndex / 2));
  };
  return React36.createElement("mesh", {
    raycast: raycast2,
    onPointerOut: handlePointerOut,
    onPointerMove: handlePointerMove,
    onClick: props.onClick || handleClick
  }, [...Array(6)].map((_, index) => React36.createElement(FaceMaterial, _extends({
    key: index,
    index,
    hover: hover === index
  }, props))), React36.createElement("boxGeometry", null));
};
var EdgeCube = ({
  onClick,
  dimensions,
  position: position2,
  hoverColor = colors2.hover
}) => {
  const {
    tweenCamera,
    raycast: raycast2
  } = useGizmoContext();
  const [hover, setHover] = React36.useState(false);
  const handlePointerOut = (e2) => {
    e2.stopPropagation();
    setHover(false);
  };
  const handlePointerOver = (e2) => {
    e2.stopPropagation();
    setHover(true);
  };
  const handleClick = (e2) => {
    e2.stopPropagation();
    tweenCamera(position2);
  };
  return React36.createElement("mesh", {
    scale: 1.01,
    position: position2,
    raycast: raycast2,
    onPointerOver: handlePointerOver,
    onPointerOut: handlePointerOut,
    onClick: onClick || handleClick
  }, React36.createElement("meshBasicMaterial", {
    color: hover ? hoverColor : "white",
    transparent: true,
    opacity: 0.6,
    visible: hover
  }), React36.createElement("boxGeometry", {
    args: dimensions
  }));
};
var GizmoViewcube = (props) => {
  return React36.createElement("group", {
    scale: [60, 60, 60]
  }, React36.createElement(FaceCube, props), edges.map((edge, index) => React36.createElement(EdgeCube, _extends({
    key: index,
    position: edge,
    dimensions: edgeDimensions[index]
  }, props))), corners.map((corner, index) => React36.createElement(EdgeCube, _extends({
    key: index,
    position: corner,
    dimensions: cornerDimensions
  }, props))), React36.createElement("ambientLight", {
    intensity: 0.5
  }), React36.createElement("pointLight", {
    position: [10, 10, 10],
    intensity: 0.5
  }));
};

// node_modules/@react-three/drei/core/GizmoViewport.js
var React37 = __toModule(require_react());
function Axis({
  scale: scale2 = [0.8, 0.05, 0.05],
  color: color3,
  rotation: rotation2
}) {
  return React37.createElement("group", {
    rotation: rotation2
  }, React37.createElement("mesh", {
    position: [0.4, 0, 0]
  }, React37.createElement("boxGeometry", {
    args: scale2
  }), React37.createElement("meshBasicMaterial", {
    color: color3,
    toneMapped: false
  })));
}
function AxisHead(_a) {
  var _b = _a, {
    onClick,
    font,
    disabled,
    arcStyle,
    label,
    labelColor,
    axisHeadScale = 1
  } = _b, props = __objRest(_b, [
    "onClick",
    "font",
    "disabled",
    "arcStyle",
    "label",
    "labelColor",
    "axisHeadScale"
  ]);
  const gl = useThree((state) => state.gl);
  const texture = React37.useMemo(() => {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;
    const context7 = canvas.getContext("2d");
    context7.beginPath();
    context7.arc(32, 32, 16, 0, 2 * Math.PI);
    context7.closePath();
    context7.fillStyle = arcStyle;
    context7.fill();
    if (label) {
      context7.font = font;
      context7.textAlign = "center";
      context7.fillStyle = labelColor;
      context7.fillText(label, 32, 41);
    }
    return new CanvasTexture(canvas);
  }, [arcStyle, label, labelColor, font]);
  const [active, setActive] = React37.useState(false);
  const scale2 = (label ? 1 : 0.75) * (active ? 1.2 : 1) * axisHeadScale;
  const handlePointerOver = (e2) => {
    e2.stopPropagation();
    setActive(true);
  };
  const handlePointerOut = (e2) => {
    e2.stopPropagation();
    setActive(false);
  };
  return React37.createElement("sprite", _extends({
    scale: scale2,
    onPointerOver: !disabled ? handlePointerOver : void 0,
    onPointerOut: !disabled ? onClick || handlePointerOut : void 0
  }, props), React37.createElement("spriteMaterial", {
    map: texture,
    "map-anisotropy": gl.capabilities.getMaxAnisotropy() || 1,
    alphaTest: 0.3,
    opacity: label ? 1 : 0.75,
    toneMapped: false
  }));
}
var GizmoViewport = (_a) => {
  var _b = _a, {
    hideNegativeAxes,
    hideAxisHeads,
    disabled,
    font = "18px Inter var, Arial, sans-serif",
    axisColors = ["#ff3653", "#0adb50", "#2c8fdf"],
    axisHeadScale = 1,
    axisScale,
    labels = ["X", "Y", "Z"],
    labelColor = "#000",
    onClick
  } = _b, props = __objRest(_b, [
    "hideNegativeAxes",
    "hideAxisHeads",
    "disabled",
    "font",
    "axisColors",
    "axisHeadScale",
    "axisScale",
    "labels",
    "labelColor",
    "onClick"
  ]);
  const [colorX, colorY, colorZ] = axisColors;
  const {
    tweenCamera,
    raycast: raycast2
  } = useGizmoContext();
  const axisHeadProps = {
    font,
    disabled,
    labelColor,
    raycast: raycast2,
    onClick,
    axisHeadScale,
    onPointerDown: !disabled ? (e2) => {
      tweenCamera(e2.object.position);
      e2.stopPropagation();
    } : void 0
  };
  return React37.createElement("group", _extends({
    scale: 40
  }, props), React37.createElement(Axis, {
    color: colorX,
    rotation: [0, 0, 0],
    scale: axisScale
  }), React37.createElement(Axis, {
    color: colorY,
    rotation: [0, 0, Math.PI / 2],
    scale: axisScale
  }), React37.createElement(Axis, {
    color: colorZ,
    rotation: [0, -Math.PI / 2, 0],
    scale: axisScale
  }), !hideAxisHeads && React37.createElement(React37.Fragment, null, React37.createElement(AxisHead, _extends({
    arcStyle: colorX,
    position: [1, 0, 0],
    label: labels[0]
  }, axisHeadProps)), React37.createElement(AxisHead, _extends({
    arcStyle: colorY,
    position: [0, 1, 0],
    label: labels[1]
  }, axisHeadProps)), React37.createElement(AxisHead, _extends({
    arcStyle: colorZ,
    position: [0, 0, 1],
    label: labels[2]
  }, axisHeadProps)), !hideNegativeAxes && React37.createElement(React37.Fragment, null, React37.createElement(AxisHead, _extends({
    arcStyle: colorX,
    position: [-1, 0, 0]
  }, axisHeadProps)), React37.createElement(AxisHead, _extends({
    arcStyle: colorY,
    position: [0, -1, 0]
  }, axisHeadProps)), React37.createElement(AxisHead, _extends({
    arcStyle: colorZ,
    position: [0, 0, -1]
  }, axisHeadProps)))), React37.createElement("ambientLight", {
    intensity: 0.5
  }), React37.createElement("pointLight", {
    position: [10, 10, 10],
    intensity: 0.5
  }));
};

// node_modules/@react-three/drei/core/useCubeTexture.js
function useCubeTexture(files, {
  path
}) {
  const [cubeTexture] = useLoader(CubeTextureLoader, [files], (loader) => loader.setPath(path));
  return cubeTexture;
}
useCubeTexture.preload = (files, {
  path
}) => useLoader.preload(CubeTextureLoader, [files], (loader) => loader.setPath(path));

// node_modules/@react-three/drei/core/useFBX.js
function useFBX(path) {
  return useLoader(FBXLoader, path);
}
useFBX.preload = (path) => useLoader.preload(FBXLoader, path);
useFBX.clear = (input) => useLoader.clear(FBXLoader, input);

// node_modules/@react-three/drei/core/useGLTF.js
var dracoLoader = null;
function extensions(useDraco, useMeshopt, extendLoader) {
  return (loader) => {
    if (extendLoader) {
      extendLoader(loader);
    }
    if (useDraco) {
      if (!dracoLoader) {
        dracoLoader = new DRACOLoader();
      }
      dracoLoader.setDecoderPath(typeof useDraco === "string" ? useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/");
      loader.setDRACOLoader(dracoLoader);
    }
    if (useMeshopt) {
      loader.setMeshoptDecoder(typeof MeshoptDecoder === "function" ? MeshoptDecoder() : MeshoptDecoder);
    }
  };
}
function useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {
  const gltf = useLoader(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));
  return gltf;
}
useGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));
useGLTF.clear = (input) => useLoader.clear(GLTFLoader, input);

// node_modules/@react-three/drei/core/useKTX2.js
var import_react7 = __toModule(require_react());
var cdn = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master";
function useKTX2(input, basisPath = `${cdn}/basis/`) {
  const gl = useThree((state) => state.gl);
  const textures = useLoader(KTX2Loader, IsObject(input) ? Object.values(input) : input, (loader) => {
    loader.detectSupport(gl);
    loader.setTranscoderPath(basisPath);
  });
  (0, import_react7.useEffect)(() => {
    const array = Array.isArray(textures) ? textures : [textures];
    array.forEach(gl.initTexture);
  }, [gl, textures]);
  if (IsObject(input)) {
    const keys = Object.keys(input);
    const keyed = {};
    keys.forEach((key) => Object.assign(keyed, {
      [key]: textures[keys.indexOf(key)]
    }));
    return keyed;
  } else {
    return textures;
  }
}
useKTX2.preload = (url, basisPath = `${cdn}/basis/`) => useLoader.preload(KTX2Loader, url, (loader) => {
  loader.setTranscoderPath(basisPath);
});
useKTX2.clear = (input) => useLoader.clear(KTX2Loader, input);

// node_modules/@react-three/drei/core/Stats.js
var React39 = __toModule(require_react());
var import_stats = __toModule(require_stats_min());

// node_modules/@react-three/drei/helpers/useEffectfulState.js
var React38 = __toModule(require_react());
function call3(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref != null)
    ref.current = value;
}
function useEffectfulState(fn, deps = [], cb) {
  const [state, set] = React38.useState();
  React38.useLayoutEffect(() => {
    const value = fn();
    set(value);
    call3(cb, value);
    return () => call3(cb, null);
  }, deps);
  return state;
}

// node_modules/@react-three/drei/core/Stats.js
function Stats({
  showPanel = 0,
  className,
  parent
}) {
  const stats = useEffectfulState(() => new import_stats.default(), []);
  React39.useEffect(() => {
    if (stats) {
      const node = parent && parent.current || document.body;
      stats.showPanel(showPanel);
      node == null ? void 0 : node.appendChild(stats.dom);
      if (className)
        stats.dom.classList.add(className);
      const begin = addEffect(() => stats.begin());
      const end = addAfterEffect(() => stats.end());
      return () => {
        node == null ? void 0 : node.removeChild(stats.dom);
        begin();
        end();
      };
    }
  }, [parent, stats, className, showPanel]);
  return null;
}

// node_modules/@react-three/drei/core/useDepthBuffer.js
var React40 = __toModule(require_react());

// node_modules/@react-three/drei/core/useFBO.js
var import_react8 = __toModule(require_react());
function useFBO(width, height, settings) {
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const size = useThree(({
    size: size2
  }) => size2);
  const dpr = (0, import_react8.useMemo)(() => gl.getPixelRatio(), [gl]);
  const _width = typeof width === "number" ? width : size.width * dpr;
  const _height = typeof height === "number" ? height : size.height * dpr;
  const _settings = (typeof width === "number" ? settings : width) || {};
  const target2 = (0, import_react8.useMemo)(() => {
    const _a = _settings, {
      multisample,
      samples
    } = _a, targetSettings = __objRest(_a, [
      "multisample",
      "samples"
    ]);
    let target3;
    if (multisample && gl.capabilities.isWebGL2) {
      target3 = new WebGLMultisampleRenderTarget(_width, _height, targetSettings);
      if (samples)
        target3.samples = samples;
    } else {
      target3 = new WebGLRenderTarget(_width, _height, targetSettings);
    }
    return target3;
  }, []);
  (0, import_react8.useEffect)(() => {
    target2.setSize(_width, _height);
  }, [target2, _width, _height]);
  (0, import_react8.useEffect)(() => {
    return () => target2.dispose();
  }, []);
  return target2;
}

// node_modules/@react-three/drei/core/useDepthBuffer.js
function useDepthBuffer({
  size = 256,
  frames = Infinity
} = {}) {
  const dpr = useThree((state) => state.viewport.dpr);
  const {
    width,
    height
  } = useThree((state) => state.size);
  const w = size || width * dpr;
  const h = size || height * dpr;
  const depthConfig = React40.useMemo(() => {
    const depthTexture = new DepthTexture(w, h);
    depthTexture.format = DepthFormat;
    depthTexture.type = UnsignedShortType;
    return {
      depthTexture
    };
  }, [w, h]);
  let count = 0;
  const depthFBO = useFBO(w, h, depthConfig);
  useFrame((state) => {
    if (frames === Infinity || count < frames) {
      state.gl.setRenderTarget(depthFBO);
      state.gl.render(state.scene, state.camera);
      state.gl.setRenderTarget(null);
      count++;
    }
  });
  return depthFBO.depthTexture;
}

// node_modules/@react-three/drei/core/useAspect.js
function useAspect(width, height, factor = 1) {
  const v4 = useThree((state) => state.viewport);
  const adaptedHeight = height * (v4.aspect > width / height ? v4.width / width : v4.height / height);
  const adaptedWidth = width * (v4.aspect > width / height ? v4.width / width : v4.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

// node_modules/detect-gpu/dist/detect-gpu.esm.js
function e(e2, r2, n2, t2) {
  return new (n2 || (n2 = Promise))(function(o2, a2) {
    function i4(e3) {
      try {
        c6(t2.next(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function d2(e3) {
      try {
        c6(t2.throw(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function c6(e3) {
      var r3;
      e3.done ? o2(e3.value) : (r3 = e3.value, r3 instanceof n2 ? r3 : new n2(function(e4) {
        e4(r3);
      })).then(i4, d2);
    }
    c6((t2 = t2.apply(e2, r2 || [])).next());
  });
}
var r = ["geforce 320m", "geforce 8600", "geforce 8600m gt", "geforce 8800 gs", "geforce 8800 gt", "geforce 9400", "geforce 9400m g", "geforce 9400m", "geforce 9600m gt", "geforce 9600m", "geforce fx go5200", "geforce gt 120", "geforce gt 130", "geforce gt 330m", "geforce gtx 285", "google swiftshader", "intel g41", "intel g45", "intel gma 4500mhd", "intel gma x3100", "intel hd 3000", "intel q45", "legacy", "mali-2", "mali-3", "mali-4", "quadro fx 1500", "quadro fx 4", "quadro fx 5", "radeon hd 2400", "radeon hd 2600", "radeon hd 4670", "radeon hd 4850", "radeon hd 4870", "radeon hd 5670", "radeon hd 5750", "radeon hd 6290", "radeon hd 6300", "radeon hd 6310", "radeon hd 6320", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 6770m", "radeon hd 6970m", "radeon r9 200", "sgx 543", "sgx543"];
var n = (e2) => e2 = e2.toLowerCase().replace(/^angle ?\((.+)\)*$/, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "");
var t = typeof window == "undefined";
var o = (() => {
  if (t)
    return;
  const { userAgent: e2, platform: r2, maxTouchPoints: n2 } = window.navigator, o2 = /(iphone|ipod|ipad)/i.test(e2), a2 = r2 === "iPad" || r2 === "MacIntel" && n2 > 0 && !window.MSStream;
  return { isIpad: a2, isMobile: /android/i.test(e2) || o2 || a2, isSafari12: /Version\/12.+Safari/.test(e2) };
})();
var a = (e2, r2, n2) => r2 === "apple gpu" ? ((e3, r3, n3) => {
  let t2 = [r3];
  if (n3) {
    const r4 = "\n      precision highp float;\n      attribute vec3 aPosition;\n      varying float vvv;\n      void main() {\n        vvv = 0.31622776601683794;\n        gl_Position = vec4(aPosition, 1.0);\n      }\n    ", n4 = "\n      precision highp float;\n      varying float vvv;\n      void main() {\n        vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n        enc = fract(enc);\n        enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n        gl_FragColor = enc;\n      }\n    ", a2 = e3.createShader(35633), i4 = e3.createShader(35632), d2 = e3.createProgram();
    if (i4 && a2 && d2) {
      e3.shaderSource(a2, r4), e3.shaderSource(i4, n4), e3.compileShader(a2), e3.compileShader(i4), e3.attachShader(d2, a2), e3.attachShader(d2, i4), e3.linkProgram(d2), e3.detachShader(d2, a2), e3.detachShader(d2, i4), e3.deleteShader(a2), e3.deleteShader(i4), e3.useProgram(d2);
      const c6 = e3.createBuffer();
      e3.bindBuffer(34962, c6), e3.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
      const l2 = e3.getAttribLocation(d2, "aPosition");
      e3.vertexAttribPointer(l2, 3, 5126, false, 0, 0), e3.enableVertexAttribArray(l2), e3.clearColor(1, 1, 1, 1), e3.clear(16384), e3.viewport(0, 0, 1, 1), e3.drawArrays(4, 0, 3);
      const f = new Uint8Array(4);
      e3.readPixels(0, 0, 1, 1, 6408, 5121, f), e3.deleteProgram(d2), e3.deleteBuffer(c6), t2 = { 801621810: (o == null ? void 0 : o.isIpad) ? ["apple a12x gpu"] : ["apple a11 gpu", "apple a12 gpu", "apple a13 gpu", "apple a14 gpu"], 8016218135: (o == null ? void 0 : o.isIpad) ? ["apple a9x gpu", "apple a10 gpu", "apple a10x gpu"] : ["apple a9 gpu", "apple a10 gpu"] }[f.join("")] || t2;
    }
  }
  return t2;
})(e2, r2, n2) : [r2];
var i = [];
var d = [];
var c = (e2, r2) => {
  if (e2 === r2)
    return 0;
  const n2 = e2;
  e2.length > r2.length && (e2 = r2, r2 = n2);
  let t2 = e2.length, o2 = r2.length;
  for (; t2 > 0 && e2.charCodeAt(~-t2) === r2.charCodeAt(~-o2); )
    t2--, o2--;
  let a2, c6 = 0;
  for (; c6 < t2 && e2.charCodeAt(c6) === r2.charCodeAt(c6); )
    c6++;
  if (t2 -= c6, o2 -= c6, t2 === 0)
    return o2;
  let l2, f, s = 0, g = 0, p = 0;
  for (; g < t2; )
    d[g] = e2.charCodeAt(c6 + g), i[g] = ++g;
  for (; p < o2; )
    for (a2 = r2.charCodeAt(c6 + p), l2 = p++, s = p, g = 0; g < t2; g++)
      f = a2 === d[g] ? l2 : l2 + 1, l2 = i[g], s = i[g] = l2 > s ? f > s ? s + 1 : f : f > l2 ? l2 + 1 : f;
  return s;
};
var l = ({ mobileTiers: i4 = [0, 15, 30, 60], desktopTiers: d2 = [0, 15, 30, 60], override: l2 = {}, glContext: f, failIfMajorPerformanceCaveat: s = false, benchmarksURL: g = "https://unpkg.com/detect-gpu@3.1.30/dist/benchmarks" } = {}) => e(void 0, void 0, void 0, function* () {
  const p = {};
  if (t)
    return { tier: 0, type: "SSR" };
  const { isIpad: u = !!(o == null ? void 0 : o.isIpad), isMobile: h = !!(o == null ? void 0 : o.isMobile), screenSize: v4 = window.screen, loadBenchmarks: m = (r2) => e(void 0, void 0, void 0, function* () {
    const e2 = yield fetch(`${g}/${r2}`).then((e3) => e3.json());
    return e2.shift(), e2;
  }) } = l2;
  let { renderer: w } = l2;
  const A = (e2, r2, n2, t2, o2) => ({ device: o2, fps: t2, gpu: n2, isMobile: h, tier: e2, type: r2 });
  let x, S = "";
  if (w)
    w = n(w), x = [w];
  else {
    const e2 = f || ((e3, r3 = false) => {
      const n2 = { alpha: false, antialias: false, depth: false, failIfMajorPerformanceCaveat: r3, powerPreference: "high-performance", stencil: false };
      e3 && delete n2.powerPreference;
      const t2 = window.document.createElement("canvas"), o2 = t2.getContext("webgl", n2) || t2.getContext("experimental-webgl", n2);
      return o2 != null ? o2 : void 0;
    })(o == null ? void 0 : o.isSafari12, s);
    if (!e2)
      return A(0, "WEBGL_UNSUPPORTED");
    const r2 = e2.getExtension("WEBGL_debug_renderer_info");
    if (r2 && (w = e2.getParameter(r2.UNMASKED_RENDERER_WEBGL)), !w)
      return A(1, "FALLBACK");
    S = w, w = n(w), x = a(e2, w, h);
  }
  const b = (yield Promise.all(x.map((r2) => e(void 0, void 0, void 0, function* () {
    const e2 = ((e3) => {
      const r3 = h ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr"] : ["intel", "amd", "radeon", "nvidia", "geforce"];
      for (const n3 of r3)
        if (e3.includes(n3))
          return n3;
    })(r2);
    if (!e2)
      return;
    const n2 = `${h ? "m" : "d"}-${e2}.json`, t2 = p[n2] = p[n2] || m(n2);
    let o2;
    try {
      o2 = yield t2;
    } catch (e3) {
      return;
    }
    const a2 = ((e3) => {
      var r3;
      const n3 = (e3 = e3.replace(/\([^)]+\)/, "")).match(/\d+/) || e3.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
      return (r3 = n3 == null ? void 0 : n3.join("").replace(/\W|amd/g, "")) !== null && r3 !== void 0 ? r3 : "";
    })(r2), i5 = e2 === "apple";
    let d3 = o2.filter(([, e3]) => e3 === a2);
    d3.length || (d3 = o2.filter(([e3]) => e3.includes(r2)));
    const l3 = d3.length;
    if (l3 === 0)
      return;
    let f2, [s2, , , g2] = l3 > 1 ? d3.map((e3) => [e3, c(r2, e3[0])]).sort(([, e3], [, r3]) => e3 - r3)[0][0] : d3[0], w2 = Number.MAX_VALUE;
    const { devicePixelRatio: A2 } = window, x2 = v4.width * A2 * (v4.height * A2);
    i5 && h && (g2 = g2.filter(([, , , e3]) => {
      var r3;
      return ((r3 = e3 == null ? void 0 : e3.indexOf(u ? "ipad" : "iphone")) !== null && r3 !== void 0 ? r3 : -1) > -1;
    }));
    for (const e3 of g2) {
      const [r3, n3] = e3, t3 = r3 * n3, o3 = Math.abs(x2 - t3);
      o3 < w2 && (w2 = o3, f2 = e3);
    }
    if (!f2)
      return;
    const [, , S2, b2] = f2;
    return [w2, S2, s2, b2];
  })))).filter((e2) => !!e2);
  if (!b.length) {
    const e2 = r.find((e3) => w.includes(e3));
    return e2 ? A(0, "BLOCKLISTED", e2) : A(1, "FALLBACK", `${w} (${S})`);
  }
  const [, P, C, y] = b.sort(([e2 = Number.MAX_VALUE], [r2 = Number.MAX_VALUE]) => e2 - r2)[0];
  if (P === -1)
    return A(0, "BLOCKLISTED", C, P, y);
  const L = h ? i4 : d2;
  let E = 0;
  for (let e2 = 0; e2 < L.length; e2++)
    P >= L[e2] && (E = e2);
  return A(E, "BENCHMARK", C, P, y);
});

// node_modules/@react-three/drei/core/useDetectGPU.js
var useDetectGPU = (props) => useAsset(() => l(props), "useDetectGPU");

// node_modules/@react-three/drei/core/useHelper.js
var React41 = __toModule(require_react());
function useHelper(object3D, proto, ...args) {
  const helper = React41.useRef();
  const scene = useThree((state) => state.scene);
  React41.useEffect(() => {
    if (proto && object3D.current) {
      helper.current = new proto(object3D.current, ...args);
      if (helper.current) {
        scene.add(helper.current);
      }
    }
    return () => {
      if (helper.current) {
        scene.remove(helper.current);
      }
    };
  }, [scene, proto, object3D, args]);
  useFrame(() => {
    var _helper$current;
    if ((_helper$current = helper.current) != null && _helper$current.update) {
      helper.current.update();
    }
  });
  return helper;
}

// node_modules/@react-three/drei/core/useBVH.js
var React42 = __toModule(require_react());

// node_modules/three-mesh-bvh/src/core/Constants.js
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);

// node_modules/three-mesh-bvh/src/core/MeshBVHNode.js
var MeshBVHNode = class {
  constructor() {
  }
};

// node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js
function arrayToBox(nodeIndex32, array, target2) {
  target2.min.x = array[nodeIndex32];
  target2.min.y = array[nodeIndex32 + 1];
  target2.min.z = array[nodeIndex32 + 2];
  target2.max.x = array[nodeIndex32 + 3];
  target2.max.y = array[nodeIndex32 + 4];
  target2.max.z = array[nodeIndex32 + 5];
  return target2;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i4 = 0; i4 < 3; i4++) {
    const dist = bounds[i4 + 3] - bounds[i4];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i4;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target2) {
  target2.set(source);
}
function unionBounds(a2, b, target2) {
  let aVal, bVal;
  for (let d2 = 0; d2 < 3; d2++) {
    const d3 = d2 + 3;
    aVal = a2[d2];
    bVal = b[d2];
    target2[d2] = aVal < bVal ? aVal : bVal;
    aVal = a2[d3];
    bVal = b[d3];
    target2[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d2 = 0; d2 < 3; d2++) {
    const tCenter = triangleBounds[startIndex + 2 * d2];
    const tHalf = triangleBounds[startIndex + 2 * d2 + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d2]) {
      bounds[d2] = tMin;
    }
    if (tMax > bounds[d2 + 3]) {
      bounds[d2 + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}

// node_modules/three-mesh-bvh/src/core/buildFunctions.js
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    let index;
    if (vertexCount > 65535) {
      index = new Uint32Array(new BufferConstructor(4 * vertexCount));
    } else {
      index = new Uint16Array(new BufferConstructor(2 * vertexCount));
    }
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i4 = 0; i4 < vertexCount; i4++) {
      index[i4] = i4;
    }
  }
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return [{ offset: 0, count: geo.index.count / 3 }];
  }
  const ranges = [];
  const rangeBoundaries = new Set();
  for (const group of geo.groups) {
    rangeBoundaries.add(group.start);
    rangeBoundaries.add(group.start + group.count);
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a2, b) => a2 - b);
  for (let i4 = 0; i4 < sortedBoundaries.length - 1; i4++) {
    const start2 = sortedBoundaries[i4], end = sortedBoundaries[i4 + 1];
    ranges.push({ offset: start2 / 3, count: (end - start2) / 3 });
  }
  return ranges;
}
function getBounds(triangleBounds, offset, count, target2, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i4 = offset * 6, end = (offset + count) * 6; i4 < end; i4 += 6) {
    const cx = triangleBounds[i4 + 0];
    const hx = triangleBounds[i4 + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i4 + 2];
    const hy = triangleBounds[i4 + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i4 + 4];
    const hz = triangleBounds[i4 + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target2[0] = minx;
  target2[1] = miny;
  target2[2] = minz;
  target2[3] = maxx;
  target2[4] = maxy;
  target2[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i4 = offset * 6, end = (offset + count) * 6; i4 < end; i4 += 6) {
    const cx = triangleBounds[i4 + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i4 + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i4 + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function partition(index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i4 = 0; i4 < 3; i4++) {
        let t0 = index[left * 3 + i4];
        index[left * 3 + i4] = index[right * 3 + i4];
        index[right * 3 + i4] = t0;
        let t1 = triangleBounds[left * 6 + i4 * 2 + 0];
        triangleBounds[left * 6 + i4 * 2 + 0] = triangleBounds[right * 6 + i4 * 2 + 0];
        triangleBounds[right * 6 + i4 * 2 + 0] = t1;
        let t2 = triangleBounds[left * 6 + i4 * 2 + 1];
        triangleBounds[left * 6 + i4 * 2 + 1] = triangleBounds[right * 6 + i4 * 2 + 1];
        triangleBounds[right * 6 + i4 * 2 + 1] = t2;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
var BIN_COUNT = 32;
var binsSort = (a2, b) => a2.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a2 = 0; a2 < 3; a2++) {
      const axisLeft = centroidBoundingData[a2];
      const axisRight = centroidBoundingData[a2 + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c6 = cStart; c6 < cEnd; c6 += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c6 + 2 * a2];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d2 = 0; d2 < 3; d2++) {
            rightCacheBounds[d2] = Infinity;
            rightCacheBounds[d2 + 3] = -Infinity;
            leftCacheBounds[d2] = Infinity;
            leftCacheBounds[d2 + 3] = -Infinity;
            bounds[d2] = Infinity;
            bounds[d2 + 3] = -Infinity;
          }
          expandByTriangleBounds(c6, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c6 = cStart; c6 < cEnd; c6 += 6) {
          const center = triangleBounds[c6 + 2 * a2];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c6, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c6, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a2;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i4 = 0; i4 < BIN_COUNT; i4++) {
          const bin = sahBins[i4];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i4 * binWidth;
          const bounds = bin.bounds;
          for (let d2 = 0; d2 < 3; d2++) {
            bounds[d2] = Infinity;
            bounds[d2 + 3] = -Infinity;
          }
        }
        for (let c6 = cStart; c6 < cEnd; c6 += 6) {
          const triCenter = triangleBounds[c6 + 2 * a2];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c6, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i4 = BIN_COUNT - 2; i4 >= 0; i4--) {
          const bin = sahBins[i4];
          const nextBin = sahBins[i4 + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i4 = 0; i4 < BIN_COUNT - 1; i4++) {
          const bin = sahBins[i4];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i4 + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a2;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i4 = offset, end = offset + count; i4 < end; i4++) {
    avg += triangleBounds[i4 * 6 + axis * 2];
  }
  return avg / count;
}
function computeTriangleBounds(geo, fullBounds) {
  const posAttr = geo.attributes.position;
  const posArr = posAttr.array;
  const index = geo.index.array;
  const triCount = index.length / 3;
  const triangleBounds = new Float32Array(triCount * 6);
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    const ai = index[tri3 + 0] * stride + bufferOffset;
    const bi = index[tri3 + 1] * stride + bufferOffset;
    const ci = index[tri3 + 2] * stride + bufferOffset;
    for (let el = 0; el < 3; el++) {
      const a2 = posArr[ai + el];
      const b = posArr[bi + el];
      const c6 = posArr[ci + el];
      let min = a2;
      if (b < min)
        min = b;
      if (c6 < min)
        min = c6;
      let max = a2;
      if (b > max)
        max = b;
      if (c6 > max)
        max = c6;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}
function buildTree(geo, options) {
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geo);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partition(indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
  ensureIndex(geo, options);
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geo, fullBounds);
  const indexArray = geo.index.array;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = geo.index.count / 3;
  let reachedMaxDepth = false;
  const roots = [];
  const ranges = getRootIndexRanges(geo);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
}
function buildPackedTree(geo, options) {
  const roots = buildTree(geo, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i4 = 0; i4 < roots.length; i4++) {
    const root = roots[i4];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  return packedRoots;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i4 = 0; i4 < 6; i4++) {
      float32Array[stride4Offset + i4] = boundingData[i4];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}

// node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i4 = 0, l2 = points.length; i4 < l2; i4++) {
      const p = points[i4];
      const val = p[field];
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i4 = 0, l2 = points.length; i4 < l2; i4++) {
      const p = points[i4];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var areIntersecting = function() {
  const cacheSatBounds = new SeparatingAxisBounds();
  return function areIntersecting2(shape1, shape2) {
    const points1 = shape1.points;
    const satAxes1 = shape1.satAxes;
    const satBounds1 = shape1.satBounds;
    const points2 = shape2.points;
    const satAxes2 = shape2.satAxes;
    const satBounds2 = shape2.satBounds;
    for (let i4 = 0; i4 < 3; i4++) {
      const sb = satBounds1[i4];
      const sa = satAxes1[i4];
      cacheSatBounds.setFromPoints(sa, points2);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
    for (let i4 = 0; i4 < 3; i4++) {
      const sb = satBounds2[i4];
      const sa = satAxes2[i4];
      cacheSatBounds.setFromPoints(sa, points1);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
  };
}();

// node_modules/three-mesh-bvh/src/math/MathUtilities.js
var closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v22 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v22);
    dir1.subVectors(l1.end, l2.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d2, d22;
    if (denom !== 0) {
      d2 = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d2 = 0;
    }
    d22 = (d0232 + d2 * d3210) / d3232;
    result.x = d2;
    result.y = d22;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp12 = new Vector3();
  const temp22 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d2 = paramResult.x;
    let d22 = paramResult.y;
    if (d2 >= 0 && d2 <= 1 && d22 >= 0 && d22 <= 1) {
      l1.at(d2, target1);
      l2.at(d22, target2);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d22 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d22 >= 0 && d22 <= 1) {
      if (d2 < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d2 < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d22 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp12;
      const closestPoint2 = temp22;
      l1.closestPointToPoint(p2, true, temp12);
      l2.closestPointToPoint(p, true, temp22);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle) {
    const { radius, center } = sphere;
    const { a: a2, b, c: c6 } = triangle;
    lineTemp.start = a2;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a2;
    lineTemp.end = c6;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c6;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();

// node_modules/three-mesh-bvh/src/math/SeparatingAxisTriangle.js
var SeparatingAxisTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isSeparatingAxisTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = false;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a2 = this.a;
    const b = this.b;
    const c6 = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a2, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c6);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c6, a2);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a2);
    this.needsUpdate = false;
  }
};
SeparatingAxisTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start: start2, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i4 = 0; i4 < 3; i4++) {
      const nexti = (i4 + 1) % 3;
      edge.start.copy(points[i4]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start2, point1);
    distSq = start2.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start2);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
SeparatingAxisTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new SeparatingAxisTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  return function intersectsTriangle(other, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isSeparatingAxisTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const satBounds1 = this.satBounds;
    const satAxes1 = this.satAxes;
    arr2[0] = other.a;
    arr2[1] = other.b;
    arr2[2] = other.c;
    for (let i4 = 0; i4 < 4; i4++) {
      const sb = satBounds1[i4];
      const sa = satAxes1[i4];
      cachedSatBounds.setFromPoints(sa, arr2);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const satBounds2 = other.satBounds;
    const satAxes2 = other.satAxes;
    arr1[0] = this.a;
    arr1[1] = this.b;
    arr1[2] = this.c;
    for (let i4 = 0; i4 < 4; i4++) {
      const sb = satBounds2[i4];
      const sa = satAxes2[i4];
      cachedSatBounds.setFromPoints(sa, arr1);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i4 = 0; i4 < 4; i4++) {
      const sa1 = satAxes1[i4];
      for (let i22 = 0; i22 < 4; i22++) {
        const sa2 = satAxes2[i22];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, arr1);
        cachedSatBounds2.setFromPoints(cachedAxis, arr2);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    if (target2) {
      const plane1 = this.plane;
      const plane2 = other.plane;
      if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
        console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        target2.start.set(0, 0, 0);
        target2.end.set(0, 0, 0);
      } else {
        const points1 = this.points;
        let found1 = false;
        for (let i4 = 0; i4 < 3; i4++) {
          const p1 = points1[i4];
          const p2 = points1[(i4 + 1) % 3];
          edge.start.copy(p1);
          edge.end.copy(p2);
          if (plane2.intersectLine(edge, found1 ? edge1.start : edge1.end)) {
            if (found1) {
              break;
            }
            found1 = true;
          }
        }
        const points2 = other.points;
        let found2 = false;
        for (let i4 = 0; i4 < 3; i4++) {
          const p1 = points2[i4];
          const p2 = points2[(i4 + 1) % 3];
          edge.start.copy(p1);
          edge.end.copy(p2);
          if (plane1.intersectLine(edge, found2 ? edge2.start : edge2.end)) {
            if (found2) {
              break;
            }
            found2 = true;
          }
        }
        edge1.delta(dir1);
        edge2.delta(dir2);
        if (dir1.dot(dir2) < 0) {
          let tmp = edge2.start;
          edge2.start = edge2.end;
          edge2.end = tmp;
        }
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target2.start.copy(edge1.start);
        } else {
          target2.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target2.end.copy(edge1.end);
        } else {
          target2.end.copy(edge2.end);
        }
      }
    }
    return true;
  };
}();
SeparatingAxisTriangle.prototype.distanceToPoint = function() {
  const target2 = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target2);
    return point.distanceTo(target2);
  };
}();
SeparatingAxisTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i4 = 0; i4 < 3; i4++) {
      let dist;
      const field = cornerFields[i4];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i4 = 0; i4 < 3; i4++) {
      const f11 = cornerFields[i4];
      const f12 = cornerFields[(i4 + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i22 = 0; i22 < 3; i22++) {
        const f21 = cornerFields[i22];
        const f22 = cornerFields[(i22 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
var OrientedBox = class extends Box3 {
  constructor(...args) {
    super(...args);
    this.isOrientedBox = true;
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
  }
  set(min, max, matrix2) {
    super.set(min, max);
    this.matrix = matrix2;
    this.needsUpdate = true;
  }
  copy(other) {
    super.copy(other);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = function() {
  return function update3() {
    const matrix2 = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i4 = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v4 = points[i4];
          v4.x = x ? max.x : min.x;
          v4.y = y ? max.y : min.y;
          v4.z = z ? max.z : min.z;
          v4.applyMatrix4(matrix2);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i4 = 0; i4 < 3; i4++) {
      const axis = satAxes[i4];
      const sb = satBounds[i4];
      const index = 1 << i4;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i4 = 0; i4 < 3; i4++) {
      const axis = satAxes[i4];
      const sb = satBounds[i4];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new SeparatingAxisTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle.isSeparatingAxisTriangle) {
      saTri.copy(triangle);
      saTri.update();
      triangle = saTri;
    } else if (triangle.needsUpdate) {
      triangle.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle.a;
    pointsArr[1] = triangle.b;
    pointsArr[2] = triangle.c;
    for (let i4 = 0; i4 < 3; i4++) {
      const sb = satBounds[i4];
      const sa = satAxes[i4];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle.satBounds;
    const triSatAxes = triangle.satAxes;
    const points = this.points;
    for (let i4 = 0; i4 < 3; i4++) {
      const sb = triSatBounds[i4];
      const sa = triSatAxes[i4];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i4 = 0; i4 < 3; i4++) {
      const sa1 = satAxes[i4];
      for (let i22 = 0; i22 < 4; i22++) {
        const sa2 = triSatAxes[i22];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = function() {
  return function closestPointToPoint(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target2 = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target2);
    return point.distanceTo(target2);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields2 = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i4 = 0; i4 < 8; i4++) {
      const p = points[i4];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i4 = 0; i4 < 3; i4++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i22 = 0; i22 <= 1; i22++) {
          const nextIndex = (i4 + 1) % 3;
          const nextIndex2 = (i4 + 2) % 3;
          const index = i1 << nextIndex | i22 << nextIndex2;
          const index2 = 1 << i4 | i1 << nextIndex | i22 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields2[i4];
          const f2 = xyzFields2[nextIndex];
          const f3 = xyzFields2[nextIndex2];
          const line2 = segments2[count];
          const start2 = line2.start;
          const end = line2.end;
          start2[f1] = min[f1];
          start2[f2] = i1 ? min[f2] : max[f2];
          start2[f3] = i22 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i22 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i4 = 0; i4 < 12; i4++) {
      const l1 = segments1[i4];
      for (let i22 = 0; i22 < 12; i22++) {
        const l2 = segments2[i22];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js
var vA = new Vector3();
var vB = new Vector3();
var vC = new Vector3();
var uvA = new Vector2();
var uvB = new Vector2();
var uvC = new Vector2();
var intersectionPoint = new Vector3();
function checkIntersection(ray2, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray2.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray2.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray2, position2, uv, a2, b, c6, side) {
  vA.fromBufferAttribute(position2, a2);
  vB.fromBufferAttribute(position2, b);
  vC.fromBufferAttribute(position2, c6);
  const intersection = checkIntersection(ray2, vA, vB, vC, intersectionPoint, side);
  if (intersection) {
    if (uv) {
      uvA.fromBufferAttribute(uv, a2);
      uvB.fromBufferAttribute(uv, b);
      uvC.fromBufferAttribute(uv, c6);
      intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
    }
    const face = {
      a: a2,
      b,
      c: c6,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(vA, vB, vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a2;
  }
  return intersection;
}
function intersectTri(geo, side, ray2, tri, intersections) {
  const triOffset = tri * 3;
  const a2 = geo.index.getX(triOffset);
  const b = geo.index.getX(triOffset + 1);
  const c6 = geo.index.getX(triOffset + 2);
  const intersection = checkBufferGeometryIntersection(ray2, geo.attributes.position, geo.attributes.uv, a2, b, c6, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}

// node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js
function intersectTris(geo, side, ray2, offset, count, intersections) {
  for (let i4 = offset, end = offset + count; i4 < end; i4++) {
    intersectTri(geo, side, ray2, i4, intersections);
  }
}
function intersectClosestTri(geo, side, ray2, offset, count) {
  let dist = Infinity;
  let res = null;
  for (let i4 = offset, end = offset + count; i4 < end; i4++) {
    const intersection = intersectTri(geo, side, ray2, i4);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}

// node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js
function setTriangle(tri, i4, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i4;
  let i1 = i4 + 1;
  let i22 = i4 + 2;
  if (index) {
    i0 = index.getX(i4);
    i1 = index.getX(i4 + 1);
    i22 = index.getX(i4 + 2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i22);
  tc.y = pos.getY(i22);
  tc.z = pos.getZ(i22);
}
function iterateOverTriangles(offset, count, geometry, intersectsTriangleFunc, contained, depth, triangle) {
  const index = geometry.index;
  const pos = geometry.attributes.position;
  for (let i4 = offset, l2 = count + offset; i4 < l2; i4++) {
    setTriangle(triangle, i4 * 3, index, pos);
    triangle.needsUpdate = true;
    if (intersectsTriangleFunc(triangle, i4, contained, depth)) {
      return true;
    }
  }
  return false;
}
var tempV1 = new Vector3();
var tempV2 = new Vector3();
var tempV3 = new Vector3();
var tempUV1 = new Vector2();
var tempUV2 = new Vector2();
var tempUV3 = new Vector2();

// node_modules/three-mesh-bvh/src/utils/PrimitivePool.js
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives2 = this._primitives;
    if (primitives2.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives2.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};

// node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}

// node_modules/three-mesh-bvh/src/core/castFunctions.js
var boundingBox = new Box3();
var boxIntersection = new Vector3();
var xyzFields = ["x", "y", "z"];
function raycast(nodeIndex32, geometry, side, ray2, intersects) {
  let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(geometry, side, ray2, offset, count, intersects);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, boxIntersection)) {
      raycast(leftIndex, geometry, side, ray2, intersects);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, boxIntersection)) {
      raycast(rightIndex, geometry, side, ray2, intersects);
    }
  }
}
function raycastFirst(nodeIndex32, geometry, side, ray2) {
  let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(geometry, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = xyzFields[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c12, c22;
    if (leftToRight) {
      c12 = LEFT_NODE(nodeIndex32);
      c22 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c12 = RIGHT_NODE(nodeIndex32, uint32Array);
      c22 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c12, float32Array, ray2, boxIntersection);
    const c1Result = c1Intersection ? raycastFirst(c12, geometry, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c22 + splitAxis] : point >= float32Array[c22 + splitAxis + 3];
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c22, float32Array, ray2, boxIntersection);
    const c2Result = c2Intersection ? raycastFirst(c22, geometry, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var shapecast = function() {
  let _box12, _box22;
  const boxStack = [];
  const boxPool = new PrimitivePool(() => new Box3());
  return function shapecast2(...args) {
    _box12 = boxPool.getPrimitive();
    _box22 = boxPool.getPrimitive();
    boxStack.push(_box12, _box22);
    const result = shapecastTraverse(...args);
    boxPool.releasePrimitive(_box12);
    boxPool.releasePrimitive(_box22);
    boxStack.pop();
    boxStack.pop();
    const length = boxStack.length;
    if (length > 0) {
      _box22 = boxStack[length - 1];
      _box12 = boxStack[length - 2];
    }
    return result;
  };
  function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
    function getLeftOffset(nodeIndex322) {
      let nodeIndex162 = nodeIndex322 * 2, uint16Array2 = _uint16Array, uint32Array2 = _uint32Array;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }
    function getRightEndOffset(nodeIndex322) {
      let nodeIndex162 = nodeIndex322 * 2, uint16Array2 = _uint16Array, uint32Array2 = _uint32Array;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    }
    let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
    if (isLeaf) {
      const offset = OFFSET(nodeIndex32, uint32Array);
      const count = COUNT(nodeIndex16, uint16Array);
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box12);
      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box12);
    } else {
      const left = LEFT_NODE(nodeIndex32);
      const right = RIGHT_NODE(nodeIndex32, uint32Array);
      let c12 = left;
      let c22 = right;
      let score1, score2;
      let box1, box2;
      if (nodeScoreFunc) {
        box1 = _box12;
        box2 = _box22;
        arrayToBox(BOUNDING_DATA_INDEX(c12), float32Array, box1);
        arrayToBox(BOUNDING_DATA_INDEX(c22), float32Array, box2);
        score1 = nodeScoreFunc(box1);
        score2 = nodeScoreFunc(box2);
        if (score2 < score1) {
          c12 = right;
          c22 = left;
          const temp5 = score1;
          score1 = score2;
          score2 = temp5;
          box1 = box2;
        }
      }
      if (!box1) {
        box1 = _box12;
        arrayToBox(BOUNDING_DATA_INDEX(c12), float32Array, box1);
      }
      const isC1Leaf = IS_LEAF(c12 * 2, uint16Array);
      const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c12);
      let c1StopTraversal;
      if (c1Intersection === CONTAINED) {
        const offset = getLeftOffset(c12);
        const end = getRightEndOffset(c12);
        const count = end - offset;
        c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c12, box1);
      } else {
        c1StopTraversal = c1Intersection && shapecastTraverse(c12, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);
      }
      if (c1StopTraversal)
        return true;
      box2 = _box22;
      arrayToBox(BOUNDING_DATA_INDEX(c22), float32Array, box2);
      const isC2Leaf = IS_LEAF(c22 * 2, uint16Array);
      const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c22);
      let c2StopTraversal;
      if (c2Intersection === CONTAINED) {
        const offset = getLeftOffset(c22);
        const end = getRightEndOffset(c22);
        const count = end - offset;
        c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c22, box2);
      } else {
        c2StopTraversal = c2Intersection && shapecastTraverse(c22, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);
      }
      if (c2StopTraversal)
        return true;
      return false;
    }
  }
}();
var intersectsGeometry = function() {
  const triangle = new SeparatingAxisTriangle();
  const triangle2 = new SeparatingAxisTriangle();
  const invertedMat = new Matrix4();
  const obb3 = new OrientedBox();
  const obb22 = new OrientedBox();
  return function intersectsGeometry2(nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null) {
    let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
    if (cachedObb === null) {
      if (!otherGeometry.boundingBox) {
        otherGeometry.computeBoundingBox();
      }
      obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
      cachedObb = obb3;
    }
    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
    if (isLeaf) {
      const thisGeometry = geometry;
      const thisIndex = thisGeometry.index;
      const thisPos = thisGeometry.attributes.position;
      const index = otherGeometry.index;
      const pos = otherGeometry.attributes.position;
      const offset = OFFSET(nodeIndex32, uint32Array);
      const count = COUNT(nodeIndex16, uint16Array);
      invertedMat.copy(geometryToBvh).invert();
      if (otherGeometry.boundsTree) {
        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb22);
        obb22.matrix.copy(invertedMat);
        obb22.needsUpdate = true;
        const res = otherGeometry.boundsTree.shapecast({
          intersectsBounds: (box) => obb22.intersectsBox(box),
          intersectsTriangle: (tri) => {
            tri.a.applyMatrix4(geometryToBvh);
            tri.b.applyMatrix4(geometryToBvh);
            tri.c.applyMatrix4(geometryToBvh);
            tri.needsUpdate = true;
            for (let i4 = offset * 3, l2 = (count + offset) * 3; i4 < l2; i4 += 3) {
              setTriangle(triangle2, i4, thisIndex, thisPos);
              triangle2.needsUpdate = true;
              if (tri.intersectsTriangle(triangle2)) {
                return true;
              }
            }
            return false;
          }
        });
        return res;
      } else {
        for (let i4 = offset * 3, l2 = count + offset * 3; i4 < l2; i4 += 3) {
          setTriangle(triangle, i4, thisIndex, thisPos);
          triangle.a.applyMatrix4(invertedMat);
          triangle.b.applyMatrix4(invertedMat);
          triangle.c.applyMatrix4(invertedMat);
          triangle.needsUpdate = true;
          for (let i22 = 0, l22 = index.count; i22 < l22; i22 += 3) {
            setTriangle(triangle2, i22, index, pos);
            triangle2.needsUpdate = true;
            if (triangle.intersectsTriangle(triangle2)) {
              return true;
            }
          }
        }
      }
    } else {
      const left = nodeIndex32 + 8;
      const right = uint32Array[nodeIndex32 + 6];
      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
      const leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry2(left, geometry, otherGeometry, geometryToBvh, cachedObb);
      if (leftIntersection)
        return true;
      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
      const rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry2(right, geometry, otherGeometry, geometryToBvh, cachedObb);
      if (rightIntersection)
        return true;
      return false;
    }
  };
}();
function intersectRay(nodeIndex32, array, ray2, target2) {
  arrayToBox(nodeIndex32, array, boundingBox);
  return ray2.intersectBox(boundingBox, target2);
}
var bufferStack = [];
var _prevBuffer;
var _float32Array;
var _uint16Array;
var _uint32Array;
function setBuffer(buffer) {
  if (_prevBuffer) {
    bufferStack.push(_prevBuffer);
  }
  _prevBuffer = buffer;
  _float32Array = new Float32Array(buffer);
  _uint16Array = new Uint16Array(buffer);
  _uint32Array = new Uint32Array(buffer);
}
function clearBuffer() {
  _prevBuffer = null;
  _float32Array = null;
  _uint16Array = null;
  _uint32Array = null;
  if (bufferStack.length) {
    setBuffer(bufferStack.pop());
  }
}

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
var SKIP_GENERATION = Symbol("skip tree generation");
var aabb = new Box3();
var aabb2 = new Box3();
var tempMatrix = new Matrix4();
var obb = new OrientedBox();
var obb2 = new OrientedBox();
var temp = new Vector3();
var temp1 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
var tempBox = new Box3();
var trianglePool = new PrimitivePool(() => new SeparatingAxisTriangle());
var MeshBVH = class {
  static serialize(bvh, options = {}) {
    if (options.isBufferGeometry) {
      console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.");
      return MeshBVH.serialize(arguments[0], {
        cloneBuffers: arguments[2] === void 0 ? true : arguments[2]
      });
    }
    options = __spreadValues({
      cloneBuffers: true
    }, options);
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice()
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    if (typeof options === "boolean") {
      console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.");
      return MeshBVH.deserialize(arguments[0], arguments[1], {
        setIndex: arguments[2] === void 0 ? true : arguments[2]
      });
    }
    options = __spreadValues({
      setIndex: true
    }, options);
    const { index, roots } = data;
    const bvh = new MeshBVH(geometry, __spreadProps(__spreadValues({}, options), { [SKIP_GENERATION]: true }));
    bvh._roots = roots;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === "undefined") {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this._roots = null;
    if (!options[SKIP_GENERATION]) {
      this._roots = buildPackedTree(geometry, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    this.geometry = geometry;
  }
  refit(nodeIndices = null) {
    if (nodeIndices && Array.isArray(nodeIndices)) {
      nodeIndices = new Set(nodeIndices);
    }
    const geometry = this.geometry;
    const indexArr = geometry.index.array;
    const posAttr = geometry.attributes.position;
    const posArr = posAttr.array;
    const bufferOffset = posAttr.offset || 0;
    let stride = 3;
    if (posAttr.isInterleavedBufferAttribute) {
      stride = posAttr.data.stride;
    }
    let buffer, uint32Array, uint16Array, float32Array;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i4 = 0, l2 = roots.length; i4 < l2; i4++) {
      buffer = roots[i4];
      uint32Array = new Uint32Array(buffer);
      uint16Array = new Uint16Array(buffer);
      float32Array = new Float32Array(buffer);
      _traverse(0, byteOffset);
      byteOffset += buffer.byteLength;
    }
    function _traverse(node32Index, byteOffset2, force = false) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        let minx = Infinity;
        let miny = Infinity;
        let minz = Infinity;
        let maxx = -Infinity;
        let maxy = -Infinity;
        let maxz = -Infinity;
        for (let i4 = 3 * offset, l2 = 3 * (offset + count); i4 < l2; i4++) {
          const index = indexArr[i4] * stride + bufferOffset;
          const x = posArr[index + 0];
          const y = posArr[index + 1];
          const z = posArr[index + 2];
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
          float32Array[node32Index + 0] = minx;
          float32Array[node32Index + 1] = miny;
          float32Array[node32Index + 2] = minz;
          float32Array[node32Index + 3] = maxx;
          float32Array[node32Index + 4] = maxy;
          float32Array[node32Index + 5] = maxz;
          return true;
        } else {
          return false;
        }
      } else {
        const left = node32Index + 8;
        const right = uint32Array[node32Index + 6];
        const offsetLeft = left + byteOffset2;
        const offsetRight = right + byteOffset2;
        let forceChildren = force;
        let includesLeft = false;
        let includesRight = false;
        if (nodeIndices) {
          if (!forceChildren) {
            includesLeft = nodeIndices.has(offsetLeft);
            includesRight = nodeIndices.has(offsetRight);
            forceChildren = !includesLeft && !includesRight;
          }
        } else {
          includesLeft = true;
          includesRight = true;
        }
        const traverseLeft = forceChildren || includesLeft;
        const traverseRight = forceChildren || includesRight;
        let leftChange = false;
        if (traverseLeft) {
          leftChange = _traverse(left, byteOffset2, forceChildren);
        }
        let rightChange = false;
        if (traverseRight) {
          rightChange = _traverse(right, byteOffset2, forceChildren);
        }
        const didChange = leftChange || rightChange;
        if (didChange) {
          for (let i4 = 0; i4 < 3; i4++) {
            const lefti = left + i4;
            const righti = right + i4;
            const minLeftValue = float32Array[lefti];
            const maxLeftValue = float32Array[lefti + 3];
            const minRightValue = float32Array[righti];
            const maxRightValue = float32Array[righti + 3];
            float32Array[node32Index + i4] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
            float32Array[node32Index + i4 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
          }
        }
        return didChange;
      }
    }
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse(0);
    function _traverse(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse(left, depth + 1);
          _traverse(right, depth + 1);
        }
      }
    }
  }
  raycast(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    for (let i4 = 0, l2 = roots.length; i4 < l2; i4++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i4].materialIndex].side : side;
      const startCount = intersects.length;
      setBuffer(roots[i4]);
      raycast(0, geometry, materialSide, ray2, intersects);
      clearBuffer();
      if (isArrayMaterial) {
        const materialIndex = groups[i4].materialIndex;
        for (let j = startCount, jl = intersects.length; j < jl; j++) {
          intersects[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects;
  }
  raycastFirst(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    for (let i4 = 0, l2 = roots.length; i4 < l2; i4++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i4].materialIndex].side : side;
      setBuffer(roots[i4]);
      const result = raycastFirst(0, geometry, materialSide, ray2);
      clearBuffer();
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i4].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    const geometry = this.geometry;
    let result = false;
    for (const root of this._roots) {
      setBuffer(root);
      result = intersectsGeometry(0, geometry, otherGeometry, geomToMesh);
      clearBuffer();
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {
    const geometry = this.geometry;
    if (callbacks instanceof Function) {
      if (_intersectsTriangleFunc) {
        const originalTriangleFunc = _intersectsTriangleFunc;
        _intersectsTriangleFunc = (tri, index, contained, depth) => {
          const i32 = index * 3;
          return originalTriangleFunc(tri, i32, i32 + 1, i32 + 2, contained, depth);
        };
      }
      callbacks = {
        boundsTraverseOrder: _orderNodesFunc,
        intersectsBounds: callbacks,
        intersectsTriangle: _intersectsTriangleFunc,
        intersectsRange: null
      };
      console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.");
    }
    const triangle = trianglePool.getPrimitive();
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    for (const root of this._roots) {
      setBuffer(root);
      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      clearBuffer();
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    trianglePool.releasePrimitive(triangle);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const indexAttr = this.geometry.index;
    const positionAttr = this.geometry.attributes.position;
    const otherIndexAttr = otherBvh.geometry.index;
    const otherPositionAttr = otherBvh.geometry.attributes.position;
    tempMatrix.copy(matrixToLocal).invert();
    const triangle = trianglePool.getPrimitive();
    const triangle2 = trianglePool.getPrimitive();
    if (intersectsTriangles) {
      let iterateOverDoubleTriangles = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
        for (let i22 = offset2, l2 = offset2 + count2; i22 < l2; i22++) {
          setTriangle(triangle2, i22 * 3, otherIndexAttr, otherPositionAttr);
          triangle2.a.applyMatrix4(matrixToLocal);
          triangle2.b.applyMatrix4(matrixToLocal);
          triangle2.c.applyMatrix4(matrixToLocal);
          triangle2.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            setTriangle(triangle, i1 * 3, indexAttr, positionAttr);
            triangle.needsUpdate = true;
            if (intersectsTriangles(triangle, triangle2, i1, i22, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    this.getBoundingBox(aabb2);
    aabb2.applyMatrix4(matrixToLocal);
    const result = this.shapecast({
      intersectsBounds: (box) => aabb2.intersectsBox(box),
      intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {
        aabb.copy(box);
        aabb.applyMatrix4(tempMatrix);
        return otherBvh.shapecast({
          intersectsBounds: (box2) => aabb.intersectsBox(box2),
          intersectsRange: (offset2, count2, contained2, depth2, nodeIndex2) => {
            return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);
          }
        });
      }
    });
    trianglePool.releasePrimitive(triangle);
    trianglePool.releasePrimitive(triangle2);
    return result;
  }
  intersectsBox(box, boxToMesh) {
    obb.set(box.min, box.max, boxToMesh);
    obb.needsUpdate = true;
    return this.shapecast({
      intersectsBounds: (box2) => obb.intersectsBox(box2),
      intersectsTriangle: (tri) => obb.intersectsTriangle(tri)
    });
  }
  intersectsSphere(sphere) {
    return this.shapecast({
      intersectsBounds: (box) => sphere.intersectsBox(box),
      intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
    });
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    obb.needsUpdate = true;
    const geometry = this.geometry;
    const pos = geometry.attributes.position;
    const index = geometry.index;
    const otherPos = otherGeometry.attributes.position;
    const otherIndex = otherGeometry.index;
    const triangle = trianglePool.getPrimitive();
    const triangle2 = trianglePool.getPrimitive();
    let tempTarget1 = temp1;
    let tempTargetDest1 = temp2;
    let tempTarget2 = null;
    let tempTargetDest2 = null;
    if (target2) {
      tempTarget2 = temp3;
      tempTargetDest2 = temp4;
    }
    let closestDistance = Infinity;
    let closestDistanceTriIndex = null;
    let closestDistanceOtherTriIndex = null;
    tempMatrix.copy(geometryToBvh).invert();
    obb2.matrix.copy(tempMatrix);
    this.shapecast({
      boundsTraverseOrder: (box) => {
        return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2.min.copy(box.min);
            obb2.max.copy(box.max);
            obb2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          return otherGeometry.boundsTree.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i22 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i22 < l2; i22 += 3) {
                setTriangle(triangle2, i22, otherIndex, otherPos);
                triangle2.a.applyMatrix4(geometryToBvh);
                triangle2.b.applyMatrix4(geometryToBvh);
                triangle2.c.applyMatrix4(geometryToBvh);
                triangle2.needsUpdate = true;
                for (let i4 = offset * 3, l3 = (offset + count) * 3; i4 < l3; i4 += 3) {
                  setTriangle(triangle, i4, index, pos);
                  triangle.needsUpdate = true;
                  const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i4 / 3;
                    closestDistanceOtherTriIndex = i22 / 3;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = otherIndex ? otherIndex.count : otherPos.count;
          for (let i22 = 0, l2 = triCount; i22 < l2; i22 += 3) {
            setTriangle(triangle2, i22, otherIndex, otherPos);
            triangle2.a.applyMatrix4(geometryToBvh);
            triangle2.b.applyMatrix4(geometryToBvh);
            triangle2.c.applyMatrix4(geometryToBvh);
            triangle2.needsUpdate = true;
            for (let i4 = offset * 3, l3 = (offset + count) * 3; i4 < l3; i4 += 3) {
              setTriangle(triangle, i4, index, pos);
              triangle.needsUpdate = true;
              const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i4 / 3;
                closestDistanceOtherTriIndex = i22 / 3;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    });
    trianglePool.releasePrimitive(triangle);
    trianglePool.releasePrimitive(triangle2);
    if (closestDistance === Infinity)
      return null;
    if (!target1.point)
      target1.point = tempTargetDest1.clone();
    else
      target1.point.copy(tempTargetDest1);
    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
    if (target2) {
      if (!target2.point)
        target2.point = tempTargetDest2.clone();
      else
        target2.point.copy(tempTargetDest2);
      target2.point.applyMatrix4(tempMatrix);
      tempTargetDest1.applyMatrix4(tempMatrix);
      target2.distance = tempTargetDest1.sub(target2.point).length();
      target2.faceIndex = closestDistanceOtherTriIndex;
    }
    return target1;
  }
  closestPointToPoint(point, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const minThresholdSq = minThreshold * minThreshold;
    const maxThresholdSq = maxThreshold * maxThreshold;
    let closestDistanceSq = Infinity;
    let closestDistanceTriIndex = null;
    this.shapecast({
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    });
    if (closestDistanceSq === Infinity)
      return null;
    const closestDistance = Math.sqrt(closestDistanceSq);
    if (!target2.point)
      target2.point = temp1.clone();
    else
      target2.point.copy(temp1);
    target2.distance = closestDistance, target2.faceIndex = closestDistanceTriIndex;
    return target2;
  }
  getBoundingBox(target2) {
    target2.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target2.union(tempBox);
    });
    return target2;
  }
};
var originalRaycast = MeshBVH.prototype.raycast;
MeshBVH.prototype.raycast = function(...args) {
  if (args[0].isMesh) {
    console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');
    const [
      mesh,
      raycaster,
      ray2,
      intersects
    ] = args;
    const results = originalRaycast.call(this, ray2, mesh.material);
    results.forEach((hit) => {
      hit = convertRaycastIntersect(hit, mesh, raycaster);
      if (hit) {
        intersects.push(hit);
      }
    });
    return intersects;
  } else {
    return originalRaycast.apply(this, args);
  }
};
var originalRaycastFirst = MeshBVH.prototype.raycastFirst;
MeshBVH.prototype.raycastFirst = function(...args) {
  if (args[0].isMesh) {
    console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');
    const [
      mesh,
      raycaster,
      ray2
    ] = args;
    return convertRaycastIntersect(originalRaycastFirst.call(this, ray2, mesh.material), mesh, raycaster);
  } else {
    return originalRaycastFirst.apply(this, args);
  }
};
var originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;
MeshBVH.prototype.closestPointToPoint = function(...args) {
  if (args[0].isMesh) {
    console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.');
    args.unshift();
    const target2 = args[1];
    const result = {};
    args[1] = result;
    originalClosestPointToPoint.apply(this, args);
    if (target2) {
      target2.copy(result.point);
    }
    return result.distance;
  } else {
    return originalClosestPointToPoint.apply(this, args);
  }
};
var originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;
MeshBVH.prototype.closestPointToGeometry = function(...args) {
  const target1 = args[2];
  const target2 = args[3];
  if (target1 && target1.isVector3 || target2 && target2.isVector3) {
    console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');
    const result1 = {};
    const result2 = {};
    const geometryToBvh = args[1];
    args[2] = result1;
    args[3] = result2;
    originalClosestPointToGeometry.apply(this, args);
    if (target1) {
      target1.copy(result1.point);
    }
    if (target2) {
      target2.copy(result2.point).applyMatrix4(geometryToBvh);
    }
    return result1.distance;
  } else {
    return originalClosestPointToGeometry.apply(this, args);
  }
};
var originalRefit = MeshBVH.prototype.refit;
MeshBVH.prototype.refit = function(...args) {
  const nodeIndices = args[0];
  const terminationIndices = args[1];
  if (terminationIndices && (terminationIndices instanceof Set || Array.isArray(terminationIndices))) {
    console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');
    const newNodeIndices = new Set();
    terminationIndices.forEach((v4) => newNodeIndices.add(v4));
    if (nodeIndices) {
      nodeIndices.forEach((v4) => newNodeIndices.add(v4));
    }
    originalRefit.call(this, newNodeIndices);
  } else {
    originalRefit.apply(this, args);
  }
};
[
  "intersectsGeometry",
  "shapecast",
  "intersectsBox",
  "intersectsSphere"
].forEach((name) => {
  const originalFunc = MeshBVH.prototype[name];
  MeshBVH.prototype[name] = function(...args) {
    if (args[0] === null || args[0].isMesh) {
      args.shift();
      console.warn(`MeshBVH: The function signature for "${name}" has changed and no longer takes Mesh. See docs for new signature.`);
    }
    return originalFunc.apply(this, args);
  };
});

// node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js
var boundingBox2 = new Box3();

// node_modules/three-mesh-bvh/src/debug/Debug.js
var _box1 = new Box3();
var _box2 = new Box3();
var _vec = new Vector3();

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
var ray = new Ray();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;
function acceleratedRaycast(raycaster, intersects) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);
      if (hit) {
        intersects.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material);
      for (let i4 = 0, l2 = hits.length; i4 < l2; i4++) {
        const hit = convertRaycastIntersect(hits[i4], this, raycaster);
        if (hit) {
          intersects.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects);
  }
}
function computeBoundsTree(options) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}

// node_modules/@react-three/drei/core/useBVH.js
function useBVH(mesh, options) {
  React42.useEffect(() => {
    if (mesh.current) {
      mesh.current.raycast = acceleratedRaycast;
      const geometry = mesh.current.geometry;
      geometry.computeBoundsTree = computeBoundsTree;
      geometry.disposeBoundsTree = disposeBoundsTree;
      geometry.computeBoundsTree(options);
      return () => {
        if (geometry.boundsTree) {
          geometry.disposeBoundsTree();
        }
      };
    }
  }, [mesh, options]);
}

// node_modules/@react-three/drei/core/useContextBridge.js
var React43 = __toModule(require_react());
function useContextBridge(...contexts) {
  const cRef = React43.useRef([]);
  cRef.current = contexts.map((context7) => React43.useContext(context7));
  return React43.useMemo(() => ({
    children
  }) => contexts.reduceRight((acc, Context2, i4) => React43.createElement(Context2.Provider, {
    value: cRef.current[i4],
    children: acc
  }), children), []);
}

// node_modules/@react-three/drei/core/useAnimations.js
var React44 = __toModule(require_react());
function useAnimations(clips, root) {
  const ref = React44.useRef();
  const [actualRef] = React44.useState(() => root ? root instanceof Object3D ? {
    current: root
  } : root : ref);
  const [mixer] = React44.useState(() => new AnimationMixer(void 0));
  const lazyActions = React44.useRef({});
  const [api] = React44.useState(() => {
    const actions = {};
    clips.forEach((clip) => Object.defineProperty(actions, clip.name, {
      enumerable: true,
      get() {
        if (actualRef.current) {
          return lazyActions.current[clip.name] || (lazyActions.current[clip.name] = mixer.clipAction(clip, actualRef.current));
        }
      }
    }));
    return {
      ref: actualRef,
      clips,
      actions,
      names: clips.map((c6) => c6.name),
      mixer
    };
  });
  useFrame((state, delta) => mixer.update(delta));
  React44.useEffect(() => {
    const currentRoot = actualRef.current;
    return () => {
      lazyActions.current = {};
      Object.values(api.actions).forEach((action) => {
        if (currentRoot) {
          mixer.uncacheAction(action, currentRoot);
        }
      });
    };
  }, [clips]);
  return api;
}

// node_modules/@react-three/drei/core/useIntersect.js
var React45 = __toModule(require_react());
function useIntersect(onChange) {
  const ref = React45.useRef(null);
  const check = React45.useRef(false);
  const temp5 = React45.useRef(false);
  React45.useEffect(() => {
    const obj = ref.current;
    if (obj) {
      const unsub1 = addEffect(() => {
        check.current = false;
        return true;
      });
      const oldOnRender = obj.onBeforeRender;
      obj.onBeforeRender = () => check.current = true;
      const unsub2 = addAfterEffect(() => {
        if (check.current !== temp5.current)
          onChange(temp5.current = check.current);
        return true;
      });
      return () => {
        obj.onBeforeRender = oldOnRender;
        unsub1();
        unsub2();
      };
    }
  }, []);
  return ref;
}

// node_modules/@react-three/drei/core/CurveModifier.js
var React46 = __toModule(require_react());
var CurveModifier = React46.forwardRef(({
  children,
  curve
}, ref) => {
  const [object3D, setObj] = React46.useState();
  const original = React46.useRef();
  const modifier = React46.useRef();
  React46.useImperativeHandle(ref, () => ({
    moveAlongCurve: (val) => {
      var _modifier$current;
      (_modifier$current = modifier.current) == null ? void 0 : _modifier$current.moveAlongCurve(val);
    }
  }));
  React46.useEffect(() => {
    if (!modifier.current && original.current && ref) {
      modifier.current = new Flow(original.current);
      setObj(modifier.current.object3D);
    }
  }, [children, ref]);
  React46.useEffect(() => {
    if (original.current && curve) {
      var _modifier$current2;
      (_modifier$current2 = modifier.current) == null ? void 0 : _modifier$current2.updateCurve(0, curve);
    }
  }, [curve]);
  return object3D ? React46.createElement("primitive", {
    object: object3D
  }) : React46.cloneElement(React46.Children.only(children), {
    ref: original
  });
});

// node_modules/@react-three/drei/core/MeshDistortMaterial.js
var React47 = __toModule(require_react());

// node_modules/@react-three/drei/helpers/glsl/distort.vert.glsl.js
var distort = "#define GLSLIFY 1\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}";

// node_modules/@react-three/drei/core/MeshDistortMaterial.js
var DistortMaterialImpl = class extends MeshPhysicalMaterial {
  constructor(parameters = {}) {
    super(parameters);
    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._distort = {
      value: 0.4
    };
    this._radius = {
      value: 1
    };
  }
  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.radius = this._radius;
    shader.uniforms.distort = this._distort;
    shader.vertexShader = `
      uniform float time;
      uniform float radius;
      uniform float distort;
      ${distort}
      ${shader.vertexShader}
    `;
    shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `
        float updateTime = time / 50.0;
        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));
        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));
        `);
  }
  get time() {
    return this._time.value;
  }
  set time(v4) {
    this._time.value = v4;
  }
  get distort() {
    return this._distort.value;
  }
  set distort(v4) {
    this._distort.value = v4;
  }
  get radius() {
    return this._radius.value;
  }
  set radius(v4) {
    this._radius.value = v4;
  }
};
var MeshDistortMaterial = React47.forwardRef((_a, ref) => {
  var _b = _a, {
    speed = 1
  } = _b, props = __objRest(_b, [
    "speed"
  ]);
  const [material] = React47.useState(() => new DistortMaterialImpl());
  useFrame((state) => material && (material.time = state.clock.getElapsedTime() * speed));
  return React47.createElement("primitive", _extends({
    dispose: void 0,
    object: material,
    ref,
    attach: "material"
  }, props));
});

// node_modules/@react-three/drei/core/MeshWobbleMaterial.js
var React48 = __toModule(require_react());
var WobbleMaterialImpl = class extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);
    this.setValues(parameters);
    this._time = {
      value: 0
    };
    this._factor = {
      value: 1
    };
  }
  onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = `
      uniform float time;
      uniform float factor;
      ${shader.vertexShader}
    `;
    shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", `float theta = sin( time + position.y ) / 2.0 * factor;
        float c = cos( theta );
        float s = sin( theta );
        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
        vec3 transformed = vec3( position ) * m;
        vNormal = vNormal * m;`);
  }
  get time() {
    return this._time.value;
  }
  set time(v4) {
    this._time.value = v4;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(v4) {
    this._factor.value = v4;
  }
};
var MeshWobbleMaterial = React48.forwardRef((_a, ref) => {
  var _b = _a, {
    speed = 1
  } = _b, props = __objRest(_b, [
    "speed"
  ]);
  const [material] = React48.useState(() => new WobbleMaterialImpl());
  useFrame((state) => material && (material.time = state.clock.getElapsedTime() * speed));
  return React48.createElement("primitive", _extends({
    dispose: void 0,
    object: material,
    ref,
    attach: "material"
  }, props));
});

// node_modules/@react-three/drei/core/MeshReflectorMaterial.js
var React49 = __toModule(require_react());

// node_modules/@react-three/drei/materials/ConvolutionMaterial.js
var ConvolutionMaterial = class extends ShaderMaterial {
  constructor(texelSize = new Vector2()) {
    super({
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        halfTexelSize: new Uniform(new Vector2()),
        kernel: new Uniform(0),
        scale: new Uniform(1),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(1),
        minDepthThreshold: new Uniform(0),
        maxDepthThreshold: new Uniform(1),
        depthScale: new Uniform(0),
        depthToBlurRatioBias: new Uniform(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false
    });
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
  }
  setResolution(resolution) {
    this.uniforms.resolution.value.copy(resolution);
  }
};

// node_modules/@react-three/drei/materials/BlurPass.js
var BlurPass = class {
  constructor({
    gl,
    resolution,
    width = 500,
    height = 500,
    minDepthThreshold = 0,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25
  }) {
    this.renderToScreen = false;
    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer: false,
      depthBuffer: false,
      encoding: gl.outputEncoding
    });
    this.renderTargetB = this.renderTargetA.clone();
    this.convolutionMaterial = new ConvolutionMaterial();
    this.convolutionMaterial.setTexelSize(1 / width, 1 / height);
    this.convolutionMaterial.setResolution(new Vector2(width, height));
    this.scene = new Scene();
    this.camera = new Camera();
    this.convolutionMaterial.uniforms.minDepthThreshold.value = minDepthThreshold;
    this.convolutionMaterial.uniforms.maxDepthThreshold.value = maxDepthThreshold;
    this.convolutionMaterial.uniforms.depthScale.value = depthScale;
    this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = depthToBlurRatioBias;
    this.convolutionMaterial.defines.USE_DEPTH = depthScale > 0;
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new BufferAttribute(vertices, 3));
    geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
    this.screen = new Mesh(geometry, this.convolutionMaterial);
    this.screen.frustumCulled = false;
    this.scene.add(this.screen);
  }
  render(renderer, inputBuffer, outputBuffer) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    let material = this.convolutionMaterial;
    let uniforms = material.uniforms;
    uniforms.depthBuffer.value = inputBuffer.depthTexture;
    const kernel = material.kernel;
    let lastRT = inputBuffer;
    let destRT;
    let i4, l2;
    for (i4 = 0, l2 = kernel.length - 1; i4 < l2; ++i4) {
      destRT = (i4 & 1) === 0 ? renderTargetA : renderTargetB;
      uniforms.kernel.value = kernel[i4];
      uniforms.inputBuffer.value = lastRT.texture;
      renderer.setRenderTarget(destRT);
      renderer.render(scene, camera);
      lastRT = destRT;
    }
    uniforms.kernel.value = kernel[i4];
    uniforms.inputBuffer.value = lastRT.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
};

// node_modules/@react-three/drei/materials/MeshReflectorMaterial.js
var MeshReflectorMaterial = class extends MeshStandardMaterial {
  constructor(parameters = {}) {
    super(parameters);
    this._debug = {
      value: 0
    };
    this._tDepth = {
      value: null
    };
    this._distortionMap = {
      value: null
    };
    this._tDiffuse = {
      value: null
    };
    this._tDiffuseBlur = {
      value: null
    };
    this._textureMatrix = {
      value: null
    };
    this._hasBlur = {
      value: false
    };
    this._mirror = {
      value: 0
    };
    this._mixBlur = {
      value: 0
    };
    this._blurStrength = {
      value: 0.5
    };
    this._minDepthThreshold = {
      value: 0.9
    };
    this._maxDepthThreshold = {
      value: 1
    };
    this._depthScale = {
      value: 0
    };
    this._depthToBlurRatioBias = {
      value: 0.25
    };
    this._distortion = {
      value: 1
    };
    this._mixContrast = {
      value: 1
    };
    this.setValues(parameters);
  }
  onBeforeCompile(shader) {
    var _shader$defines;
    if (!((_shader$defines = shader.defines) != null && _shader$defines.USE_UV)) {
      shader.defines.USE_UV = "";
    }
    shader.uniforms.debug = this._debug;
    shader.uniforms.hasBlur = this._hasBlur;
    shader.uniforms.tDiffuse = this._tDiffuse;
    shader.uniforms.tDepth = this._tDepth;
    shader.uniforms.distortionMap = this._distortionMap;
    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;
    shader.uniforms.textureMatrix = this._textureMatrix;
    shader.uniforms.mirror = this._mirror;
    shader.uniforms.mixBlur = this._mixBlur;
    shader.uniforms.mixStrength = this._blurStrength;
    shader.uniforms.minDepthThreshold = this._minDepthThreshold;
    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;
    shader.uniforms.depthScale = this._depthScale;
    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;
    shader.uniforms.distortion = this._distortion;
    shader.uniforms.mixContrast = this._mixContrast;
    shader.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;     
      ${shader.vertexShader}`;
    shader.vertexShader = shader.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`);
    shader.fragmentShader = `
        uniform int debug;
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;        
        ${shader.fragmentShader}`;
    shader.fragmentShader = shader.fragmentShader.replace("#include <emissivemap_fragment>", `#include <emissivemap_fragment>
    
      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);
      
      vec4 merge = base;
      
      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif
  
      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif
      
      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);           
      diffuseColor = sRGBToLinear(diffuseColor);
      
      if (debug == 1) {
        diffuseColor = sRGBToLinear(vec4(vec3(depthFactor), 1.0));
      }
      if (debug == 2) {
        diffuseColor = sRGBToLinear(vec4(vec3(blurFactor), 1.0));
      }
      if (debug == 3) {
        diffuseColor = sRGBToLinear(texture2DProj(tDiffuse, new_vUv));
      }
      if (debug == 4) {
        diffuseColor = sRGBToLinear(texture2DProj(tDiffuseBlur, new_vUv));
      }
      `);
  }
  get tDiffuse() {
    return this._tDiffuse.value;
  }
  set tDiffuse(v4) {
    this._tDiffuse.value = v4;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(v4) {
    this._tDepth.value = v4;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(v4) {
    this._distortionMap.value = v4;
  }
  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }
  set tDiffuseBlur(v4) {
    this._tDiffuseBlur.value = v4;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(v4) {
    this._textureMatrix.value = v4;
  }
  get hasBlur() {
    return this._hasBlur.value;
  }
  set hasBlur(v4) {
    this._hasBlur.value = v4;
  }
  get mirror() {
    return this._mirror.value;
  }
  set mirror(v4) {
    this._mirror.value = v4;
  }
  get mixBlur() {
    return this._mixBlur.value;
  }
  set mixBlur(v4) {
    this._mixBlur.value = v4;
  }
  get mixStrength() {
    return this._blurStrength.value;
  }
  set mixStrength(v4) {
    this._blurStrength.value = v4;
  }
  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }
  set minDepthThreshold(v4) {
    this._minDepthThreshold.value = v4;
  }
  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }
  set maxDepthThreshold(v4) {
    this._maxDepthThreshold.value = v4;
  }
  get depthScale() {
    return this._depthScale.value;
  }
  set depthScale(v4) {
    this._depthScale.value = v4;
  }
  get debug() {
    return this._debug.value;
  }
  set debug(v4) {
    this._debug.value = v4;
  }
  get depthToBlurRatioBias() {
    return this._depthToBlurRatioBias.value;
  }
  set depthToBlurRatioBias(v4) {
    this._depthToBlurRatioBias.value = v4;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(v4) {
    this._distortion.value = v4;
  }
  get mixContrast() {
    return this._mixContrast.value;
  }
  set mixContrast(v4) {
    this._mixContrast.value = v4;
  }
};

// node_modules/@react-three/drei/core/MeshReflectorMaterial.js
extend({
  MeshReflectorMaterialImpl: MeshReflectorMaterial
});
var MeshReflectorMaterial2 = React49.forwardRef((_a, ref) => {
  var _b = _a, {
    mixBlur = 0,
    mixStrength = 1,
    resolution = 256,
    blur = [0, 0],
    minDepthThreshold = 0.9,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25,
    mirror = 0,
    debug = 0,
    distortion = 1,
    mixContrast = 1,
    distortionMap
  } = _b, props = __objRest(_b, [
    "mixBlur",
    "mixStrength",
    "resolution",
    "blur",
    "minDepthThreshold",
    "maxDepthThreshold",
    "depthScale",
    "depthToBlurRatioBias",
    "mirror",
    "debug",
    "distortion",
    "mixContrast",
    "distortionMap"
  ]);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  blur = Array.isArray(blur) ? blur : [blur, blur];
  const hasBlur = blur[0] + blur[1] > 0;
  const materialRef = React49.useRef(null);
  const [reflectorPlane] = React49.useState(() => new Plane());
  const [normal] = React49.useState(() => new Vector3());
  const [reflectorWorldPosition] = React49.useState(() => new Vector3());
  const [cameraWorldPosition] = React49.useState(() => new Vector3());
  const [rotationMatrix] = React49.useState(() => new Matrix4());
  const [lookAtPosition] = React49.useState(() => new Vector3(0, 0, -1));
  const [clipPlane] = React49.useState(() => new Vector4());
  const [view] = React49.useState(() => new Vector3());
  const [target2] = React49.useState(() => new Vector3());
  const [q] = React49.useState(() => new Vector4());
  const [textureMatrix] = React49.useState(() => new Matrix4());
  const [virtualCamera] = React49.useState(() => new PerspectiveCamera());
  const beforeRender = React49.useCallback(() => {
    var _materialRef$current;
    const parent = materialRef.current.parent || ((_materialRef$current = materialRef.current) == null ? void 0 : _materialRef$current.__r3f.parent);
    if (!parent)
      return;
    reflectorWorldPosition.setFromMatrixPosition(parent.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(parent.matrixWorld);
    normal.set(0, 0, 1);
    normal.applyMatrix4(rotationMatrix);
    view.subVectors(reflectorWorldPosition, cameraWorldPosition);
    if (view.dot(normal) > 0)
      return;
    view.reflect(normal).negate();
    view.add(reflectorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target2.subVectors(reflectorWorldPosition, lookAtPosition);
    target2.reflect(normal).negate();
    target2.add(reflectorWorldPosition);
    virtualCamera.position.copy(view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(rotationMatrix);
    virtualCamera.up.reflect(normal);
    virtualCamera.lookAt(target2);
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    textureMatrix.multiply(virtualCamera.projectionMatrix);
    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
    textureMatrix.multiply(parent.matrixWorld);
    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1;
    q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(2 / clipPlane.dot(q));
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1;
    projectionMatrix.elements[14] = clipPlane.w;
  }, [camera]);
  const [fbo1, fbo2, blurpass, reflectorProps] = React49.useMemo(() => {
    const parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat,
      encoding: gl.outputEncoding
    };
    const fbo12 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo12.depthBuffer = true;
    fbo12.depthTexture = new DepthTexture(resolution, resolution);
    fbo12.depthTexture.format = DepthFormat;
    fbo12.depthTexture.type = UnsignedShortType;
    const fbo22 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass2 = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1],
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias
    });
    const reflectorProps2 = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo12.texture,
      tDepth: fbo12.depthTexture,
      tDiffuseBlur: fbo22.texture,
      hasBlur,
      mixStrength,
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias,
      transparent: true,
      debug,
      distortion,
      distortionMap,
      mixContrast,
      "defines-USE_BLUR": hasBlur ? "" : void 0,
      "defines-USE_DEPTH": depthScale > 0 ? "" : void 0,
      "defines-USE_DISTORTION": distortionMap ? "" : void 0
    };
    return [fbo12, fbo22, blurpass2, reflectorProps2];
  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, debug, distortion, distortionMap, mixContrast]);
  useFrame(() => {
    var _materialRef$current2;
    const parent = materialRef.current.parent || ((_materialRef$current2 = materialRef.current) == null ? void 0 : _materialRef$current2.__r3f.parent);
    if (!parent)
      return;
    parent.visible = false;
    const currentXrEnabled = gl.xr.enabled;
    const currentShadowAutoUpdate = gl.shadowMap.autoUpdate;
    beforeRender();
    gl.xr.enabled = false;
    gl.shadowMap.autoUpdate = false;
    gl.setRenderTarget(fbo1);
    gl.state.buffers.depth.setMask(true);
    if (!gl.autoClear)
      gl.clear();
    gl.render(scene, virtualCamera);
    if (hasBlur)
      blurpass.render(gl, fbo1, fbo2);
    gl.xr.enabled = currentXrEnabled;
    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;
    parent.visible = true;
    gl.setRenderTarget(null);
  });
  return React49.createElement("meshReflectorMaterialImpl", _extends({
    attach: "material",
    key: "key" + reflectorProps["defines-USE_BLUR"] + reflectorProps["defines-USE_DEPTH"] + reflectorProps["defines-USE_DISTORTION"],
    ref: react_merge_refs_esm_default([materialRef, ref])
  }, reflectorProps, props));
});

// node_modules/@react-three/drei/core/PointMaterial.js
var React50 = __toModule(require_react());
var PointMaterialImpl = class extends ShaderMaterial {
  constructor() {
    super({
      transparent: true,
      uniforms: {
        size: {
          value: 1
        }
      },
      vertexShader: ShaderLib.points.vertexShader,
      fragmentShader: `
      varying vec3 vColor;
      void main() {
        vec2 cxy = 2.0 * gl_PointCoord - 1.0;
        float r = dot(cxy, cxy);
        float delta = fwidth(r);
        vec3 color = vColor;
        #ifdef TONE_MAPPING
          color = toneMapping(color);
        #endif
        gl_FragColor = linearToOutputTexel(vec4(color, 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r)));
      }`,
      vertexColors: true
    });
  }
  get scale() {
    return this.uniforms.size.value;
  }
  set scale(v4) {
    this.uniforms.size.value = v4;
  }
};
var PointMaterial = React50.forwardRef((props, ref) => {
  const [material] = React50.useState(() => new PointMaterialImpl());
  return React50.createElement("primitive", _extends({
    object: material,
    ref,
    attach: "material"
  }, props));
});

// node_modules/@react-three/drei/core/softShadows.js
var pcss = ({
  frustum = 3.75,
  size = 5e-3,
  near = 9.5,
  samples = 17,
  rings = 11
} = {}) => `#define LIGHT_WORLD_SIZE ${size}
#define LIGHT_FRUSTUM_WIDTH ${frustum}
#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)
#define NEAR_PLANE ${near}

#define NUM_SAMPLES ${samples}
#define NUM_RINGS ${rings}
#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES
#define PCF_NUM_SAMPLES NUM_SAMPLES

vec2 poissonDisk[NUM_SAMPLES];

void initPoissonSamples(const in vec2 randomSeed) {
  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);
  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);
  float angle = rand(randomSeed) * PI2;
  float radius = INV_NUM_SAMPLES;
  float radiusStep = radius;
  for (int i = 0; i < NUM_SAMPLES; i++) {
    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);
    radius += radiusStep;
    angle += ANGLE_STEP;
  }
}

float penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation
  return (zReceiver - zBlocker) / zBlocker;
}

float findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {
  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;
  float blockerDepthSum = 0.0;
  int numBlockers = 0;
  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {
    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
    if (shadowMapDepth < zReceiver) {
      blockerDepthSum += shadowMapDepth;
      numBlockers++;
    }
  }
  if (numBlockers == 0) return -1.0;
  return blockerDepthSum / float(numBlockers);
}

float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {
  float sum = 0.0;
  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {
    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));
    if (zReceiver <= depth) sum += 1.0;
  }
  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {
    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));
    if (zReceiver <= depth) sum += 1.0;
  }
  return sum / (2.0 * float(PCF_NUM_SAMPLES));
}

float PCSS(sampler2D shadowMap, vec4 coords) {
  vec2 uv = coords.xy;
  float zReceiver = coords.z; // Assumed to be eye-space z in this code
  initPoissonSamples(uv);
  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);
  if (avgBlockerDepth == -1.0) return 1.0;
  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;
  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);
}`;
var deployed = false;
var softShadows = (props) => {
  if (!deployed) {
    deployed = true;
    let shader = ShaderChunk.shadowmap_pars_fragment;
    shader = shader.replace("#ifdef USE_SHADOWMAP", "#ifdef USE_SHADOWMAP\n" + pcss(__spreadValues({}, props)));
    shader = shader.replace("#if defined( SHADOWMAP_TYPE_PCF )", "\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )");
    ShaderChunk.shadowmap_pars_fragment = shader;
  }
};

// node_modules/@react-three/drei/core/shapes.js
var React51 = __toModule(require_react());
function create2(type) {
  const El = type + "BufferGeometry";
  return React51.forwardRef((_a, ref) => {
    var _b = _a, {
      args,
      children
    } = _b, props = __objRest(_b, [
      "args",
      "children"
    ]);
    return React51.createElement("mesh", _extends({
      ref
    }, props), React51.createElement(El, {
      attach: "geometry",
      args
    }), children);
  });
}
var Box = create2("box");
var Circle = create2("circle");
var Cone = create2("cone");
var Cylinder = create2("cylinder");
var Sphere2 = create2("sphere");
var Plane2 = create2("plane");
var Tube = create2("tube");
var Torus = create2("torus");
var TorusKnot = create2("torusKnot");
var Tetrahedron = create2("tetrahedron");
var Ring = create2("ring");
var Polyhedron = create2("polyhedron");
var Icosahedron = create2("icosahedron");
var Octahedron = create2("octahedron");
var Dodecahedron = create2("dodecahedron");
var Extrude = create2("extrude");
var Lathe = create2("lathe");

// node_modules/@react-three/drei/core/RoundedBox.js
var React52 = __toModule(require_react());
var eps = 1e-5;
function createShape(width, height, radius0) {
  const shape = new Shape();
  const radius = radius0 - eps;
  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
  shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
  shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
  return shape;
}
var RoundedBox = React52.forwardRef(function RoundedBox2(_a, ref) {
  var _b = _a, {
    args: [width = 1, height = 1, depth = 1] = [],
    radius = 0.05,
    smoothness = 4,
    children
  } = _b, rest = __objRest(_b, [
    "args",
    "radius",
    "smoothness",
    "children"
  ]);
  const shape = React52.useMemo(() => createShape(width, height, radius), [width, height, radius]);
  const params = React52.useMemo(() => ({
    depth: depth - radius * 2,
    bevelEnabled: true,
    bevelSegments: smoothness * 2,
    steps: 1,
    bevelSize: radius - eps,
    bevelThickness: radius,
    curveSegments: smoothness
  }), [depth, radius, smoothness]);
  const geomRef = React52.useRef();
  React52.useLayoutEffect(() => {
    if (geomRef.current) {
      geomRef.current.center();
    }
  }, [shape, params]);
  return React52.createElement("mesh", _extends({
    ref
  }, rest), React52.createElement("extrudeBufferGeometry", {
    attach: "geometry",
    ref: geomRef,
    args: [shape, params]
  }), children);
});

// node_modules/@react-three/drei/core/ScreenQuad.js
var React53 = __toModule(require_react());
function createScreenQuadGeometry() {
  const geometry = new BufferGeometry();
  const vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
  geometry.setAttribute("position", new BufferAttribute(vertices, 2));
  return geometry;
}
var ScreenQuad = React53.forwardRef(function ScreenQuad2(_a, ref) {
  var _b = _a, {
    children
  } = _b, restProps = __objRest(_b, [
    "children"
  ]);
  const geometry = React53.useMemo(createScreenQuadGeometry, []);
  return React53.createElement("mesh", _extends({
    ref,
    geometry,
    frustumCulled: false
  }, restProps), children);
});

// node_modules/@react-three/drei/core/Center.js
var React54 = __toModule(require_react());
var Center = React54.forwardRef(function Center2(_a, ref) {
  var _b = _a, {
    children,
    alignTop
  } = _b, props = __objRest(_b, [
    "children",
    "alignTop"
  ]);
  const outer = React54.useRef(null);
  const inner = React54.useRef(null);
  React54.useLayoutEffect(() => {
    outer.current.position.set(0, 0, 0);
    outer.current.updateWorldMatrix(true, true);
    const box3 = new Box3().setFromObject(inner.current);
    const center = new Vector3();
    const sphere = new Sphere();
    const height = box3.max.y - box3.min.y;
    box3.getCenter(center);
    box3.getBoundingSphere(sphere);
    outer.current.position.set(-center.x, -center.y + (alignTop ? height / 2 : 0), -center.z);
  }, [children]);
  return React54.createElement("group", _extends({
    ref
  }, props), React54.createElement("group", {
    ref: outer
  }, React54.createElement("group", {
    ref: inner
  }, children)));
});

// node_modules/@react-three/drei/core/Bounds.js
var React55 = __toModule(require_react());
var isOrthographic = (def) => def && def.isOrthographicCamera;
var isObject3D = (def) => def && def.isObject3D;
var isBox3 = (def) => def && def.isBox3;
var context4 = React55.createContext(null);
function Bounds({
  children,
  damping = 6,
  fit,
  clip,
  margin = 1.2,
  eps: eps2 = 0.01,
  onFit
}) {
  const ref = React55.useRef(null);
  const camera = useThree((state) => state.camera);
  const controls = useThree((state) => state.controls);
  const invalidate = useThree((state) => state.invalidate);
  const onFitRef = React55.useRef(onFit);
  onFitRef.current = onFit;
  function equals(a2, b) {
    return Math.abs(a2.x - b.x) < eps2 && Math.abs(a2.y - b.y) < eps2 && Math.abs(a2.z - b.z) < eps2;
  }
  function damp(v4, t2, lambda, delta) {
    v4.x = MathUtils.damp(v4.x, t2.x, lambda, delta);
    v4.y = MathUtils.damp(v4.y, t2.y, lambda, delta);
    v4.z = MathUtils.damp(v4.z, t2.z, lambda, delta);
  }
  const [current] = React55.useState(() => ({
    animating: false,
    focus: new Vector3(),
    camera: new Vector3(),
    zoom: 1
  }));
  const [goal] = React55.useState(() => ({
    focus: new Vector3(),
    camera: new Vector3(),
    zoom: 1
  }));
  const [box] = React55.useState(() => new Box3());
  const api = React55.useMemo(() => {
    function getSize() {
      const size = box.getSize(new Vector3());
      const center = box.getCenter(new Vector3());
      const maxSize = Math.max(size.x, size.y, size.z);
      const fitHeightDistance = isOrthographic(camera) ? maxSize * 4 : maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
      const fitWidthDistance = isOrthographic(camera) ? maxSize * 4 : fitHeightDistance / camera.aspect;
      const distance = margin * Math.max(fitHeightDistance, fitWidthDistance);
      return {
        box,
        size,
        center,
        distance
      };
    }
    return {
      getSize,
      refresh(object) {
        if (isObject3D(object))
          box.setFromObject(object);
        else if (isBox3(object))
          box.copy(object);
        else if (ref.current)
          box.setFromObject(ref.current);
        if (box.isEmpty()) {
          const max = camera.position.length() || 10;
          box.setFromCenterAndSize(new Vector3(), new Vector3(max, max, max));
        }
        if ((controls == null ? void 0 : controls.constructor.name) === "OrthographicTrackballControls") {
          const {
            distance
          } = getSize();
          const direction = camera.position.clone().sub(controls.target).normalize().multiplyScalar(distance);
          const newPos = controls.target.clone().add(direction);
          camera.position.copy(newPos);
        }
        return this;
      },
      clip() {
        const {
          distance
        } = getSize();
        if (controls)
          controls.maxDistance = distance * 10;
        camera.near = distance / 100;
        camera.far = distance * 100;
        camera.updateProjectionMatrix();
        if (controls)
          controls.update();
        return this;
      },
      fit() {
        current.camera.copy(camera.position);
        if (controls)
          current.focus.copy(controls.target);
        const {
          center,
          distance
        } = getSize();
        const direction = center.clone().sub(camera.position).normalize().multiplyScalar(distance);
        goal.camera.copy(center).sub(direction);
        goal.focus.copy(center);
        if (isOrthographic(camera)) {
          current.zoom = camera.zoom;
          let maxHeight = 0, maxWidth = 0;
          const vertices = [new Vector3(box.min.x, box.min.y, box.min.z), new Vector3(box.min.x, box.max.y, box.min.z), new Vector3(box.min.x, box.min.y, box.max.z), new Vector3(box.min.x, box.max.y, box.max.z), new Vector3(box.max.x, box.max.y, box.max.z), new Vector3(box.max.x, box.max.y, box.min.z), new Vector3(box.max.x, box.min.y, box.max.z), new Vector3(box.max.x, box.min.y, box.min.z)];
          center.applyMatrix4(camera.matrixWorldInverse);
          for (const v4 of vertices) {
            v4.applyMatrix4(camera.matrixWorldInverse);
            maxHeight = Math.max(maxHeight, Math.abs(v4.y - center.y));
            maxWidth = Math.max(maxWidth, Math.abs(v4.x - center.x));
          }
          maxHeight *= 2;
          maxWidth *= 2;
          const zoomForHeight = (camera.top - camera.bottom) / maxHeight;
          const zoomForWidth = (camera.right - camera.left) / maxWidth;
          goal.zoom = Math.min(zoomForHeight, zoomForWidth) / margin;
          if (!damping) {
            camera.zoom = goal.zoom;
            camera.updateProjectionMatrix();
          }
        }
        if (damping) {
          current.animating = true;
        } else {
          camera.position.copy(goal.camera);
          camera.lookAt(goal.focus);
          if (controls) {
            controls.target.copy(goal.focus);
            controls.update();
          }
          invalidate();
        }
        if (onFitRef.current)
          onFitRef.current(this.getSize());
        return this;
      }
    };
  }, [box, camera, controls, margin, damping, invalidate]);
  React55.useLayoutEffect(() => {
    api.refresh();
    if (fit)
      api.fit();
    if (clip)
      api.clip();
    if (controls) {
      const callback = () => current.animating = false;
      controls.addEventListener("start", callback);
      return () => controls.removeEventListener("start", callback);
    }
  }, [clip, fit, controls]);
  useFrame((state, delta) => {
    if (current.animating) {
      damp(current.focus, goal.focus, damping, delta);
      damp(current.camera, goal.camera, damping, delta);
      current.zoom = MathUtils.damp(current.zoom, goal.zoom, damping, delta);
      camera.position.copy(current.camera);
      if (isOrthographic(camera)) {
        camera.zoom = current.zoom;
        camera.updateProjectionMatrix();
      }
      if (!controls) {
        camera.lookAt(current.focus);
      } else {
        controls.target.copy(current.focus);
        controls.update();
      }
      invalidate();
      if (isOrthographic(camera) && !(Math.abs(current.zoom - goal.zoom) < eps2))
        return;
      if (!isOrthographic(camera) && !equals(current.camera, goal.camera))
        return;
      if (controls && !equals(current.focus, goal.focus))
        return;
      current.animating = false;
    }
  });
  return React55.createElement("group", {
    ref
  }, React55.createElement(context4.Provider, {
    value: api
  }, children));
}
function useBounds() {
  return React55.useContext(context4);
}

// node_modules/@react-three/drei/core/CameraShake.js
var React56 = __toModule(require_react());
var CameraShake = React56.forwardRef(({
  intensity = 1,
  decay,
  decayRate = 0.65,
  maxYaw = 0.1,
  maxPitch = 0.1,
  maxRoll = 0.1,
  yawFrequency = 0.1,
  pitchFrequency = 0.1,
  rollFrequency = 0.1,
  controls
}, ref) => {
  const camera = useThree((state) => state.camera);
  const defaultControls = useThree((state) => state.controls);
  const intensityRef = React56.useRef(intensity);
  const initialRotation = React56.useRef(camera.rotation.clone());
  const [yawNoise] = React56.useState(() => new SimplexNoise());
  const [pitchNoise] = React56.useState(() => new SimplexNoise());
  const [rollNoise] = React56.useState(() => new SimplexNoise());
  const constrainIntensity = () => {
    if (intensityRef.current < 0 || intensityRef.current > 1) {
      intensityRef.current = intensityRef.current < 0 ? 0 : 1;
    }
  };
  React56.useImperativeHandle(ref, () => ({
    getIntensity: () => intensityRef.current,
    setIntensity: (val) => {
      intensityRef.current = val;
      constrainIntensity();
    }
  }), []);
  React56.useEffect(() => {
    const currControls = defaultControls || (controls == null ? void 0 : controls.current);
    const callback = () => void (initialRotation.current = camera.rotation.clone());
    currControls == null ? void 0 : currControls.addEventListener("change", callback);
    return () => void (currControls == null ? void 0 : currControls.removeEventListener("change", callback));
  }, [controls, defaultControls]);
  useFrame(({
    clock
  }, delta) => {
    const shake = Math.pow(intensityRef.current, 2);
    const yaw = maxYaw * shake * yawNoise.noise(clock.elapsedTime * yawFrequency, 1);
    const pitch = maxPitch * shake * pitchNoise.noise(clock.elapsedTime * pitchFrequency, 1);
    const roll = maxRoll * shake * rollNoise.noise(clock.elapsedTime * rollFrequency, 1);
    camera.rotation.set(initialRotation.current.x + pitch, initialRotation.current.y + yaw, initialRotation.current.z + roll);
    if (decay && intensityRef.current > 0) {
      intensityRef.current -= decayRate * delta;
      constrainIntensity();
    }
  });
  return null;
});

// node_modules/@react-three/drei/core/Float.js
var React57 = __toModule(require_react());
function Float(_a) {
  var _b = _a, {
    children,
    speed = 1,
    rotationIntensity = 1,
    floatIntensity = 1
  } = _b, props = __objRest(_b, [
    "children",
    "speed",
    "rotationIntensity",
    "floatIntensity"
  ]);
  const ref = React57.useRef(null);
  const offset = React57.useRef(Math.random() * 1e4);
  useFrame((state) => {
    const t2 = offset.current + state.clock.getElapsedTime();
    ref.current.rotation.x = Math.cos(t2 / 4 * speed) / 8 * rotationIntensity;
    ref.current.rotation.y = Math.sin(t2 / 4 * speed) / 8 * rotationIntensity;
    ref.current.rotation.z = Math.sin(t2 / 4 * speed) / 20 * rotationIntensity;
    ref.current.position.y = Math.sin(t2 / 4 * speed) / 10 * floatIntensity;
  });
  return React57.createElement("group", props, React57.createElement("group", {
    ref
  }, children));
}

// node_modules/@react-three/drei/core/Stage.js
var React60 = __toModule(require_react());

// node_modules/@react-three/drei/core/Environment.js
var React58 = __toModule(require_react());

// node_modules/@react-three/drei/helpers/environment-assets.js
var presetsObj = {
  sunset: "venice_sunset_1k.hdr",
  dawn: "kiara_1_dawn_1k.hdr",
  night: "dikhololo_night_1k.hdr",
  warehouse: "empty_warehouse_01_1k.hdr",
  forest: "forest_slope_1k.hdr",
  apartment: "lebombo_1k.hdr",
  studio: "studio_small_03_1k.hdr",
  city: "potsdamer_platz_1k.hdr",
  park: "rooitou_park_1k.hdr",
  lobby: "st_fagans_interior_1k.hdr"
};

// node_modules/@react-three/drei/core/Environment.js
var CUBEMAP_ROOT = "https://rawcdn.githack.com/pmndrs/drei-assets/aa3600359ba664d546d05821bcbca42013587df2";
function Environment({
  background = false,
  files = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
  path = "",
  preset = void 0,
  scene,
  extensions: extensions2
}) {
  if (preset) {
    if (!(preset in presetsObj)) {
      throw new Error("Preset must be one of: " + Object.keys(presetsObj).join(", "));
    }
    files = presetsObj[preset];
    path = CUBEMAP_ROOT + "/hdri/";
  }
  const defaultScene = useThree(({
    scene: scene2
  }) => scene2);
  const isCubeMap = Array.isArray(files);
  const loader = isCubeMap ? CubeTextureLoader : RGBELoader;
  const loaderResult = useLoader(loader, isCubeMap ? [files] : files, (loader2) => {
    loader2.setPath(path);
    loader2.setDataType == null ? void 0 : loader2.setDataType(FloatType);
    if (extensions2)
      extensions2(loader2);
  });
  const texture = isCubeMap ? loaderResult[0] : loaderResult;
  texture.mapping = EquirectangularReflectionMapping;
  React58.useLayoutEffect(() => {
    const oldbg = scene ? scene.background : defaultScene.background;
    const oldenv = scene ? scene.environment : defaultScene.environment;
    if (scene) {
      scene.environment = texture;
      if (background)
        scene.background = texture;
    } else {
      defaultScene.environment = texture;
      if (background)
        defaultScene.background = texture;
    }
    return () => {
      if (scene) {
        scene.environment = oldenv;
        scene.background = oldbg;
      } else {
        defaultScene.environment = oldenv;
        defaultScene.background = oldbg;
      }
      texture.dispose();
    };
  }, [texture, background, scene]);
  return null;
}

// node_modules/@react-three/drei/core/ContactShadows.js
var React59 = __toModule(require_react());
var ContactShadows = React59.forwardRef((_a, ref) => {
  var _b = _a, {
    scale: scale2,
    frames = Infinity,
    opacity = 1,
    width = 1,
    height = 1,
    blur = 1,
    far = 10,
    resolution = 256
  } = _b, props = __objRest(_b, [
    "scale",
    "frames",
    "opacity",
    "width",
    "height",
    "blur",
    "far",
    "resolution"
  ]);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const shadowCamera = React59.useRef();
  width = width * (Array.isArray(scale2) ? scale2[0] : scale2 || 1);
  height = height * (Array.isArray(scale2) ? scale2[1] : scale2 || 1);
  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React59.useMemo(() => {
    const renderTarget2 = new WebGLRenderTarget(resolution, resolution);
    const renderTargetBlur2 = new WebGLRenderTarget(resolution, resolution);
    renderTargetBlur2.texture.generateMipmaps = renderTarget2.texture.generateMipmaps = false;
    const planeGeometry2 = new PlaneGeometry(width, height).rotateX(Math.PI / 2);
    const blurPlane2 = new Mesh(planeGeometry2);
    const depthMaterial2 = new MeshDepthMaterial();
    depthMaterial2.depthTest = depthMaterial2.depthWrite = false;
    depthMaterial2.onBeforeCompile = (shader) => shader.fragmentShader = shader.fragmentShader.replace("1.0 - fragCoordZ ), opacity );", "0.0 ), ( 1.0 - fragCoordZ ) * 1.0 );");
    const horizontalBlurMaterial2 = new ShaderMaterial(HorizontalBlurShader);
    const verticalBlurMaterial2 = new ShaderMaterial(VerticalBlurShader);
    verticalBlurMaterial2.depthTest = horizontalBlurMaterial2.depthTest = false;
    return [renderTarget2, planeGeometry2, depthMaterial2, blurPlane2, horizontalBlurMaterial2, verticalBlurMaterial2, renderTargetBlur2];
  }, [resolution, width, height, scale2]);
  let count = 0;
  useFrame(() => {
    if (shadowCamera.current && (frames === Infinity || count < frames)) {
      const initialBackground = scene.background;
      scene.background = null;
      scene.overrideMaterial = depthMaterial;
      gl.setRenderTarget(renderTarget);
      gl.render(scene, shadowCamera.current);
      scene.overrideMaterial = null;
      blurPlane.material = horizontalBlurMaterial;
      blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;
      horizontalBlurMaterial.uniforms.h.value = blur / 256;
      gl.setRenderTarget(renderTargetBlur);
      gl.render(blurPlane, shadowCamera.current);
      blurPlane.material = verticalBlurMaterial;
      blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;
      verticalBlurMaterial.uniforms.v.value = blur / 256;
      gl.setRenderTarget(renderTarget);
      gl.render(blurPlane, shadowCamera.current);
      gl.setRenderTarget(null);
      scene.background = initialBackground;
      count++;
    }
  });
  return React59.createElement("group", _extends({
    "rotation-x": Math.PI / 2
  }, props, {
    ref
  }), React59.createElement("mesh", {
    geometry: planeGeometry,
    scale: [1, -1, 1],
    rotation: [-Math.PI / 2, 0, 0]
  }, React59.createElement("meshBasicMaterial", {
    map: renderTarget.texture,
    transparent: true,
    opacity
  })), React59.createElement("orthographicCamera", {
    ref: shadowCamera,
    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]
  }));
});

// node_modules/@react-three/drei/core/Stage.js
var presets = {
  rembrandt: {
    main: [1, 2, 1],
    fill: [-2, -0.5, -2]
  },
  portrait: {
    main: [-1, 2, 0.5],
    fill: [-1, 0.5, -1.5]
  },
  upfront: {
    main: [0, 2, 1],
    fill: [-1, 0.5, -1.5]
  },
  soft: {
    main: [-2, 4, 4],
    fill: [-1, 0.5, -1.5]
  }
};
function Stage(_a) {
  var _b = _a, {
    children,
    controls,
    shadows = true,
    adjustCamera = true,
    environment = "city",
    intensity = 1,
    preset = "rembrandt",
    shadowBias = 0,
    contactShadow = {
      blur: 2,
      opacity: 0.5,
      position: [0, 0, 0]
    }
  } = _b, props = __objRest(_b, [
    "children",
    "controls",
    "shadows",
    "adjustCamera",
    "environment",
    "intensity",
    "preset",
    "shadowBias",
    "contactShadow"
  ]);
  const config2 = presets[preset];
  const camera = useThree((state) => state.camera);
  const defaultControls = useThree((state) => state.controls);
  const outer = React60.useRef(null);
  const inner = React60.useRef(null);
  const [{
    radius,
    width,
    height
  }, set] = React60.useState({
    radius: 0,
    width: 0,
    height: 0
  });
  React60.useLayoutEffect(() => {
    outer.current.position.set(0, 0, 0);
    outer.current.updateWorldMatrix(true, true);
    const box3 = new Box3().setFromObject(inner.current);
    const center = new Vector3();
    const sphere = new Sphere();
    const height2 = box3.max.y - box3.min.y;
    const width2 = box3.max.x - box3.min.x;
    box3.getCenter(center);
    box3.getBoundingSphere(sphere);
    set({
      radius: sphere.radius,
      width: width2,
      height: height2
    });
    outer.current.position.set(-center.x, -center.y + height2 / 2, -center.z);
  }, [children]);
  React60.useLayoutEffect(() => {
    if (adjustCamera) {
      const y = radius / (height > width ? 1.5 : 2.5);
      camera.position.set(0, radius * 0.5, radius * 2.5);
      camera.near = 0.1;
      camera.far = Math.max(5e3, radius * 4);
      camera.lookAt(0, y, 0);
      const ctrl = defaultControls || (controls == null ? void 0 : controls.current);
      if (ctrl) {
        ctrl.target.set(0, y, 0);
        ctrl.update();
      }
    }
  }, [defaultControls, radius, height, width, adjustCamera]);
  return React60.createElement("group", props, React60.createElement("group", {
    ref: outer
  }, React60.createElement("group", {
    ref: inner
  }, children)), contactShadow && React60.createElement(ContactShadows, _extends({
    width: radius * 2,
    height: radius * 2,
    far: radius / 2
  }, contactShadow)), environment && React60.createElement(Environment, {
    preset: environment
  }), React60.createElement("ambientLight", {
    intensity: intensity / 3
  }), React60.createElement("spotLight", {
    penumbra: 1,
    position: [config2.main[0] * radius, config2.main[1] * radius, config2.main[2] * radius],
    intensity: intensity * 2,
    castShadow: shadows,
    "shadow-bias": shadowBias
  }), React60.createElement("pointLight", {
    position: [config2.fill[0] * radius, config2.fill[1] * radius, config2.fill[2] * radius],
    intensity
  }));
}

// node_modules/@react-three/drei/core/Backdrop.js
var React61 = __toModule(require_react());
var easeInExpo = (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10);
function Backdrop(_a) {
  var _b = _a, {
    children,
    floor = 0.25,
    segments = 20,
    receiveShadow
  } = _b, props = __objRest(_b, [
    "children",
    "floor",
    "segments",
    "receiveShadow"
  ]);
  const ref = React61.useRef(null);
  React61.useLayoutEffect(() => {
    let i4 = 0;
    const offset = segments / segments / 2;
    const position2 = ref.current.attributes.position;
    for (let x = 0; x < segments + 1; x++) {
      for (let y = 0; y < segments + 1; y++) {
        position2.setXYZ(i4++, x / segments - offset + (x === 0 ? -floor : 0), y / segments - offset, easeInExpo(x / segments));
      }
    }
    position2.needsUpdate = true;
    ref.current.computeVertexNormals();
  }, [segments, floor]);
  return React61.createElement("group", props, React61.createElement("mesh", {
    receiveShadow,
    rotation: [-Math.PI / 2, 0, Math.PI / 2]
  }, React61.createElement("planeGeometry", {
    ref,
    args: [1, 1, segments, segments]
  }), children));
}

// node_modules/@react-three/drei/core/Shadow.js
var React62 = __toModule(require_react());
var Shadow = React62.forwardRef((_a, ref) => {
  var _b = _a, {
    fog = false,
    colorStop = 0,
    color: color3 = "black",
    opacity = 0.5
  } = _b, props = __objRest(_b, [
    "fog",
    "colorStop",
    "color",
    "opacity"
  ]);
  const canvas = React62.useMemo(() => {
    const canvas2 = document.createElement("canvas");
    canvas2.width = 128;
    canvas2.height = 128;
    const context7 = canvas2.getContext("2d");
    const gradient = context7.createRadialGradient(canvas2.width / 2, canvas2.height / 2, 0, canvas2.width / 2, canvas2.height / 2, canvas2.width / 2);
    gradient.addColorStop(colorStop, new Color(color3).getStyle());
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    context7.fillStyle = gradient;
    context7.fillRect(0, 0, canvas2.width, canvas2.height);
    return canvas2;
  }, [color3, colorStop]);
  return React62.createElement("mesh", _extends({
    ref
  }, props), React62.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [1, 1]
  }), React62.createElement("meshBasicMaterial", {
    attach: "material",
    transparent: true,
    opacity,
    fog
  }, React62.createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

// node_modules/@react-three/drei/core/Reflector.js
var React63 = __toModule(require_react());
extend({
  MeshReflectorMaterial
});
var Reflector = React63.forwardRef((_a, ref) => {
  var _b = _a, {
    mixBlur = 0,
    mixStrength = 0.5,
    resolution = 256,
    blur = [0, 0],
    args = [1, 1],
    minDepthThreshold = 0.9,
    maxDepthThreshold = 1,
    depthScale = 0,
    depthToBlurRatioBias = 0.25,
    mirror = 0,
    children,
    debug = 0,
    distortion = 1,
    mixContrast = 1,
    distortionMap
  } = _b, props = __objRest(_b, [
    "mixBlur",
    "mixStrength",
    "resolution",
    "blur",
    "args",
    "minDepthThreshold",
    "maxDepthThreshold",
    "depthScale",
    "depthToBlurRatioBias",
    "mirror",
    "children",
    "debug",
    "distortion",
    "mixContrast",
    "distortionMap"
  ]);
  React63.useEffect(() => {
    console.warn("Reflector has been deprecated and will be removed next major. Replace it with <MeshReflectorMaterial />!");
  }, []);
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const camera = useThree(({
    camera: camera2
  }) => camera2);
  const scene = useThree(({
    scene: scene2
  }) => scene2);
  blur = Array.isArray(blur) ? blur : [blur, blur];
  const hasBlur = blur[0] + blur[1] > 0;
  const meshRef = React63.useRef(null);
  const [reflectorPlane] = React63.useState(() => new Plane());
  const [normal] = React63.useState(() => new Vector3());
  const [reflectorWorldPosition] = React63.useState(() => new Vector3());
  const [cameraWorldPosition] = React63.useState(() => new Vector3());
  const [rotationMatrix] = React63.useState(() => new Matrix4());
  const [lookAtPosition] = React63.useState(() => new Vector3(0, 0, -1));
  const [clipPlane] = React63.useState(() => new Vector4());
  const [view] = React63.useState(() => new Vector3());
  const [target2] = React63.useState(() => new Vector3());
  const [q] = React63.useState(() => new Vector4());
  const [textureMatrix] = React63.useState(() => new Matrix4());
  const [virtualCamera] = React63.useState(() => new PerspectiveCamera());
  const beforeRender = React63.useCallback(() => {
    reflectorWorldPosition.setFromMatrixPosition(meshRef.current.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(meshRef.current.matrixWorld);
    normal.set(0, 0, 1);
    normal.applyMatrix4(rotationMatrix);
    view.subVectors(reflectorWorldPosition, cameraWorldPosition);
    if (view.dot(normal) > 0)
      return;
    view.reflect(normal).negate();
    view.add(reflectorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target2.subVectors(reflectorWorldPosition, lookAtPosition);
    target2.reflect(normal).negate();
    target2.add(reflectorWorldPosition);
    virtualCamera.position.copy(view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(rotationMatrix);
    virtualCamera.up.reflect(normal);
    virtualCamera.lookAt(target2);
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    textureMatrix.multiply(virtualCamera.projectionMatrix);
    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
    textureMatrix.multiply(meshRef.current.matrixWorld);
    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1;
    q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(2 / clipPlane.dot(q));
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1;
    projectionMatrix.elements[14] = clipPlane.w;
  }, []);
  const [fbo1, fbo2, blurpass, reflectorProps] = React63.useMemo(() => {
    const parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat,
      encoding: gl.outputEncoding
    };
    const fbo12 = new WebGLRenderTarget(resolution, resolution, parameters);
    fbo12.depthBuffer = true;
    fbo12.depthTexture = new DepthTexture(resolution, resolution);
    fbo12.depthTexture.format = DepthFormat;
    fbo12.depthTexture.type = UnsignedShortType;
    const fbo22 = new WebGLRenderTarget(resolution, resolution, parameters);
    const blurpass2 = new BlurPass({
      gl,
      resolution,
      width: blur[0],
      height: blur[1],
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias
    });
    const reflectorProps2 = {
      mirror,
      textureMatrix,
      mixBlur,
      tDiffuse: fbo12.texture,
      tDepth: fbo12.depthTexture,
      tDiffuseBlur: fbo22.texture,
      hasBlur,
      mixStrength,
      minDepthThreshold,
      maxDepthThreshold,
      depthScale,
      depthToBlurRatioBias,
      transparent: true,
      debug,
      distortion,
      distortionMap,
      mixContrast,
      "defines-USE_BLUR": hasBlur ? "" : void 0,
      "defines-USE_DEPTH": depthScale > 0 ? "" : void 0,
      "defines-USE_DISTORTION": distortionMap ? "" : void 0
    };
    return [fbo12, fbo22, blurpass2, reflectorProps2];
  }, [gl, blur, textureMatrix, resolution, mirror, hasBlur, mixBlur, mixStrength, minDepthThreshold, maxDepthThreshold, depthScale, depthToBlurRatioBias, debug, distortion, distortionMap, mixContrast]);
  useFrame(() => {
    if (!(meshRef != null && meshRef.current))
      return;
    meshRef.current.visible = false;
    const currentXrEnabled = gl.xr.enabled;
    const currentShadowAutoUpdate = gl.shadowMap.autoUpdate;
    beforeRender();
    gl.xr.enabled = false;
    gl.shadowMap.autoUpdate = false;
    gl.setRenderTarget(fbo1);
    gl.state.buffers.depth.setMask(true);
    if (!gl.autoClear)
      gl.clear();
    gl.render(scene, virtualCamera);
    if (hasBlur)
      blurpass.render(gl, fbo1, fbo2);
    gl.xr.enabled = currentXrEnabled;
    gl.shadowMap.autoUpdate = currentShadowAutoUpdate;
    meshRef.current.visible = true;
    gl.setRenderTarget(null);
  });
  return React63.createElement("mesh", _extends({
    ref: react_merge_refs_esm_default([meshRef, ref])
  }, props), React63.createElement("planeBufferGeometry", {
    args
  }), children ? children("meshReflectorMaterial", reflectorProps) : React63.createElement("meshReflectorMaterial", reflectorProps));
});

// node_modules/@react-three/drei/core/SpotLight.js
var React64 = __toModule(require_react());

// node_modules/@react-three/drei/materials/SpotLightMaterial.js
var SpotLightMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        depth: {
          value: null
        },
        opacity: {
          value: 1
        },
        attenuation: {
          value: 2.5
        },
        anglePower: {
          value: 12
        },
        spotPosition: {
          value: new Vector3(0, 0, 0)
        },
        lightColor: {
          value: new Color("white")
        },
        cameraNear: {
          value: 0
        },
        cameraFar: {
          value: 1
        },
        resolution: {
          value: new Vector2(0, 0)
        }
      },
      transparent: true,
      depthWrite: false,
      vertexShader: `
      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      varying float vViewZ;
      varying float vIntensity;
      uniform vec3 spotPosition;
      uniform float attenuation;      

      void main() {
        // compute intensity
        vNormal = normalize( normalMatrix * normal );
        vec4 worldPosition	= modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;
        vec4 viewPosition = viewMatrix * worldPosition;
        vViewZ = viewPosition.z;
        float intensity	= distance(worldPosition.xyz, spotPosition) / attenuation;
        intensity	= 1.0 - clamp(intensity, 0.0, 1.0);
        vIntensity = intensity;        
        // set gl_Position
        gl_Position	= projectionMatrix * viewPosition;

      }`,
      fragmentShader: `
      #include <packing>

      varying vec3 vNormal;
      varying vec3 vWorldPosition;
      uniform vec3 lightColor;
      uniform vec3 spotPosition;
      uniform float attenuation;
      uniform float anglePower;
      uniform sampler2D depth;
      uniform vec2 resolution;
      uniform float cameraNear;
      uniform float cameraFar;
      varying float vViewZ;
      varying float vIntensity;
      uniform float opacity;

      float readDepth( sampler2D depthSampler, vec2 coord ) {
        float fragCoordZ = texture2D( depthSampler, coord ).x;
        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
        return viewZ;
      }

      void main() {
        float d = 1.0;
        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;
        if (isSoft) {
          vec2 sUv = gl_FragCoord.xy / resolution;
          d = readDepth(depth, sUv);
        }
        float intensity = vIntensity;
        vec3 normal	= vec3(vNormal.x, vNormal.y, abs(vNormal.z));
        float angleIntensity	= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );
        intensity	*= angleIntensity;
        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry
        if (isSoft) {
          intensity	*= smoothstep(0., 1., vViewZ - d);
        }
        gl_FragColor = vec4(lightColor, intensity * opacity);
      }`
    });
  }
};

// node_modules/@react-three/drei/core/SpotLight.js
var vec = new Vector3();
var SpotLight = React64.forwardRef((_a, ref) => {
  var _b = _a, {
    opacity = 1,
    radiusTop,
    radiusBottom,
    depthBuffer,
    color: color3 = "white",
    distance = 5,
    angle = 0.15,
    attenuation = 5,
    anglePower = 5
  } = _b, props = __objRest(_b, [
    "opacity",
    "radiusTop",
    "radiusBottom",
    "depthBuffer",
    "color",
    "distance",
    "angle",
    "attenuation",
    "anglePower"
  ]);
  const mesh = React64.useRef(null);
  const size = useThree((state) => state.size);
  const camera = useThree((state) => state.camera);
  const dpr = useThree((state) => state.viewport.dpr);
  const [material] = React64.useState(() => new SpotLightMaterial());
  radiusTop = radiusTop === void 0 ? 0.1 : radiusTop;
  radiusBottom = radiusBottom === void 0 ? angle * 7 : radiusBottom;
  useFrame(() => {
    material.uniforms.spotPosition.value.copy(mesh.current.getWorldPosition(vec));
    mesh.current.lookAt(mesh.current.parent.target.getWorldPosition(vec));
  });
  const geom = React64.useMemo(() => {
    const geometry = new CylinderGeometry(radiusTop, radiusBottom, distance, 128, 64, true);
    geometry.applyMatrix4(new Matrix4().makeTranslation(0, -distance / 2, 0));
    geometry.applyMatrix4(new Matrix4().makeRotationX(-Math.PI / 2));
    return geometry;
  }, [angle, distance, radiusTop, radiusBottom]);
  return React64.createElement("spotLight", _extends({
    ref,
    angle,
    color: color3,
    distance
  }, props), React64.createElement("mesh", {
    ref: mesh,
    geometry: geom,
    raycast: () => null
  }, React64.createElement("primitive", {
    object: material,
    attach: "material",
    "uniforms-opacity-value": opacity,
    "uniforms-lightColor-value": color3,
    "uniforms-attenuation-value": attenuation,
    "uniforms-anglePower-value": anglePower,
    "uniforms-depth-value": depthBuffer,
    "uniforms-cameraNear-value": camera.near,
    "uniforms-cameraFar-value": camera.far,
    "uniforms-resolution-value": depthBuffer ? [size.width * dpr, size.height * dpr] : [0, 0]
  })));
});

// node_modules/@react-three/drei/core/Sky.js
var React65 = __toModule(require_react());
function calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {
  const theta = Math.PI * (inclination - 0.5);
  const phi = 2 * Math.PI * (azimuth - 0.5);
  vector.x = Math.cos(phi);
  vector.y = Math.sin(theta);
  vector.z = Math.sin(phi);
  return vector;
}
var Sky2 = React65.forwardRef((_a, ref) => {
  var _b = _a, {
    inclination = 0.6,
    azimuth = 0.1,
    distance = 1e3,
    mieCoefficient = 5e-3,
    mieDirectionalG = 0.8,
    rayleigh = 0.5,
    turbidity = 10,
    sunPosition = calcPosFromAngles(inclination, azimuth)
  } = _b, props = __objRest(_b, [
    "inclination",
    "azimuth",
    "distance",
    "mieCoefficient",
    "mieDirectionalG",
    "rayleigh",
    "turbidity",
    "sunPosition"
  ]);
  const scale2 = React65.useMemo(() => new Vector3().setScalar(distance), [distance]);
  const [sky] = React65.useState(() => new Sky());
  return React65.createElement("primitive", _extends({
    dispose: void 0,
    object: sky,
    ref,
    "material-uniforms-mieCoefficient-value": mieCoefficient,
    "material-uniforms-mieDirectionalG-value": mieDirectionalG,
    "material-uniforms-rayleigh-value": rayleigh,
    "material-uniforms-sunPosition-value": sunPosition,
    "material-uniforms-turbidity-value": turbidity,
    scale: scale2
  }, props));
});

// node_modules/@react-three/drei/core/Stars.js
var React66 = __toModule(require_react());
var StarfieldMaterial = class extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0
        },
        fade: {
          value: 1
        }
      },
      vertexShader: `
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,
      fragmentShader: `
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);
      }`
    });
  }
};
var genStar = (r2) => {
  return new Vector3().setFromSpherical(new Spherical(r2, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};
var Stars = React66.forwardRef(({
  radius = 100,
  depth = 50,
  count = 5e3,
  saturation = 0,
  factor = 4,
  fade = false
}, ref) => {
  const material = React66.useRef();
  const [position2, color3, size] = React66.useMemo(() => {
    const positions = [];
    const colors3 = [];
    const sizes = Array.from({
      length: count
    }, () => (0.5 + 0.5 * Math.random()) * factor);
    const color4 = new Color();
    let r2 = radius + depth;
    const increment = depth / count;
    for (let i4 = 0; i4 < count; i4++) {
      r2 -= increment * Math.random();
      positions.push(...genStar(r2).toArray());
      color4.setHSL(i4 / count, saturation, 0.9);
      colors3.push(color4.r, color4.g, color4.b);
    }
    return [new Float32Array(positions), new Float32Array(colors3), new Float32Array(sizes)];
  }, [count, depth, factor, radius, saturation]);
  useFrame((state) => material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime()));
  const [starfieldMaterial] = React66.useState(() => new StarfieldMaterial());
  return React66.createElement("points", {
    ref
  }, React66.createElement("bufferGeometry", {
    attach: "geometry"
  }, React66.createElement("bufferAttribute", {
    attachObject: ["attributes", "position"],
    args: [position2, 3]
  }), React66.createElement("bufferAttribute", {
    attachObject: ["attributes", "color"],
    args: [color3, 3]
  }), React66.createElement("bufferAttribute", {
    attachObject: ["attributes", "size"],
    args: [size, 1]
  })), React66.createElement("primitive", {
    dispose: void 0,
    ref: material,
    object: starfieldMaterial,
    attach: "material",
    blending: AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

// node_modules/@react-three/drei/core/Cloud.js
var React67 = __toModule(require_react());
var CLOUD_URL = "https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png";
function Cloud(_a) {
  var _b = _a, {
    opacity = 0.5,
    speed = 0.4,
    width = 10,
    depth = 1.5,
    segments = 20
  } = _b, props = __objRest(_b, [
    "opacity",
    "speed",
    "width",
    "depth",
    "segments"
  ]);
  const group = React67.useRef();
  const texture = useTexture(CLOUD_URL);
  const clouds = React67.useMemo(() => [...new Array(segments)].map((_, index) => ({
    x: width / 2 - Math.random() * width,
    y: width / 2 - Math.random() * width,
    scale: 0.4 + Math.sin((index + 1) / segments * Math.PI) * ((0.2 + Math.random()) * 10),
    density: Math.max(0.2, Math.random()),
    rotation: Math.max(2e-3, 5e-3 * Math.random()) * speed
  })), [width, segments, speed]);
  useFrame((state) => {
    var _group$current;
    return (_group$current = group.current) == null ? void 0 : _group$current.children.forEach((cloud, index) => {
      cloud.children[0].rotation.z += clouds[index].rotation;
      cloud.children[0].scale.setScalar(clouds[index].scale + (1 + Math.sin(state.clock.getElapsedTime() / 10)) / 2 * index / 10);
    });
  });
  return React67.createElement("group", props, React67.createElement("group", {
    position: [0, 0, segments / 2 * depth],
    ref: group
  }, clouds.map(({
    x,
    y,
    scale: scale2,
    density
  }, index) => React67.createElement(Billboard, {
    key: index,
    position: [x, y, -index * depth]
  }, React67.createElement(Plane2, {
    scale: scale2,
    rotation: [0, 0, 0]
  }, React67.createElement("meshStandardMaterial", {
    map: texture,
    transparent: true,
    opacity: scale2 / 6 * density * opacity,
    depthTest: false
  }))))));
}

// node_modules/@react-three/drei/core/useMatcapTexture.js
var React68 = __toModule(require_react());
function getFormatString(format) {
  switch (format) {
    case 64:
      return "-64px";
    case 128:
      return "-128px";
    case 256:
      return "-256px";
    case 512:
      return "-512px";
    default:
      return "";
  }
}
var LIST_URL = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/matcaps.json";
var MATCAP_ROOT = "https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d";
function useMatcapTexture(id = 0, format = 1024) {
  const matcapList = useAsset(() => new Promise(async (resolve) => {
    const matcapList2 = await fetch(LIST_URL).then((res) => res.json());
    resolve(matcapList2);
  }), "matcapList");
  const DEFAULT_MATCAP = matcapList[0];
  const numTot = React68.useMemo(() => Object.keys(matcapList).length, []);
  const fileHash = React68.useMemo(() => {
    if (typeof id === "string") {
      return id;
    } else if (typeof id === "number") {
      return matcapList[id];
    }
    return null;
  }, [id]);
  const fileName = `${fileHash || DEFAULT_MATCAP}${getFormatString(format)}.png`;
  const url = `${MATCAP_ROOT}/${format}/${fileName}`;
  const matcapTexture = useTexture(url);
  return [matcapTexture, url, numTot];
}

// node_modules/@react-three/drei/core/useNormalTexture.js
var React69 = __toModule(require_react());
var NORMAL_ROOT = "https://rawcdn.githack.com/pmndrs/drei-assets/7a3104997e1576f83472829815b00880d88b32fb";
var LIST_URL2 = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/normals/normals.json";
function useNormalTexture(id = 0, settings = {}) {
  const {
    repeat = [1, 1],
    anisotropy = 1,
    offset = [0, 0]
  } = settings;
  const normalsList = useAsset(() => new Promise(async (resolve) => {
    const normalsList2 = await fetch(LIST_URL2).then((res) => res.json());
    resolve(normalsList2);
  }), "normalsList");
  const numTot = React69.useMemo(() => Object.keys(normalsList).length, []);
  const DEFAULT_NORMAL = normalsList[0];
  const imageName = normalsList[id] || DEFAULT_NORMAL;
  const url = `${NORMAL_ROOT}/normals/${imageName}`;
  const normalTexture = useTexture(url);
  React69.useLayoutEffect(() => {
    if (!normalTexture)
      return;
    normalTexture.wrapS = normalTexture.wrapT = RepeatWrapping;
    normalTexture.repeat = new Vector2(repeat[0], repeat[1]);
    normalTexture.offset = new Vector2(offset[0], offset[1]);
    normalTexture.anisotropy = anisotropy;
  }, [normalTexture, anisotropy, repeat, offset]);
  return [normalTexture, url, numTot];
}

// node_modules/@react-three/drei/core/Points.js
var React70 = __toModule(require_react());

// node_modules/@react-three/drei/helpers/Position.js
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var Position = class extends Group {
  constructor() {
    super();
    this.color = new Color("white");
    this.instance = {
      current: void 0
    };
    this.instanceKey = {
      current: void 0
    };
  }
  get geometry() {
    var _this$instance$curren;
    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;
  }
  raycast(raycaster, intersects) {
    const parent = this.instance.current;
    if (!parent)
      return;
    if (!parent.geometry || !parent.material)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld = parent.matrixWorld;
    let instanceId = parent.userData.instances.indexOf(this.instanceKey);
    if (instanceId === -1)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i4 = 0, l2 = _instanceIntersects.length; i4 < l2; i4++) {
      const intersect = _instanceIntersects[i4];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};

// node_modules/@react-three/drei/core/Points.js
var i2;
var positionRef;
var context5 = React70.createContext(null);
var parentMatrix = new Matrix4();
var position = new Vector3();
var color = new Color();
var PointsInstances = React70.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    range,
    limit = 1e3
  } = _b, props = __objRest(_b, [
    "children",
    "range",
    "limit"
  ]);
  const parentRef = React70.useRef(null);
  const [refs, setRefs] = React70.useState([]);
  const [[positions, colors3, sizes]] = React70.useState(() => [new Float32Array(limit * 3), Float32Array.from({
    length: limit * 3
  }, () => 1), Float32Array.from({
    length: limit
  }, () => 1)]);
  React70.useLayoutEffect(() => {
    parentRef.current.geometry.drawRange.count = Math.min(limit, range !== void 0 ? range : limit, refs.length);
  }, [refs, range]);
  React70.useEffect(() => {
    parentRef.current.geometry.attributes.position.needsUpdate = true;
  });
  useFrame(() => {
    parentRef.current.updateMatrix();
    parentRef.current.updateMatrixWorld();
    parentMatrix.copy(parentRef.current.matrixWorld).invert();
    for (i2 = 0; i2 < refs.length; i2++) {
      positionRef = refs[i2].current;
      positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);
      if (position.x !== positions[i2 * 3] || position.y !== positions[i2 * 3 + 1] || position.z !== positions[i2 * 3 + 2]) {
        position.toArray(positions, i2 * 3);
        parentRef.current.geometry.attributes.position.needsUpdate = true;
        positionRef.matrixWorldNeedsUpdate = true;
      }
      if (!positionRef.color.equals(color.fromArray(colors3, i2 * 3))) {
        positionRef.color.toArray(colors3, i2 * 3);
        parentRef.current.geometry.attributes.color.needsUpdate = true;
      }
      if (positionRef.size !== sizes[i2]) {
        sizes.set([positionRef.size], i2);
        parentRef.current.geometry.attributes.size.needsUpdate = true;
      }
    }
  });
  const events = React70.useMemo(() => {
    const events2 = {};
    for (i2 = 0; i2 < refs.length; i2++) {
      var _refs$i$current;
      Object.assign(events2, (_refs$i$current = refs[i2].current) == null ? void 0 : _refs$i$current.__r3f.handlers);
    }
    return Object.keys(events2).reduce((prev, key) => __spreadProps(__spreadValues({}, prev), {
      [key]: (event) => {
        var _refs$event$index, _r3f, _r3f$handlers;
        const object = (_refs$event$index = refs[event.index]) == null ? void 0 : _refs$event$index.current;
        return object == null ? void 0 : (_r3f = object.__r3f) == null ? void 0 : (_r3f$handlers = _r3f.handlers) == null ? void 0 : _r3f$handlers[key](__spreadProps(__spreadValues({}, event), {
          object
        }));
      }
    }), {});
  }, [children, refs]);
  const api = React70.useMemo(() => ({
    subscribe: (ref2) => {
      setRefs((refs2) => [...refs2, ref2]);
      return () => setRefs((refs2) => refs2.filter((item) => item.current !== ref2.current));
    }
  }), []);
  return React70.createElement("points", _extends({
    matrixAutoUpdate: false,
    ref: react_merge_refs_esm_default([ref, parentRef])
  }, events, props), React70.createElement("bufferGeometry", null, React70.createElement("bufferAttribute", {
    attachObject: ["attributes", "position"],
    count: positions.length / 3,
    array: positions,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), React70.createElement("bufferAttribute", {
    attachObject: ["attributes", "color"],
    count: colors3.length / 3,
    array: colors3,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), React70.createElement("bufferAttribute", {
    attachObject: ["attributes", "size"],
    count: sizes.length,
    array: sizes,
    itemSize: 1,
    usage: DynamicDrawUsage
  })), React70.createElement(context5.Provider, {
    value: api
  }, children));
});
var Point = React70.forwardRef((_a, ref) => {
  var _b = _a, {
    children
  } = _b, props = __objRest(_b, [
    "children"
  ]);
  React70.useMemo(() => extend({
    Position
  }), []);
  const group = React70.useRef();
  const {
    subscribe
  } = React70.useContext(context5);
  React70.useLayoutEffect(() => subscribe(group), []);
  return React70.createElement("position", _extends({
    ref: react_merge_refs_esm_default([ref, group])
  }, props), children);
});
var PointsBuffer = React70.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    children,
    positions,
    colors: colors3,
    sizes,
    stride = 3
  } = _b, props = __objRest(_b, [
    "children",
    "positions",
    "colors",
    "sizes",
    "stride"
  ]);
  const pointsRef = React70.useRef(null);
  useFrame(() => {
    const attr = pointsRef.current.geometry.attributes;
    attr.position.needsUpdate = true;
    if (colors3) {
      attr.color.needsUpdate = true;
    }
    if (sizes) {
      attr.size.needsUpdate = true;
    }
  });
  return React70.createElement("points", _extends({
    matrixAutoUpdate: false,
    ref: react_merge_refs_esm_default([forwardedRef, pointsRef])
  }, props), React70.createElement("bufferGeometry", null, React70.createElement("bufferAttribute", {
    attachObject: ["attributes", "position"],
    count: positions.length / stride,
    array: positions,
    itemSize: stride,
    usage: DynamicDrawUsage
  }), colors3 && React70.createElement("bufferAttribute", {
    attachObject: ["attributes", "color"],
    count: colors3.length / stride,
    array: colors3,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), sizes && React70.createElement("bufferAttribute", {
    attachObject: ["attributes", "size"],
    count: sizes.length / stride,
    array: sizes,
    itemSize: 1,
    usage: DynamicDrawUsage
  })), children);
});
var Points = React70.forwardRef((props, forwardedRef) => {
  if (props.positions instanceof Float32Array) {
    return React70.createElement(PointsBuffer, _extends({}, props, {
      ref: forwardedRef
    }));
  }
  return React70.createElement(PointsInstances, _extends({}, props, {
    ref: forwardedRef
  }));
});

// node_modules/@react-three/drei/core/Instances.js
var React71 = __toModule(require_react());

// node_modules/react-composer/es/index.js
var import_react9 = __toModule(require_react());
var import_prop_types = __toModule(require_prop_types());
function Composer(props) {
  return renderRecursive(props.children, props.components);
}
Composer.propTypes = {
  children: import_prop_types.default.func.isRequired,
  components: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.element, import_prop_types.default.func])).isRequired
};
function renderRecursive(render3, remaining, results) {
  results = results || [];
  if (!remaining[0]) {
    return render3(results);
  }
  function nextRender(value) {
    return renderRecursive(render3, remaining.slice(1), results.concat([value]));
  }
  return typeof remaining[0] === "function" ? remaining[0]({ results, render: nextRender }) : (0, import_react9.cloneElement)(remaining[0], { children: nextRender });
}

// node_modules/@react-three/drei/core/Instances.js
var i3;
var instanceRef;
var globalContext = React71.createContext(null);
var parentMatrix2 = new Matrix4();
var instanceMatrix = new Matrix4();
var tempMatrix2 = new Matrix4();
var color2 = new Color();
var translation = new Vector3();
var rotation = new Quaternion();
var scale = new Vector3();
var Instance = React71.forwardRef((_a, ref) => {
  var _b = _a, {
    context: context7,
    children
  } = _b, props = __objRest(_b, [
    "context",
    "children"
  ]);
  React71.useMemo(() => extend({
    Position
  }), []);
  const group = React71.useRef();
  const {
    subscribe,
    getParent
  } = React71.useContext(context7 || globalContext);
  React71.useLayoutEffect(() => subscribe(group), []);
  return React71.createElement("position", _extends({
    instance: getParent(),
    instanceKey: group,
    ref: react_merge_refs_esm_default([ref, group])
  }, props), children);
});
var Instances = React71.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    range,
    limit = 1e3,
    frames = Infinity
  } = _b, props = __objRest(_b, [
    "children",
    "range",
    "limit",
    "frames"
  ]);
  const [{
    context: context7,
    instance
  }] = React71.useState(() => {
    const context8 = React71.createContext(null);
    return {
      context: context8,
      instance: React71.forwardRef((props2, ref2) => React71.createElement(Instance, _extends({
        context: context8
      }, props2, {
        ref: ref2
      })))
    };
  });
  const parentRef = React71.useRef(null);
  const [instances, setInstances] = React71.useState([]);
  const [[matrices, colors3]] = React71.useState(() => {
    const mArray = new Float32Array(limit * 16);
    for (i3 = 0; i3 < limit; i3++)
      tempMatrix2.identity().toArray(mArray, i3 * 16);
    return [mArray, new Float32Array([...new Array(limit * 3)].map(() => 1))];
  });
  React71.useLayoutEffect(() => {
    parentRef.current.count = parentRef.current.instanceMatrix.updateRange.count = parentRef.current.instanceColor.updateRange.count = Math.min(limit, range !== void 0 ? range : limit, instances.length);
  }, [instances, range]);
  React71.useEffect(() => {
    parentRef.current.instanceMatrix.needsUpdate = true;
  });
  let count = 0;
  useFrame(() => {
    if (frames === Infinity || count < frames) {
      parentRef.current.updateMatrix();
      parentRef.current.updateMatrixWorld();
      parentMatrix2.copy(parentRef.current.matrixWorld).invert();
      for (i3 = 0; i3 < instances.length; i3++) {
        instanceRef = instances[i3].current;
        instanceRef.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix2);
        if (!instanceMatrix.equals(tempMatrix2.fromArray(matrices, i3 * 16))) {
          instanceMatrix.toArray(matrices, i3 * 16);
          parentRef.current.instanceMatrix.needsUpdate = true;
        }
        if (!instanceRef.color.equals(color2.fromArray(colors3, i3 * 3))) {
          instanceRef.color.toArray(colors3, i3 * 3);
          parentRef.current.instanceColor.needsUpdate = true;
        }
      }
      count++;
    }
  });
  const api = React71.useMemo(() => ({
    getParent: () => parentRef,
    subscribe: (ref2) => {
      setInstances((instances2) => [...instances2, ref2]);
      return () => setInstances((instances2) => instances2.filter((item) => item.current !== ref2.current));
    }
  }), []);
  return React71.createElement("instancedMesh", _extends({
    userData: {
      instances
    },
    matrixAutoUpdate: false,
    ref: react_merge_refs_esm_default([ref, parentRef]),
    args: [null, null, 0],
    raycast: () => null
  }, props), React71.createElement("instancedBufferAttribute", {
    attach: "instanceMatrix",
    count: matrices.length / 16,
    array: matrices,
    itemSize: 16,
    usage: DynamicDrawUsage
  }), React71.createElement("instancedBufferAttribute", {
    attach: "instanceColor",
    count: colors3.length / 3,
    array: colors3,
    itemSize: 3,
    usage: DynamicDrawUsage
  }), typeof children === "function" ? React71.createElement(context7.Provider, {
    value: api
  }, children(instance)) : React71.createElement(globalContext.Provider, {
    value: api
  }, children));
});
function Merged(_a) {
  var _b = _a, {
    meshes,
    children
  } = _b, props = __objRest(_b, [
    "meshes",
    "children"
  ]);
  const isArray = Array.isArray(meshes);
  if (!isArray) {
    for (const key of Object.keys(meshes))
      if (!meshes[key].isMesh)
        delete meshes[key];
  }
  return React71.createElement(Composer, {
    components: (isArray ? meshes : Object.values(meshes)).map(({
      geometry,
      material
    }) => React71.createElement(Instances, _extends({
      key: geometry.uuid,
      geometry,
      material
    }, props)))
  }, (args) => isArray ? children(...args) : children(Object.keys(meshes).filter((key) => meshes[key].isMesh).reduce((acc, key, i4) => __spreadProps(__spreadValues({}, acc), {
    [key]: args[i4]
  }), {})));
}

// node_modules/@react-three/drei/core/Segments.js
var React72 = __toModule(require_react());
var context6 = React72.createContext(null);
var arrColor = (color3) => color3 instanceof Color ? color3.toArray() : color3;
var arrPos = (pos) => pos instanceof Vector3 ? pos.toArray() : pos;
var Segments = React72.forwardRef((props, forwardedRef) => {
  const _a = props, {
    limit = 1e3,
    lineWidth = 1,
    children
  } = _a, rest = __objRest(_a, [
    "limit",
    "lineWidth",
    "children"
  ]);
  const [segments, setSegments] = React72.useState([]);
  const [line] = React72.useState(() => new Line2());
  const [material] = React72.useState(() => new LineMaterial());
  const [geometry] = React72.useState(() => new LineSegmentsGeometry());
  const [resolution] = React72.useState(() => new Vector2(512, 512));
  const [positions] = React72.useState(() => Array(limit * 6).fill(0));
  const [colors3] = React72.useState(() => Array(limit * 6).fill(0));
  const api = React72.useMemo(() => ({
    subscribe: (ref) => {
      setSegments((segments2) => [...segments2, ref]);
      return () => setSegments((segments2) => segments2.filter((item) => item.current !== ref.current));
    }
  }), []);
  useFrame(() => {
    for (let i4 = 0; i4 < limit; i4++) {
      var _segments$i;
      const segment = (_segments$i = segments[i4]) == null ? void 0 : _segments$i.current;
      const segmentStart = segment ? arrPos(segment.start) : [0, 0, 0];
      const segmentEnd = segment ? arrPos(segment.end) : [0, 0, 0];
      const segmentColor = segment ? arrColor(segment.color) : [1, 1, 1];
      for (var j = 0; j < 3; j++) {
        positions[i4 * 6 + j] = segmentStart[j];
        positions[i4 * 6 + j + 3] = segmentEnd[j];
        colors3[i4 * 6 + j] = segmentColor[j];
        colors3[i4 * 6 + j + 3] = segmentColor[j];
      }
    }
    geometry.setColors(colors3);
    geometry.setPositions(positions);
    line.computeLineDistances();
  });
  return React72.createElement("primitive", {
    object: line,
    ref: forwardedRef
  }, React72.createElement("primitive", {
    object: geometry,
    attach: "geometry"
  }), React72.createElement("primitive", _extends({
    object: material,
    attach: "material",
    vertexColors: true,
    resolution,
    linewidth: lineWidth
  }, rest)), React72.createElement(context6.Provider, {
    value: api
  }, children));
});
var SegmentObject = class {
  constructor() {
    this.color = new Color("white");
    this.start = new Vector3(0, 0, 0);
    this.end = new Vector3(0, 0, 0);
  }
};
var Segment = React72.forwardRef((props, forwardedRef) => {
  const api = React72.useContext(context6);
  if (!api)
    throw "Segment must used inside Segments component.";
  const ref = React72.useRef();
  React72.useMemo(() => extend({
    SegmentObject
  }), []);
  React72.useLayoutEffect(() => api.subscribe(ref), []);
  return React72.createElement("segmentObject", _extends({
    ref: react_merge_refs_esm_default([ref, forwardedRef])
  }, props));
});

// node_modules/@react-three/drei/core/Detailed.js
var React73 = __toModule(require_react());
var Detailed = React73.forwardRef((_a, ref) => {
  var _b = _a, {
    children,
    distances
  } = _b, props = __objRest(_b, [
    "children",
    "distances"
  ]);
  const lodRef = React73.useRef(null);
  React73.useLayoutEffect(() => {
    const {
      current: lod
    } = lodRef;
    lod.levels.length = 0;
    lod.children.forEach((object, index) => lod.levels.push({
      object,
      distance: distances[index]
    }));
  });
  useFrame((state) => {
    var _lodRef$current;
    return (_lodRef$current = lodRef.current) == null ? void 0 : _lodRef$current.update(state.camera);
  });
  return React73.createElement("lOD", _extends({
    ref: react_merge_refs_esm_default([lodRef, ref])
  }, props), children);
});

// node_modules/@react-three/drei/core/Preload.js
var React74 = __toModule(require_react());
function Preload({
  all,
  scene,
  camera
}) {
  const gl = useThree(({
    gl: gl2
  }) => gl2);
  const dCamera = useThree(({
    camera: camera2
  }) => camera2);
  const dScene = useThree(({
    scene: scene2
  }) => scene2);
  React74.useLayoutEffect(() => {
    const invisible = [];
    if (all) {
      (scene || dScene).traverse((object) => {
        if (object.visible === false) {
          invisible.push(object);
          object.visible = true;
        }
      });
    }
    gl.compile(scene || dScene, camera || dCamera);
    const cubeRenderTarget = new WebGLCubeRenderTarget(128);
    const cubeCamera = new CubeCamera(0.01, 1e5, cubeRenderTarget);
    cubeCamera.update(gl, scene || dScene);
    cubeRenderTarget.dispose();
    invisible.forEach((object) => object.visible = false);
  }, []);
  return null;
}

// node_modules/@react-three/drei/core/BakeShadows.js
var import_react10 = __toModule(require_react());
function BakeShadows() {
  const gl = useThree((state) => state.gl);
  (0, import_react10.useEffect)(() => {
    gl.shadowMap.autoUpdate = false;
    gl.shadowMap.needsUpdate = true;
    return () => {
      gl.shadowMap.autoUpdate = gl.shadowMap.needsUpdate = true;
    };
  }, [gl.shadowMap]);
  return null;
}

// node_modules/@react-three/drei/core/meshBounds.js
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();
var _vA = new Vector3();
function meshBounds(raycaster, intersects) {
  const geometry = this.geometry;
  const material = this.material;
  const matrixWorld = this.matrixWorld;
  if (material === void 0)
    return;
  if (geometry.boundingSphere === null)
    geometry.computeBoundingSphere();
  _sphere.copy(geometry.boundingSphere);
  _sphere.applyMatrix4(matrixWorld);
  if (raycaster.ray.intersectsSphere(_sphere) === false)
    return;
  _inverseMatrix.copy(matrixWorld).invert();
  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null)
    return;
  intersects.push({
    distance: _vA.distanceTo(raycaster.ray.origin),
    point: _vA.clone(),
    object: this
  });
}

// node_modules/@react-three/drei/core/AdaptiveDpr.js
var React75 = __toModule(require_react());
function AdaptiveDpr({
  pixelated
}) {
  const gl = useThree((state) => state.gl);
  const active = useThree((state) => state.internal.active);
  const current = useThree((state) => state.performance.current);
  const initialDpr = useThree((state) => state.viewport.initialDpr);
  const setDpr = useThree((state) => state.setDpr);
  React75.useEffect(() => {
    const domElement = gl.domElement;
    return () => {
      if (active)
        setDpr(initialDpr);
      if (pixelated && domElement)
        domElement.style.imageRendering = "auto";
    };
  }, []);
  React75.useEffect(() => {
    setDpr(current * initialDpr);
    if (pixelated && gl.domElement)
      gl.domElement.style.imageRendering = current === 1 ? "auto" : "pixelated";
  }, [current]);
  return null;
}

// node_modules/@react-three/drei/core/AdaptiveEvents.js
var React76 = __toModule(require_react());
function AdaptiveEvents() {
  const get = useThree((state) => state.get);
  const current = useThree((state) => state.performance.current);
  React76.useEffect(() => {
    const enabled = get().raycaster.enabled;
    return () => void (get().raycaster.enabled = enabled);
  }, []);
  React76.useEffect(() => void (get().raycaster.enabled = current === 1), [current]);
  return null;
}
export {
  AdaptiveDpr,
  AdaptiveEvents,
  ArcballControls2 as ArcballControls,
  Backdrop,
  BakeShadows,
  Billboard,
  Bounds,
  Box,
  CameraShake,
  Center,
  Circle,
  Cloud,
  Cone,
  ContactShadows,
  CubeCamera2 as CubeCamera,
  CubicBezierLine,
  CurveModifier,
  CycleRaycast,
  Cylinder,
  Detailed,
  DeviceOrientationControls2 as DeviceOrientationControls,
  Dodecahedron,
  Edges,
  Effects,
  Environment,
  Extrude,
  FirstPersonControls2 as FirstPersonControls,
  Float,
  FlyControls2 as FlyControls,
  GizmoHelper,
  GizmoViewcube,
  GizmoViewport,
  GradientTexture,
  Html,
  Icosahedron,
  Image,
  Instance,
  Instances,
  IsObject,
  Lathe,
  Line,
  Loader,
  MapControls2 as MapControls,
  Merged,
  MeshDistortMaterial,
  MeshReflectorMaterial2 as MeshReflectorMaterial,
  MeshWobbleMaterial,
  Octahedron,
  OrbitControls2 as OrbitControls,
  OrthographicCamera2 as OrthographicCamera,
  PerspectiveCamera2 as PerspectiveCamera,
  Plane2 as Plane,
  Point,
  PointMaterial,
  PointMaterialImpl,
  PointerLockControls2 as PointerLockControls,
  Points,
  PointsBuffer,
  Polyhedron,
  PositionalAudio,
  Preload,
  PresentationControls,
  QuadraticBezierLine,
  Reflector,
  Ring,
  RoundedBox,
  ScreenQuad,
  Scroll,
  ScrollControls,
  Segment,
  Segments,
  Select,
  Shadow,
  Sky2 as Sky,
  Sphere2 as Sphere,
  SpotLight,
  Stage,
  Stars,
  Stats,
  Tetrahedron,
  Text2 as Text,
  Torus,
  TorusKnot,
  TrackballControls2 as TrackballControls,
  TransformControls2 as TransformControls,
  Tube,
  calcPosFromAngles,
  isWebGL2Available,
  meshBounds,
  shaderMaterial,
  softShadows,
  useAnimations,
  useAspect,
  useBVH,
  useBounds,
  useCamera,
  useContextBridge,
  useCubeTexture,
  useCursor,
  useDepthBuffer,
  useDetectGPU,
  useFBO,
  useFBX,
  useGLTF,
  useGizmoContext,
  useHelper,
  useIntersect,
  useKTX2,
  useMatcapTexture,
  useNormalTexture,
  useProgress,
  useScroll,
  useSelect,
  useTexture
};
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=@react-three_drei.js.map
